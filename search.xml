<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[风控用户识别方法]]></title>
    <url>%2F2017%2F12%2F09%2F%E9%A3%8E%E6%8E%A7%E7%94%A8%E6%88%B7%E8%AF%86%E5%88%AB%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言因为工作方向相关，之前我也尝试着在Google、arXiv、wikipedia等等地方搜一些风控识别的资料或者思路，但是事与愿违的是，绝大多数的与风控算法都毫无关系，基本上都是推销自己家的产品的，所以，我之前也尝试着写了一些方法的梳理，如: 多算法识别撞库刷券等异常用户 异常值识别与处理 但是在我前几天再回过头去看自己写的这些东西的时候，作为一个老司机来说，我都不想去看一篇又一篇动则上千字的文章，理论交错，文笔粗陋，正巧现在公司内部也有一个风控的项目，所以，我准备做一个开源的项目fast_risk_control，核心在于： 简单操作，几乎不用多少调参，自动识别异常点 理论清晰，支持的方法多，兼容性好 集成数据预处理的过程，减轻前置工作量 “纠结”了几个朋友的情况下，一期已经完工，主要是搭建了最简单的框架，我相信，这只是一个开始，欢迎大家试用，也欢迎每一个人来批评，更希望有想法的同学一起来做这个事情。 接下来，让我们来讲讲，一期我们做了什么？核心我们一期做的异常点识别中，核心是利用的14年周志华教授提出的isolation forest算法进行识别，详细的理论部分请参见：Isolation Forest，重复说一个事情的意义也不大。这边需要解释几点： 具体是怎么得到当前的算法流程的呢？ 为什么用当前的算法进行识别而不用其他的识别算法？ 当前的设计下存在哪些问题？ 未来的方向会在哪边？ 让我们来一一来回答这些问题。 为了用Isolation Forest而不用其他的识别算法？在设计这套算法之前，我们其实是遇到了一个实际的业务问题，黑产撞库。相信大家毫不陌生这个词，无论是阿里、京东、滴滴还是腾讯，被撞库是一件普通了不能再普通的事情，“黑产”的人从第三方渠道，获取到你历史上的手机号和一些你曾经用的密码，重复的登陆，暴力的尝试，如果你的密码设置的比较简单，比如：“123456”，“qwerty”…非常容易被破解，然后再根据你历史下单的情况，进行假冒“客服”退款，进行诈骗，百度一搜就有一堆这样的新闻： 频发假冒电商客服 当心!近期有人冒充假客服行骗 几分钟骗走市民八九万元… 所以，我们需要阻止“黑产”人员进行这样的暴力破解，获取用户的资料，由此而引发了我们对这个问题的思考。我们在对这个问题分析的时候，巧妙的发现了如下的一些信息： 因为涉及公司机密，这边隐去了具体坐标和值，很容易发现以下问题： 正常扇面内数据分布密集，未知扇面内数据分布松散，异常扇面内数据分布稀疏 正常扇面内的数据量占全量数据的绝大多数 不存在明显的分割线，正常扇面和异常扇面存在过度地带 这个给了我们一些启发，我们做了如下的分析： 我们观察了异常扇面内的用户黑白比，如我们预计的黑白比为20:3，也就是说分布远离大量数据点的用户绝大多数存在问题 为止区域的用户黑白比为1:2，这说明在黑白用户之间不存在明显的界限，有交错地带 正常区域内也存在黑名单用户，比例在504:1，也就是说，我们划分有一定识别能力，但是还是不能做到全量识别 综合上述这些预先的处理，我们要用算法完成三件事情：1.切分全量用户，做到识别出正常，未知，异常用户2.识别出异常用户和正常用户之间的差异约束切割3.在异常用户+未知用户里面，找出利用差异约束切割出黑名单 为什么用当前的算法进行识别而不用其他的识别算法？切分数据的时候，我们这边采用的是切比雪夫切割。非理工科的同学可能比较疑惑什么是切比雪夫切割，这边如果数据是正态下，箱式图的Q3+3/2xQI作为上top点进行切割，大家就应该很熟悉了，其实利用的就是数据出现的概率。上面这张图很好的解释了，在数据服从正态分布的情况下，出现数据值比均值+3x标准差要大的概率不足0.1%，所以，我们可以认为这些数据是异常点了。那现在出现了一个问题，日常数据分布都不一定是正态的，所以引出来了类似的切比雪夫理论，它用的是马氏距离距离中心点的程度，详细的马氏距离理论见马氏距离分布。 切分完成数据之后，我们要做寻找差异约束切割逻辑。从最上面的扇面图，我们很容易发现，正常数据与异常数据之间的密度差异很明显，所以如何识别密度差异的算法就是我们需要的，这边我大概找了6、7种常见的切分方法，这边主要讲三种：isolation forest，lof，distance similarity。理论我之前也讲过，贴上地址，不废话了：密度算法。这边主要展示效果差异：通过68个数据集，很明显的可以看出LOF的识别出来的用户的异常用户异常程度是低于Isolation Forest和Distince Similarity的，起码在我们这些数据集样本中，Isolation Forest和Distince Similarity识别效果差异不大，所以，我们再考虑了另一个性能问题：我们用了CV=10的交叉检验，发现，平均下来，Isolation Forest识别速度是Distince Similarity的1/3以下。综合上述，还有一些其他因素，最后我们选择了Isoation Forest的方法。 当前的设计下存在哪些问题？上面说的都是比较正面的问题，让我们看看，有哪些缺点。首先，从头到尾，我们一直在围绕密度差异这个问题，但是就我平时做的一些小爬虫都知道，降低暴力获取的速度，慢慢搞，这时候就以上的方法就无法做到有效的识别。除此之外，因为我们用了切比雪夫不等式，所以对其有概念的同学知道，算马氏距离的时候需要算协方差矩阵，当数据量异常异常大(我测算的是12mx100)的时候计算资源紧张，可能算不出来；数据量异常异常小的时候feature严重共线性，也可能计算不出来。 未来的方向会在哪边？所以，后续我们会新增其他算法，支持过大过小情况下的识别方法。针对数据量过小的识别情况，我在V0.0.3版本下更新了一个简单识别的方法，之后会优化更好的算法替代掉的。只要数据量太大无法计算的问题，我之后会采取矩阵切割分块计算的方法，这个是后话了。 最后，我们以当前算法包的使用来结束整篇介绍：12#安装pip install fast_risk_control 自动识别过程：123from fast_risk_control import fast_risk_controldata = pd.read_table('../路径')#数据可以在https://github.com/sladesha/machine_learning/tree/master/data下的data_all.csv获取fast_risk_control.transform(data) 相关的结果显示：12345#Attributes: #正常用户的各feature的状态，用来对比异常数据的结果fast_risk_control.heavy_point #识别出来的outlier及对应的feature值，prob越小代表越异常fast_risk_control.outlier_details 以上部分内容截取自我的github，希望对大家有一些帮助。 最后，谢谢大家的阅读，欢迎大家关注我的个人博客。 本文拒绝任何形式的转载，若要转载请联系stw386@sina.com]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>风控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FM理论解析及应用]]></title>
    <url>%2F2017%2F12%2F04%2FFM%E7%90%86%E8%AE%BA%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[FM的产生背景我其实没有做过很多CTR预估的事情，但是我在工作中常常遇到CRM流失预估、订单预估这些依赖于特征工程的事情，其中就涉及到特征的组合问题。 one-hot过程在feature选取过程中，不可避免的会出现，学历这种高中、大学、研究生等多分类的feature，在实际应用中，我们对单个feature需要进行一种one hot过程，就是将原来的学历拆解为 是否为高中，是否为大学，注意，可以不用加是否为研究生一列，因为是否为高中，是否为大学的两列已经可以推导这个用户是否为研究生，加上这一列有时候反而会共线性。但是这样做，看起来没什么问题，想想看要是100个这样的特征，每个特征有100个这样单独的feature value的话，整体数据将是一个非常庞大的稀疏矩阵，无论是计算还是分析都是会存在巨大的问题的，所以看看我们能不能组合一些特征降低维度。 什么叫做组合问题现在有一组数据，其中特征包含性别（男女），学历（高中，大学，研究生），想要判断这两个feature对是否对化妆品感谢兴趣。单独的观察性别这一栏，发现有一定相关性，但是比较弱，并不是所有的女性都对化妆品感兴趣；单独的观察学历这一栏也发现，学历与对化妆品感兴趣的程度并没有显著的相关性。其实，我们可以从自己的感知理解，首先，数据中女生可能比男生对化妆品更感兴趣，但是女生数据中存在大量的高中生，相对于高中生而言，大学生和研究生可能对化妆品更加感兴趣一点，所以原来的两个feature：性别，学历就组合成了是否为性别女+学历大于高中一个feature，这就是特征组合的过程。如果feature总个数少还可以，要是要有上千上万个，光两两组和就有n*(n-1)/2种可能，所以我们需要想一个其他办法。 组合特征后的表达形式首先，我们都知道一般的线性模型为： 为了考虑组合特征的作用，我们采用多项式来代表，形如特征xi与xj的组合用xixj表示，具体的表达式如下：其中，wij为组合特征xixj的权重，n表示样本的feature个数，xi为第i个feature。 方程定义完成了，下面就要开始数学定义 对每一个特征xi引入辅助向量Vi=(vi1,vi2,…vik),这边的k就是矩阵拆解的规模值，利用ViVj.T对交叉项的系数wij进行估计,及则这边需要注意一点，k理论上讲，越大越能强化拟合的能力，但是实际在运算过程中，一来受限于计算能力，二来受限于数据量，过大的k只会带来过拟合的问题。我实测了40w左右的数据，观察到k值在6-8左右，valid集合数据拟合效果最优，仅供参考 很明显，上面这么多未知数：1+n是线性未知数个数，nxfeature是组合特征的未知数个数，常规求解的效率可想而知。但是看到xixj这样的形式，我们很容易联想到：2ab = (a+b)^2 -a^2 -b^2，所以在解决这个wij、xi、xj点积的问题上，我们采用了：1/2 * ( (a+b+c)^2 - a^2 - b^2 - c^2)的方式 下面让我们来解这个式子这边需要一点导数功底，我们先来看对w0也就是bias求导，这个毫无意外，梯度为1；再对wi求导，这个也很简单，xi即可，这个也很简单，少许繁琐的就是wij求导，让我来仔细看看：ok，我知道我的字很丑，别说话，看问题，所以我们可以总结为下面这个网上到处都有的式子：这个式子就是上面这么来的。把上面的那个点积形式代入求解及为： 引申一个FFM概念在FM模型中，每一个特征会对应一个隐变量，但在FFM模型中，认为应该将特征分为多个field，每个特征对应每个field分别有一个隐变量。 举个例子，我们的样本有3种类型的字段：qualifications, age, gender，分别可以代表学历，年龄段，性别。其中qualifications有3种数据，age有5种数据，gender有男女2种，经过one-hot编码以后，每个样本有7个特征，其中只有3个特征非空。如果使用FM模型，则7个特征，每个特征对应一个隐变量。如果使用FFM模型，则7个特征，每个特征对应3个隐变量，即每个类型对应一个隐变量，及对应qualifications, age, gender各占一个。 我看了Yu-Chin Juan实现了一个C++版的FFM模型的源码，倒过来想他的表达式应该是这样的：其他模块都与fm差不多，主要看Vj1f2Vj2f1这个东西。我们假设j1特征属于f1这个field，j2特征属于f2这个feild，则Vj1f2表示j1这个特征对应j2所属的field的隐变量。很恶心的解释，通俗的来讲就是，性别为女与学历这个field的组合有个隐变量，性别女与年龄这个field的组合又有一个不一样的隐变量，而却不考虑到底是什么学历是啥，年龄具体到什么细节。Yu-Chin Juan大神在实际写code的过程中，干掉来常数和一次项，可能是为了方便计算，保留的如下：整理的最优化损失函数如下：前面为l2正则，后面为交互熵形式，我们看到了y*Φ(V,x)这个及其类似hinge loss里面的1−t⋅y部分，所以注意这边的y属于{-1，1}这边的求导，我算了一个小时都没搞出来，等哪天有空了，再仔细的去算一下，去翻了原论文，最后的迭代形式如下：η是常规的速率，V是初始均匀分布即可 代码实现我这边完成了FM的代码实现，详细见我的github：fm代码为了方便不想看细节，只想撸代码的同学，我打包上传到了pypi，你只需要pip install fm_easy_run即可体验至于ffm，我下午实在没写出来，对不起彭老师，丢脸了，后续看什么时候有空再研究一下。demo如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import pandas as pdimport numpy as npimport syssys.path.append('/Users/slade/Documents/GitHub/machine_learning/FM/script/')from fm import fm#local pathpath = '/Users/slade/Documents/GitHub/machine_learning/data/data_all.txt'#create modelmodel = fm(iter = 1)#fitmodel.fit(path)# In [11]: model.fit(a)# the no 0 times, the loss arrach 正方向#predictX = pd.read_table(path)#第一列是手机号，第二列是因变量，都去掉X = np.array(X.iloc[:,2:])model.predict(X)# [0.0068623909053069695,# 0.03070660744280522,# 0.62197610204590048,# 0.11532505686311838,# 0.020968338370392487,# 0.017638116663948621,# 0.01831564127277888,# 0.10688694669470335,# ...]#_wmodel._w# array([[-1.08728341],# [ 0.11213358],# [ 0.05307469],# [-1.68175973],# [-0.01022176],# [-0.0144888 ],# [-1.37021031],# [-1.13095253],# [-0.12314619]])#_vmodel._v# array([[ 0.0764419 , 0.0764419 , 0.0764419 , 0.0764419 , 0.0764419 ,# 0.0764419 , 0.0764419 , 0.0764419 ],# [ 0.3254763 , 0.3254763 , 0.3254763 , 0.3254763 , 0.3254763 ,# 0.3254763 , 0.3254763 , 0.3254763 ],# [ 0.35334494, 0.35334494, 0.35334494, 0.35334494, 0.35334494,# 0.35334494, 0.35334494, 0.35334494],# [-0.1346388 , -0.1346388 , -0.1346388 , -0.1346388 , -0.1346388 ,# -0.1346388 , -0.1346388 , -0.1346388 ],# [ 0.34120166, 0.34120166, 0.34120166, 0.34120166, 0.34120166,# 0.34120166, 0.34120166, 0.34120166],# [ 0.34007967, 0.34007967, 0.34007967, 0.34007967, 0.34007967,# 0.34007967, 0.34007967, 0.34007967],# [ 0.05097865, 0.05097865, 0.05097865, 0.05097865, 0.05097865,# 0.05097865, 0.05097865, 0.05097865],# [ 0.12091724, 0.12091724, 0.12091724, 0.12091724, 0.12091724,# 0.12091724, 0.12091724, 0.12091724],# [ 0.28326789, 0.28326789, 0.28326789, 0.28326789, 0.28326789,# 0.28326789, 0.28326789, 0.28326789]])#_w_0model._w_0#-1.8927186959057687 最后，着重提示，本文很多思路很解析都参考的Yu-Chin Juan的源代码，附上github地址，欢迎去关注原作者的内容，感谢大神带路，谢谢大家阅读。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>特征组合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SMOTE算法]]></title>
    <url>%2F2017%2F12%2F01%2FSMOTE%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[17.11.28更新一下：最近把这个算法集成到了数据预处理的python工程代码中了，不想看原理想直接用的，有简易版的python开发：特征工程代码模版 ，进入页面后ctrl+F搜smote就行，请自取 之前一直没有用过python，最近做了一些数量级比较大的项目，觉得有必要熟悉一下python，正好用到了smote，网上也没有搜到，所以就当做一个小练手来做一下。 首先，看下Smote算法之前，我们先看下当正负样本不均衡的时候，我们通常用的方法： 抽样常规的包含过抽样、欠抽样、组合抽样过抽样：将样本较少的一类sample补齐欠抽样：将样本较多的一类sample压缩组合抽样：约定一个量级N，同时进行过抽样和欠抽样，使得正负样本量和等于约定量级N 这种方法要么丢失数据信息，要么会导致较少样本共线性，存在明显缺陷 权重调整常规的包括算法中的weight，weight matrix改变入参的权重比，比如boosting中的全量迭代方式、逻辑回归中的前置的权重设置 这种方式的弊端在于无法控制合适的权重比，需要多次尝试 核函数修正通过核函数的改变，来抵消样本不平衡带来的问题 这种使用场景局限，前置的知识学习代价高，核函数调整代价高，黑盒优化 模型修正通过现有的较少的样本类别的数据，用算法去探查数据之间的特征，判读数据是否满足一定的规律比如，通过线性拟合，发现少类样本成线性关系，可以新增线性拟合模型下的新点 实际规律比较难发现，难度较高 SMOTE（Synthetic minoritye over-sampling technique,SMOTE）是Chawla在2002年提出的过抽样的算法，一定程度上可以避免以上的问题 下面介绍一下这个算法： 很明显的可以看出，蓝色样本数量远远大于红色样本，在常规调用分类模型去判断的时候可能会导致之间忽视掉红色样本带了的影响，只强调蓝色样本的分类准确性，这边需要增加红色样本来平衡数据集 Smote算法的思想其实很简单，先随机选定n个少类的样本，如下图 再找出最靠近它的m个少类样本，如下图 再任选最临近的m个少类样本中的任意一点， 在这两点上任选一点，这点就是新增的数据样本 R语言上的开发较为简单，有现成的包库，这边简单介绍一下：1234567rm(list=ls())install.packages(“DMwR”,dependencies=T)library(DMwR)#加载smote包newdata=SMOTE(formula,data,perc.over=,perc.under=)#formula:申明自变量因变量#perc.over：过采样次数#perc.under：欠采样次数 效果对比：简单的看起来就好像是重复描绘了较少的类这边的smote是封装好的，直接调用就行了，没有什么特别之处 这边自己想拿刚学的python练练手，所有就拿python写了一下过程：12345678910111213# -*- coding: utf-8 -*-import numpy as npimport pandas as pdfrom sklearn.preprocessing import StandardScalerfrom numpy import *import matplotlib.pyplot as plt#读数据data = pd.read_table('C:/Users/17031877/Desktop/supermarket_second_man_clothes_train.txt', low_memory=False)#简单的预处理test_date = pd.concat([data['label'], data.iloc[:, 7:10]], axis=1)test_date = test_date.dropna(how='any') 数据大致如下：12345678910test_date.head()Out[25]: label max_date_diff max_pay cnt_time0 0 23.0 43068.0 151 0 10.0 1899.0 22 0 146.0 3299.0 213 0 30.0 31959.0 354 0 3.0 24165.0 98test_date['label'][test_date['label']==0].count()/test_date['label'][test_date['label']==1].count()Out[37]: 67 label是样本类别判别标签，1:0=67:1，需要对label=1的数据进行扩充 12345678# 筛选目标变量aimed_date = test_date[test_date['label'] == 1]# 随机筛选少类扩充中心index = pd.DataFrame(aimed_date.index).sample(frac=0.1, random_state=1)index.columns = ['id']number = len(index)# 生成array格式aimed_date_new = aimed_date.ix[index.values.ravel(), :] 随机选取了全量少数样本的10%作为数据扩充的中心点 12345678910111213# 自变量标准化sc = StandardScaler().fit(aimed_date_new)aimed_date_new = pd.DataFrame(sc.transform(aimed_date_new))sc1 = StandardScaler().fit(aimed_date)aimed_date = pd.DataFrame(sc1.transform(aimed_date))# 定义欧式距离计算def dist(a, b): a = array(a) b = array(b) d = ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2 + (a[3] - b[3]) ** 2) ** 0.5 return d 下面定义距离计算的方式，所有算法中，涉及到距离的地方都需要标准化去除冈量，也同时加快了计算的速度这边采取了欧式距离的方式，更多计算距离的方式参考：多种距离及相似度的计算理论介绍 1234567891011# 统计所有检验距离样本个数row_l1 = aimed_date_new.iloc[:, 0].count()row_l2 = aimed_date.iloc[:, 0].count()a = zeros((row_l1, row_l2))a = pd.DataFrame(a)# 计算距离矩阵for i in range(row_l1): for j in range(row_l2): d = dist(aimed_date_new.iloc[i, :], aimed_date.iloc[j, :]) a.ix[i, j] = db = a.T.apply(lambda x: x.min()) 调用上面的计算距离的函数，形成一个距离矩阵 1234567891011121314151617181920# 找到同类点位置h = []z = []for i in range(number): for j in range(len(a.iloc[i, :])): ai = a.iloc[i, j] bi = b[i] if ai == bi: h.append(i) z.append(j) else: continuenew_point = [0, 0, 0, 0]new_point = pd.DataFrame(new_point)for i in range(len(h)): index_a = z[i] new = aimed_date.iloc[index_a, :] new_point = pd.concat([new, new_point], axis=1)new_point = new_point.iloc[:, range(len(new_point.columns) - 1)] 再找到位置的情况下，再去原始的数据集中根据位置查找具体的数据 123456789101112import randomr1 = []for i in range(len(new_point.columns)): r1.append(random.uniform(0, 1))new_point_last = []new_point_last = pd.DataFrame(new_point_last)# 求新点 new_x=old_x+rand()*(append_x-old_x)for i in range(len(new_point.columns)): new_x = (new_point.iloc[1:4, i] - aimed_date_new.iloc[number - 1 - i, 1:4]) * r1[i] + aimed_date_new.iloc[ number - 1 - i, 1:4] new_point_last = pd.concat([new_point_last, new_x], axis=1)print new_point_last 最后，再根据smote的计算公式new_x=old_x+rand()*(append_x-old_x)，计算出新的点即可，python练手到此就结束了 其实，在这个结果上，我们可以综合Tomek link做一个集成的数据扩充的算法，思路如下：假设，我们利用上述的算法产生了两个青色方框的新数据点：我们认为，对于新产生的青色数据点与其他非青色样本点距离最近的点，构成一对Tomek link，如下图框中的青蓝两点 我们可以定义规则：当以新产生点为中心，Tomek link的距离为范围半径，去框定一个空间，空间内的少数类的个数/多数类的个数&lt;最低阀值的时候，认为新产生点为“垃圾点”，应该剔除或者再次进行smote训练；空间内的少数类的个数/多数类的个数&gt;=最低阀值的时候,在进行保留并纳入smote训练的初始少类样本集合中去抽样所以，剔除左侧的青色新增点，只保留右边的新增数据如下： 参考文献： https://www.jair.org/media/953/live-953-2037-jair.pdf https://github.com/fmfn/UnbalancedDataset Batista, G. E., Bazzan, A. L., &amp; Monard, M. C. (2003, December). Balancing Training Data for Automated Annotation of Keywords: a Case Study. In WOB (pp. 10-18). Batista, G. E., Prati, R. C., &amp; Monard, M. C. (2004). A study of the behavior of several methods for balancing machine learning training data. ACM Sigkdd Explorations Newsletter, 6(1), 20-29.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>理论解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python开发：特征工程代码模版(二)]]></title>
    <url>%2F2017%2F12%2F01%2Fpython%E5%BC%80%E5%8F%91%EF%BC%9A%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[update:17.12.21 : Mutual Information互信息中mic_entroy函数里的I应该是i，已修正 转载请注明文章来源：python开发：特征工程代码模版（二），你们免费转我文章，不标注来源就算了，现在还开始写“原创”，这就过分了～ 正题开始：这篇文章是入门级的特征处理的打包解决方案的python实现汇总，如果想get一些新鲜血液的朋友可以叉了，只是方便玩数据的人进行数据特征筛选的代码集合，话不多说，让我们开始。 首先，让我们看一张入门级别的数据预处理的基本操作图，网上有很多版本，这个是我自己日常干活的时候必操作的行为罗列，其中数据整理部分已经在上一篇文章中给出了，下面我们讲一起来看看特征筛选这块。此图请尊重一下我，别拿出去传播，纯属个人的方法论，大家看看就行，谢谢。网上有其他版本的，你们去传播那些就ok了～ 方差选择法1234567def var_filter(data, k=None): var_data = data.var().sort_values() if k is not None: new_data = VarianceThreshold(threshold=k).fit_transform(data) return var_data, new_data else: return var_data 这个方法的思路很明确，我们筛掉方差过小的feature，也很好理解，一列值完全或者几乎完全一致的feature对于我们去训练最后的模型没有任何好处。熵理论也同样印证了这一点。 线性相关系数衡量123456789101112131415161718192021def pearson_value(data, label, k=None): label = str(label) # k为想删除的feature个数 Y = data[label] x = data[[x for x in data.columns if x != label]] res = [] for i in range(x.shape[1]): data_res = np.c_[Y, x.iloc[:, i]].T cor_value = np.abs(np.corrcoef(data_res)[0, 1]) res.append([label, x.columns[i], cor_value]) res = sorted(np.array(res), key=lambda x: x[2]) if k is not None: if k &lt; len(res): new_c = [] # 保留的feature for i in range(len(res) - k): new_c.append(res[i][1]) return res, new_c else: print('feature个数越界～') else: return res 当你明确了自变量与因变量之间存在线性关系的时候，你就需要剔除掉一些关心比较弱的变量，奥卡姆剃刀原理告诉我们，在尽可能压缩feature个数大小的情况下去得到效果最优的模型才是合理模型。 共线性检验123456789101112131415161718192021222324252627def vif_test(data, label, k=None): label = str(label) # k为想删除的feature个数 x = data[[x for x in data.columns if x != label]] res = np.abs(np.corrcoef(x.T)) vif_value = [] for i in range(res.shape[0]): for j in range(res.shape[0]): if j &gt; I: vif_value.append([x.columns[i], x.columns[j], res[i, j]]) vif_value = sorted(vif_value, key=lambda x: x[2]) if k is not None: if k &lt; len(vif_value): new_c = [] # 保留的feature for i in range(len(x)): if vif_value[-i][1] not in new_c: new_c.append(vif_value[-i][1]) else: new_c.append(vif_value[-i][0]) if len(new_c) == k: break out = [x for x in x.columns if x not in new_c] return vif_value, out else: print('feature个数越界～') else: return vif_value 2-3年前面试必考题，什么叫做共线性？如何解决共线性？答案之一就是共线性检验啊，判断feature之间的相关性，剔除相关性较高的feature，在R语言里面有个VIF函数可以直接求的。除此之外，采用非线性函数做特征拆解也是很好的方法。共线性严重的情况下，会导致泛化误差异常大，需着重注意～ Mutual Information互信息12345678910111213141516171819202122232425262728293031323334353637383940def MI(X, Y): # len(X) should be equal to len(Y) # X,Y should be the class feature total = len(X) X_set = set(X) Y_set = set(Y) if len(X_set) &gt; 10: print('%s非分类变量，请检查后再输入' % X_set) sys.exit() elif len(Y_set) &gt; 10: print('%s非分类变量，请检查后再输入' % Y_set) sys.exit() # Mutual information MI = 0 eps = 1.4e-45 for i in X_set: for j in Y_set: indexi = np.where(X == i) indexj = np.where(Y == j) ijinter = np.intersect1d(indexi, indexj) px = 1.0 * len(indexi[0]) / total py = 1.0 * len(indexj[0]) / total pxy = 1.0 * len(ijinter) / total MI = MI + pxy * np.log2(pxy / (px * py) + eps) return MIdef mic_entroy(data, label): # mic_value值越小，两者相关性越弱 label = str(label) # k为想删除的feature个数 x = data[[x for x in data.columns if x != label]] Y = data[label] mic_value = [] for i in range(x.shape[1]): if len(set(x.iloc[:, i])) &lt;= 10: res = MI(Y, x.iloc[:, i]) mic_value.append([x.columns[i], res]) mic_value = sorted(mic_value, key=lambda x: x[1]) return mic_value 本来我想偷懒，直接import minepy然后就得了，发现真的是特么难装，各种报错，一怒之下自己写了，这边求大佬告知，为什么pip install minepy会有这样的问题：12345678xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrunerror: command '/usr/bin/clang' failed with exit status 1 ----------------------------------------Command "/Users/slade/anaconda3/bin/python -u -c "import setuptools, tokenize;__file__='/private/var/folders/hv/kfb7n4lj06590hqxjv6f3dd00000gn/T/pip-build-hr9ej0lw/minepy/setup.py';f=getattr(tokenize, 'open', open)(__file__);code=f.read().replace('\r\n', '\n');f.close();exec(compile(code, __file__, 'exec'))" install --record /var/folders/hv/kfb7n4lj06590hqxjv6f3dd00000gn/T/pip-30cn7rbs-record/install-record.txt --single-version-externally-managed --compile" failed with error code 1 in /private/var/folders/hv/kfb7n4lj06590hqxjv6f3dd00000gn/T/pip-build-hr9ej0lw/minepy/ 回到正题，互信息其实很简单，我们看个公式I(X;Y)=H(X)-H(X|Y)，看完是不是超级清晰了，其实就是X发生的概率中去掉Y发生后X发生的概率，或者说是一个随机变量由于已知另一个随机变量而减少的不肯定性。计算公式如下，你们也可以在上面的代码里找到影子。最后还是吐槽下，这个minepy太难装了，为了个互信息，不至于不至于～ 递归特征消除法123456789101112131415def wrapper_way(data, label, k=3): # k 为要保留的数据feature个数 label = str(label) label_data = data[label] col = [x for x in data.columns if x != label] train_data = data[col] res = pd.DataFrame( RFE(estimator=LogisticRegression(), n_features_to_select=k).fit_transform(train_data, label_data)) res_c = [] for i in range(res.shape[1]): for j in range(data.shape[1]): if (res.iloc[:, i] - data.iloc[:, j]).sum() == 0: res_c.append(data.columns[j]) res.columns = res_c return res 这边开始的代码就基本上是方法梳理了，没啥亮点，我就大概和大家聊聊，递归特征消除法，用R语言里面的step()函数是一毛一样的东西，都是循环sample特征，选一个对于当前模型，特征组合最好的结果。如果数据量大，你会有非一般的感觉，这边就有小trick了，以后有空可以和大家分享～ l1/l2正则方法12345678910111213def embedded_way(data, label, way='l2', C_0=0.1): label = str(label) label_data = data[label] col = [x for x in data.columns if x != label] train_data = data[col] res = pd.DataFrame(SelectFromModel(LogisticRegression(penalty=way, C=C_0)).fit_transform(train_data, label_data)) res_c = [] for i in range(res.shape[1]): for j in range(data.shape[1]): if (res.iloc[:, i] - data.iloc[:, j]).sum() == 0: res_c.append(data.columns[j]) res.columns = res_c return res 正则理论参考：总结：常见算法工程师面试题目整理(二)，这边要提一点，并不是所有情况下都需要正则预处理的，很多算法自带正则，比如logistic啊，比如我们自己去写tensorflow神经网络啊，模型会针对性的解决问题，而这边单纯用的logstic方法来筛选，相对而言内嵌的效果会更好的。 基于树模型特征选择12345678910111213def tree_way(data,label): label = str(label) label_data = data[label] col = [x for x in data.columns if x != label] train_data = data[col] res = pd.DataFrame(SelectFromModel(GradientBoostingClassifier()).fit_transform(train_data, label_data)) res_c = [] for i in range(res.shape[1]): for j in range(data.shape[1]): if (res.iloc[:, i] - data.iloc[:, j]).sum() == 0: res_c.append(data.columns[j]) res.columns = res_c return res 这边用的是决策树每次分支下，如果改变一列值为随机值，观察对整体数据效果的影响。举个通俗易懂的例子，看看你在公司的重要性，就去和你老板提离职，要是老板疯狂给你加工资做你的思想工作，代表你很重要；如果你的老板让你去财务结账，代表你没啥意义。这里你就是这个feature，你老板就是数据效果的检验指标，常见的就是oob之类的。 这边facebook有个非常好的拓展的思路，但是大家都吹的多实际应用很少，我最近在搞这事情，等下更完这边的特征工程和下面一个nlp的case后，我想专门聊聊这个事情，用的就是决策树的另一角度，以叶子结点代替原feature，做到了非线性的特征融入线性模型，虽然很老套，但是我稍稍做了测试，效果斐然： 最后的最后，感谢大家阅读，希望能够给大家带来收获，谢谢～]]></content>
      <categories>
        <category>代码集合</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多算法识别撞库刷券等异常用户]]></title>
    <url>%2F2017%2F12%2F01%2F%E5%A4%9A%E7%AE%97%E6%B3%95%E8%AF%86%E5%88%AB%E6%92%9E%E5%BA%93%E5%88%B7%E5%88%B8%E7%AD%89%E5%BC%82%E5%B8%B8%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[在运营业务中，绝大多数公司会面临恶意注册，恶意刷接口，恶意刷券等流量问题，此类问题的常规解决方案都是拍定单位时间内的ip访问上限次数、qps上限次数等等，会存在误伤、频繁修改阀值等问题。 问题剖析：此类问题的关键在识别出与正常数据集群差异较大的离群点。所以，存在两个难点： 1.难以找到一个很清晰的边界，界定什么是正常用户，什么是异常用户 2.维数灾难及交叉指标计算之间的高频计算性能瓶颈 算法概述： 1.图形位置分布 2.统计方法检测 3.距离位置检测 4.密度位置检测 5.无监督模型识别 算法详述：图形位置分布当我们不需要长期监控异常用户，只需要少数几次识别异常用户，且精度要求不高的时候，我们可以采取简单方便的图形识别方式，例如：箱式图。 箱式图判断中，一般我们只需要锁定25%(Q1)分位点的用户特征值，75%(Q3)分位点的用户特征值，Q3与Q1之间的位差即为IQR，一般认定Q3+1.5个IQR外的点即为异常点，对应的用户即为异常用户。这种方法也叫做“盖帽法”，不必人为设定上限阀值，随着用户的数据变化而变化上界，避免了高频修改的问题，只是精度欠缺且绝大多数情况下识别出的异常用户较少。 方法比较简单，也不多加解释了。 统计方法检测方法也比较简单，上线开发简单。一直是分两步： 先假设全量数据服从一定的分布，比如常见的正太分布，泊松分布等 在计算每个点属于这个分布的概率，也就是大家常用的以平均值和方差定密度函数的问题 因为这边，我们前期无法知道数据服从什么样的分布，所以，我们这边可以用切比雪夫不等式来代替确定的分布形式。除此之外，也就是同时用了马氏距离来衡量了每个具体的点在整体数据集中的位置。 核心代码就是下面这个协方差矩阵及矩阵相乘：123456789101112#两个维度之间协方差矩阵S=np.cov(X)#协方差矩阵的逆矩阵SI = np.linalg.inv(S)#第一次计算全量用户的维度重心XTmean = XT.mean(axis=0)d1=[]n = XT.shape[0]for i in range(n): delta = XT[i] - XTmean d = np.sqrt(np.dot(np.dot(delta,SI),delta.T)) d1.append(d) 这个方法的最核心的优点就是对全量数据进行了分块，可以理解为将1拆分成了必定有问题的1/m用户，可能有问题的1/n用户，必定没问题的1/w用户（1/m+1/n+1/w=1），这也奠定了后续更好的方法的基础。但是问题也是很明显的，对于1/m，1/n的大小确定无法非常的精准，多了则影响正常用户，少了则无法准确拦截，还是一个划分的算法，并不能给出每个人的好坏程度。 距离位置检测距离探测的方法有一个非常强的假设，正常的用户都比较集中，有较多的邻居，而异常用户都特立独行。在常见的业务问题中都是满足的，比如对爬虫ip的识别，撞库的识别，这些一看那些高频访问的就不是正常用户，但是对于特别稀疏的业务场景，比如企业融资，高深度的敏感页面访问，均不是很适用，它们的频次较低无法构成一个邻居的概念。 这边非常常用的有2种，一个是连续特征间的欧式距离（标准化下的欧式距离（马氏距离）），另一个是名义变量下的余弦相似度。 这边只讨论第一种情况，连续特征下如何衡量数据是否为异常数据。前面我们也说到了，切比雪夫不等式的方法能够有效的划分出三个类别正常用户，异常用户，未知用户。所以，相应的，我们只需要在未知用户的集群里面去寻找与正常用户更不相似的，或者和异常用户更相似的用户就可以了。 对于单变量衡量： 对于多变量衡量： 核心计算相似度的方式就是以上两个公式，会有一些细节处理的问题及注意点，大家可自行研究。 密度位置检测这边先等下谈原理，较为冗长，先说结论，其实，在能够使用距离位置检测的情况下，优先使用距离位置检测的方法。密度方法的前提几乎与位置方法的前提一致，但是在计算量级上而言，存在较大的差异差别。 上述的图片是Fei Tony Liu, Kai Ming Ting, Zhi-Hua Zhou的一篇论文里面对比的常见的iForest,ORCA,LOF(也就是密度位置检测),RF方法的准确率和耗时情况，也清晰的可以看出，同为距离衡量的ORCA的耗时较大，但是LOF的耗时更高，甚至部分情况下都无法计算出结果。 下面让我们看下理论先，密度位置检测的方法之一，LOF：概念定义：1) d(p,o)：两点p和o之间的距离；2) k-distance：第k距离 对于点p的第k距离dk(p)定义如下： dk(p)=d(p,o)，并且满足： a) 在集合中至少有不包括p在内的k个点o,∈C{x≠p}， 满足d(p,o,)≤d(p,o) ； b) 在集合中最多有不包括p在内的k−1个点o,∈C{x≠p}，满足d(p,o,)&lt;d(p,o) ； 上面两个条件总结起来就是1.距离范围内至少满足一定数量的点数，2.最多允许有一个距离最大的非p点形象的看，距离就是p的第k距离，也就是距离p第k远的点的距离，不包括p，如下图箭头的路径长度。 3) k-distance neighborhood of p：第k距离邻域 点p的第k距离邻域Nk(p)，就是p的第k距离即以内的所有点，包括第k距离。 因此p的第k邻域点的个数记为 |Nk(p)|，且|Nk(p)|≥k 我们在定义一些衡量指标，那么LOF就算是完成了：1、可达距离（reach-distance）点o到点p的第k可达距离定义为：reach-distancek(p,o)=max{k−distance(o),d(p,o)} 2、局部可达密度（local reachablility density）点p处的局部可达密度为： 其中，|Nk(p)|为p的第k领域点的个数，∑o∈Nk(p)reach-distk(p,o)计算的是p的k领域内的点到p的可达距离，也就是1中涉及的计算方式。 3、局部离群因子（local outlier factor）点p的局部离群因子为：LOF（p） = （∑o∈Nk(p)lrdk(o)/lrdk(p)）/|Nk(p)|其中，lrdk(o)/lrdk(p)比值衡量了p点与附近的点之间的密切差异情况，LOF值=1时，代表p与p附近的点密度一致；LOF值1时，代表p点的密度小于p附近点的密度，也是非常符合我们的前提假设的，异常点总是比较稀疏，正常点总是比较稠密的。 到此位置LOF的数学理论就完成了，让我们回顾一下它的思想。它其实就是找数据集合中的每一个点及其邻居的点，计算它和它的邻居的密度，当它的密度大于等于它邻居的密度的时候，则认为它是稠密中心，是正常用户数据；否则异常。但是要计算每个点及对应的邻居的LOF值，计算成本也是非常的高的，最初我们也指出了这一点。 核心代码：12345678910111213141516171819def k_distance(k, instance, instances, distance_function=distance_euclidean): distances = &#123;&#125; for instance2 in instances: distance_value = distance_function(instance, instance2) if distance_value in distances: distances[distance_value].append(instance2) else: distances[distance_value] = [instance2] distances = sorted(distances.items()) neighbours = [] k_sero = 0 k_dist = None for dist in distances: k_sero += len(dist[1]) neighbours.extend(dist[1]) k_dist = dist[0] if k_sero &gt;= k: break return k_dist, neighbours 无监督模型识别其实这边说完全的无监督，我觉得不是很准确，我觉得叫“半监督”可能更好一些。这边方法很多，我只介绍两种：1.Iforest2.RNN 先让我们看下Iforest：算法的关键在于:对于一个有若干维的数据集合，对于其中的任一维度，如果该维度是连续属性的话，在若干次随机二分类后，边界稀疏点最容易优先达到子叶节点,如下图： 算法实现详细的过程为：假设数据集有N条数据，构建一颗iTree时，从N条数据中均匀抽样(一般是无放回抽样)出m(通常为256)个样本出来，作为这颗树的训练样本。在样本中，随机选一个特征，并在这个特征的所有值范围内(最小值与最大值之间)随机选一个值，对样本进行二叉划分，将样本中小于该值的划分到节点的左边，大于等于该值的划分到节点的右边,重复以上划分步骤，直到达到划分层数上限log(m)或者节点内只有一个样本，一棵树Itree的结果往往是不可信的，所以我们可以训练100-255棵树，最后整合所以树的结果取平均的深度作为输出深度，也叫做Isolation Forest。 有了算法逻辑，再看衡量指标： 其中，h(x)为x对应的节点深度，c(n)为样本可信度，s(x,n)~[0,1]，正常数据来讲s(x,n)小于0.8，s(x,n)越靠近1，数据异常的可能性越大。（这边需要注意，在sklearn中的Isolation是取得相反的逻辑，score越小数据异常的可能性越大。） 这边也贴上核心代码：12345678910111213141516171819202122232425262728def fit(self, X, y=None, sample_weight=None): X = check_array(X, accept_sparse=['csc'], ensure_2d=False) if issparse(X): # Pre-sort indices to avoid that each individual tree of the # ensemble sorts the indices. X.sort_indices() rnd = check_random_state(self.random_state) y = rnd.uniform(size=X.shape[0]) # ensure that max_sample is in [1, n_samples]: n_samples = X.shape[0] if not (self.max_samples &lt;= n_samples): warn("max_samples is larger than the total number of samples" " n_samples. Corrected as max_samples=n_samples") self.max_samples = n_samples if not (0 &lt; self.max_samples): raise ValueError("max_samples has to be positive") super(IsolationForest, self).fit(X, y, sample_weight=sample_weight) return self def _cost(self, n): if n &lt;= 1: return 1. else: harmonic_number = np.log(n) + 0.5772156649 return 2. * harmonic_number - 2. * (n - 1.) / n 2.RNN通常我们会以5层的卷积神经网络作为训练网络。我在这边处理之前将切比雪夫不等式划分出来的正常用户作为0-output，异常用户作为1-output，然后尽可能的降低损失函数的误差即可。 第一层是常规层，将不同的input做线性组合： 第二层、第四层是做数据非线性变化：这边选用的是tanh函数 第三层是做梯度分层下的非线性变化，抹平相似特征间的ouput：其中，k为3，N为想要分的梯度的个数，a3为一个阶梯跳跃到另一个阶梯的转换效率，形如： 第五层，也就是最后一层通过sigmoid进行0-1之间的压缩。 这边的损失函数用的是常见的mse： 当通过测试数据训练完成后，再将未知数据进行模型训练，观察得到结果的大小，越靠近1，越有可能为异常用户。 以上就是5种常见的只基于数据下的异常用户的识别，更偏方法技术一点，但是无论是算法实现还是业务应用中，同样需要注意输入特征的问题。由于大家运用方向不同，就不细节赘述。 详细实现demo可以私信我要，最后谢谢大家阅读了。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>风控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python开发：特征工程代码模版(一)]]></title>
    <url>%2F2017%2F12%2F01%2Fpython%E5%BC%80%E5%8F%91%EF%BC%9A%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[作为一个算法工程师，我们接的业务需求不会比数据分析挖掘工程师少，作为一个爱偷懒的人，总机械重复的完成一样的预处理工作，我是不能忍的，所以在最近几天，我正在完善一些常规的、通用的预处理的code，方便我们以后在每次分析之前直接import快速搞定，省的每次都要去做一样的事情。 如果大家有什么想实现但是懒得去弄的预处理的步骤也可以私信我，我相对而言闲暇还是有的（毕竟工资少工作也不多，摊手：《），我开发完成后直接贴出来，大家以后一起用就行了 我们需要预加载这些包，而且接下来所有的操作均在dataframe格式下完成，所以我们需要将数据先处理成dataframe格式123456789101112131415from __future__ import divisionimport numpy as npimport pandas as pdfrom sklearn import preprocessingfrom sklearn.cross_validation import train_test_splitfrom sklearn.neighbors import NearestNeighbors__author__ = 'slade_sal'__time__ = '20171128'def change_data_format(data): # 以下预处理都是基于dataframe格式进行的 data_new = pd.DataFrame(data) return data_new 空值处理接下来就开始我们的正题了，首先，我们需要判断哪些列是空值过多的，当一列数据的空值占列数的40%以上（经验值），这列能够带给我们的信息就不多了，所以我们需要把某个阀值（rate_base）以上的空值个数的列干掉，如下：123456789101112# 去除空值过多的featuredef nan_remove(data, rate_base=0.4): all_cnt = data.shape[0] avaiable_index = [] # 针对每一列feature统计nan的个数，个数大于全量样本的rate_base的认为是异常feature，进行剔除 for i in range(data.shape[1]): rate = np.isnan(np.array(data.iloc[:, i])).sum() / all_cnt if rate &lt;= rate_base: avaiable_index.append(i) data_available = data.iloc[:, avaiable_index] return data_available, avaiable_index 离群点处理把空值过多的列去完之后，我们需要考虑将一些特别离群的点去掉，这边需要注意两点： 异常值分析类的场景禁止使用这步，比如信用卡评分，爬虫识别等，你如果采取了这步，还怎么去分离出这些异常啊 容忍度高的算法不建议使用这步，比如svm里面已经有了支持向量机这个东西，你如果采取了这步的离群识别的操作会改变原分布而且svm里面决定超平面的核心与离群点无关，后接函数会引发意想不到的彩蛋～ 这边采取盖帽法与额定的分位点方法，建议组合使用，用changed_feature_box定义需要采用盖帽法的列的index_num，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940# 离群点盖帽def outlier_remove(data, limit_value=10, method='box', percentile_limit_set=90, changed_feature_box=[]): # limit_value是最小处理样本个数set，当独立样本大于limit_value我们认为非可onehot字段 feature_cnt = data.shape[1] feature_change = [] if method == 'box': for i in range(feature_cnt): if len(pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &gt;= limit_value: q1 = np.percentile(np.array(data.iloc[:, i]), 25) q3 = np.percentile(np.array(data.iloc[:, i]), 75) # q3+3/2*qi为上截距点，详细百度分箱图 top = q3 + 1.5 * (q3 - q1) data.iloc[:, i][data.iloc[:, i] &gt; top] = top feature_change.append(i) return data, feature_change if method == 'self_def': # 快速截断 if len(changed_feature_box) == 0: # 当方法选择为自定义，且没有定义changed_feature_box则全量数据全部按照percentile_limit_set的分位点大小进行截断 for i in range(feature_cnt): if len(pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &gt;= limit_value: q_limit = np.percentile(np.array(data.iloc[:, i]), percentile_limit_set) data.iloc[:, i][data.iloc[:, i] &gt; q_limit] = q_limit feature_change.append(i) else: # 如果定义了changed_feature_box，则将changed_feature_box里面的按照box方法，changed_feature_box的feature index按照percentile_limit_set的分位点大小进行截断 for i in range(feature_cnt): if len(pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &gt;= limit_value: if i in changed_feature_box: q1 = np.percentile(np.array(data.iloc[:, i]), 25) q3 = np.percentile(np.array(data.iloc[:, i]), 75) # q3+3/2*qi为上截距点，详细百度分箱图 top = q3 + 1.5 * (q3 - q1) data.iloc[:, i][data.iloc[:, i] &gt; top] = top feature_change.append(i) else: q_limit = np.percentile(np.array(data.iloc[:, i]), percentile_limit_set) data.iloc[:, i][data.iloc[:, i] &gt; q_limit] = q_limit feature_change.append(i) return data, feature_change 空值填充在此之后，我们需要对空值进行填充，这边方法就很多很多了，我这边实现的是基本的，分了连续feature和分类feature，分别针对continuous feature采取mean,min,max方式，class feature采取one_hot_encoding的方式；除此之外还可以做分层填充，差分填充等等，那个比较定制化，如果有需要，我也可以搞一套，但是个人觉得意义不大。12345678910111213141516171819202122232425262728293031323334# 空feature填充def nan_fill(data, limit_value=10, countinuous_dealed_method='mean'): feature_cnt = data.shape[1] normal_index = [] continuous_feature_index = [] class_feature_index = [] continuous_feature_df = pd.DataFrame() class_feature_df = pd.DataFrame() # 当存在空值且每个feature下独立的样本数小于limit_value，我们认为是class feature采取one_hot_encoding； # 当存在空值且每个feature下独立的样本数大于limit_value，我们认为是continuous feature采取mean,min,max方式 for i in range(feature_cnt): if np.isnan(np.array(data.iloc[:, i])).sum() &gt; 0: if len(pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &gt;= limit_value: if countinuous_dealed_method == 'mean': continuous_feature_df = pd.concat( [continuous_feature_df, data.iloc[:, i].fillna(data.iloc[:, i].mean())], axis=1) continuous_feature_index.append(i) elif countinuous_dealed_method == 'max': continuous_feature_df = pd.concat( [continuous_feature_df, data.iloc[:, i].fillna(data.iloc[:, i].max())], axis=1) continuous_feature_index.append(i) elif countinuous_dealed_method == 'min': continuous_feature_df = pd.concat( [continuous_feature_df, data.iloc[:, i].fillna(data.iloc[:, i].min())], axis=1) continuous_feature_index.append(i) elif len(pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &gt; 0 and len( pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &lt; limit_value: class_feature_df = pd.concat( [class_feature_df, pd.get_dummies(data.iloc[:, i], prefix=data.columns[i])], axis=1) class_feature_index.append(i) else: normal_index.append(i) data_update = pd.concat([data.iloc[:, normal_index], continuous_feature_df, class_feature_df], axis=1) return data_update one hot encoding过程分类feature的one hot encoding过程，常见操作，不多说123456789101112131415# onehotencodingdef ohe(data, limit_value=10): feature_cnt = data.shape[1] class_index = [] class_df = pd.DataFrame() normal_index = [] # limit_value以下的均认为是class feature，进行ohe过程 for i in range(feature_cnt): if len(pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &lt; limit_value: class_index.append(i) class_df = pd.concat([class_df, pd.get_dummies(data.iloc[:, i], prefix=data.columns[i])], axis=1) else: normal_index.append(i) data_update = pd.concat([data.iloc[:, normal_index], class_df], axis=1) return data_update Smote过程正负样本不平衡的解决，这边我写的是smote，理论部分建议参考：Python：SMOTE算法,其实简单的欠抽样和过抽样就可以解决，建议参考这边文章：Python:数据抽样平衡方法重写。都是一些老生常谈的问题了，不多说了，上代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# smote unbalance datasetdef smote(data, tag_label='tag_1', amount_personal=0, std_rate=5, k=5,method = 'mean'): cnt = data[tag_label].groupby(data[tag_label]).count() rate = max(cnt) / min(cnt) location = [] if rate &lt; 5: print('不需要smote过程') return data else: # 拆分不同大小的数据集合 less_data = np.array(data[data[tag_label] == np.array(cnt[cnt == min(cnt)].index)[0]]) more_data = np.array(data[data[tag_label] == np.array(cnt[cnt == max(cnt)].index)[0]]) # 找出每个少量数据中每条数据k个邻居 neighbors = NearestNeighbors(n_neighbors=k).fit(less_data) for i in range(len(less_data)): point = less_data[i, :] location_set = neighbors.kneighbors([less_data[i]], return_distance=False)[0] location.append(location_set) # 确定需要将少量数据补充到上限额度 # 判断有没有设定生成数据个数，如果没有按照std_rate(预期正负样本比)比例生成 if amount_personal &gt; 0: amount = amount_personal else: amount = int(max(cnt) / std_rate) # 初始化，判断连续还是分类变量采取不同的生成逻辑 times = 0 continue_index = [] # 连续变量 class_index = [] # 分类变量 for i in range(less_data.shape[1]): if len(pd.DataFrame(less_data[:, i]).drop_duplicates()) &gt; 10: continue_index.append(i) else: class_index.append(i) case_update = pd.DataFrame() while times &lt; amount: # 连续变量取附近k个点的重心，认为少数样本的附近也是少数样本 new_case = [] pool = np.random.permutation(len(location))[0] neighbor_group = less_data[location[pool], :] if method == 'mean': new_case1 = neighbor_group[:, continue_index].mean(axis=0) # 连续样本的附近点向量上的点也是异常点 if method =='random': new_case1 =less_data[pool][continue_index] + np.random.rand()*(less_data[pool][continue_index]-neighbor_group[0][continue_index]) # 分类变量取mode new_case2 = [] for i in class_index: L = pd.DataFrame(neighbor_group[:, i]) new_case2.append(np.array(L.mode()[0])[0]) new_case.extend(new_case1) new_case.extend(new_case2) case_update = pd.concat([case_update, pd.DataFrame(new_case)], axis=1) print('已经生成了%s条新数据，完成百分之%.2f' % (times, times * 100 / amount)) times = times + 1 data_res = np.vstack((more_data, np.array(case_update.T))) data_res = pd.DataFrame(data_res) data_res.columns = data.columns return data_res 总体整合一期的内容就这样吧，我感觉也没有啥好说的，都是数据分析挖掘的一些基本操作，我只是为了以后能够复用模版化了，下面贴一个全量我做预处理的过程，没啥差异，整合了一下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220from __future__ import divisionimport numpy as npimport pandas as pdfrom sklearn import preprocessingfrom sklearn.cross_validation import train_test_splitfrom sklearn.neighbors import NearestNeighborsimport sys__author__ = 'slade_sal'__time__ = '20171128'def change_data_format(data): # 以下预处理都是基于dataframe格式进行的 data_new = pd.DataFrame(data) return data_new# 去除空值过多的featuredef nan_remove(data, rate_base=0.4): all_cnt = data.shape[0] avaiable_index = [] # 针对每一列feature统计nan的个数，个数大于全量样本的rate_base的认为是异常feature，进行剔除 for i in range(data.shape[1]): rate = np.isnan(np.array(data.iloc[:, i])).sum() / all_cnt if rate &lt;= rate_base: avaiable_index.append(i) data_available = data.iloc[:, avaiable_index] return data_available, avaiable_index# 离群点盖帽def outlier_remove(data, limit_value=10, method='box', percentile_limit_set=90, changed_feature_box=[]): # limit_value是最小处理样本个数set，当独立样本大于limit_value我们认为非可onehot字段 feature_cnt = data.shape[1] feature_change = [] if method == 'box': for i in range(feature_cnt): if len(pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &gt;= limit_value: q1 = np.percentile(np.array(data.iloc[:, i]), 25) q3 = np.percentile(np.array(data.iloc[:, i]), 75) # q3+3/2*qi为上截距点，详细百度分箱图 top = q3 + 1.5 * (q3 - q1) data.iloc[:, i][data.iloc[:, i] &gt; top] = top feature_change.append(i) return data, feature_change if method == 'self_def': # 快速截断 if len(changed_feature_box) == 0: # 当方法选择为自定义，且没有定义changed_feature_box则全量数据全部按照percentile_limit_set的分位点大小进行截断 for i in range(feature_cnt): if len(pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &gt;= limit_value: q_limit = np.percentile(np.array(data.iloc[:, i]), percentile_limit_set) data.iloc[:, i][data.iloc[:, i] &gt; q_limit] = q_limit feature_change.append(i) else: # 如果定义了changed_feature_box，则将changed_feature_box里面的按照box方法，changed_feature_box的feature index按照percentile_limit_set的分位点大小进行截断 for i in range(feature_cnt): if len(pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &gt;= limit_value: if i in changed_feature_box: q1 = np.percentile(np.array(data.iloc[:, i]), 25) q3 = np.percentile(np.array(data.iloc[:, i]), 75) # q3+3/2*qi为上截距点，详细百度分箱图 top = q3 + 1.5 * (q3 - q1) data.iloc[:, i][data.iloc[:, i] &gt; top] = top feature_change.append(i) else: q_limit = np.percentile(np.array(data.iloc[:, i]), percentile_limit_set) data.iloc[:, i][data.iloc[:, i] &gt; q_limit] = q_limit feature_change.append(i) return data, feature_change# 空feature填充def nan_fill(data, limit_value=10, countinuous_dealed_method='mean'): feature_cnt = data.shape[1] normal_index = [] continuous_feature_index = [] class_feature_index = [] continuous_feature_df = pd.DataFrame() class_feature_df = pd.DataFrame() # 当存在空值且每个feature下独立的样本数小于limit_value，我们认为是class feature采取one_hot_encoding； # 当存在空值且每个feature下独立的样本数大于limit_value，我们认为是continuous feature采取mean,min,max方式 for i in range(feature_cnt): if np.isnan(np.array(data.iloc[:, i])).sum() &gt; 0: if len(pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &gt;= limit_value: if countinuous_dealed_method == 'mean': continuous_feature_df = pd.concat( [continuous_feature_df, data.iloc[:, i].fillna(data.iloc[:, i].mean())], axis=1) continuous_feature_index.append(i) elif countinuous_dealed_method == 'max': continuous_feature_df = pd.concat( [continuous_feature_df, data.iloc[:, i].fillna(data.iloc[:, i].max())], axis=1) continuous_feature_index.append(i) elif countinuous_dealed_method == 'min': continuous_feature_df = pd.concat( [continuous_feature_df, data.iloc[:, i].fillna(data.iloc[:, i].min())], axis=1) continuous_feature_index.append(i) elif len(pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &gt; 0 and len( pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &lt; limit_value: class_feature_df = pd.concat( [class_feature_df, pd.get_dummies(data.iloc[:, i], prefix=data.columns[i])], axis=1) class_feature_index.append(i) else: normal_index.append(i) data_update = pd.concat([data.iloc[:, normal_index], continuous_feature_df, class_feature_df], axis=1) return data_update# onehotencodingdef ohe(data, limit_value=10): feature_cnt = data.shape[1] class_index = [] class_df = pd.DataFrame() normal_index = [] # limit_value以下的均认为是class feature，进行ohe过程 for i in range(feature_cnt): if len(pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &lt; limit_value: class_index.append(i) class_df = pd.concat([class_df, pd.get_dummies(data.iloc[:, i], prefix=data.columns[i])], axis=1) else: normal_index.append(i) data_update = pd.concat([data.iloc[:, normal_index], class_df], axis=1) return data_update# smote unbalance datasetdef smote(data, tag_label='tag_1', amount_personal=0, std_rate=5, k=5,method = 'mean'): cnt = data[tag_label].groupby(data[tag_label]).count() rate = max(cnt) / min(cnt) location = [] if rate &lt; 5: print('不需要smote过程') return data else: # 拆分不同大小的数据集合 less_data = np.array(data[data[tag_label] == np.array(cnt[cnt == min(cnt)].index)[0]]) more_data = np.array(data[data[tag_label] == np.array(cnt[cnt == max(cnt)].index)[0]]) # 找出每个少量数据中每条数据k个邻居 neighbors = NearestNeighbors(n_neighbors=k).fit(less_data) for i in range(len(less_data)): point = less_data[i, :] location_set = neighbors.kneighbors([less_data[i]], return_distance=False)[0] location.append(location_set) # 确定需要将少量数据补充到上限额度 # 判断有没有设定生成数据个数，如果没有按照std_rate(预期正负样本比)比例生成 if amount_personal &gt; 0: amount = amount_personal else: amount = int(max(cnt) / std_rate) # 初始化，判断连续还是分类变量采取不同的生成逻辑 times = 0 continue_index = [] # 连续变量 class_index = [] # 分类变量 for i in range(less_data.shape[1]): if len(pd.DataFrame(less_data[:, i]).drop_duplicates()) &gt; 10: continue_index.append(i) else: class_index.append(i) case_update = pd.DataFrame() while times &lt; amount: # 连续变量取附近k个点的重心，认为少数样本的附近也是少数样本 new_case = [] pool = np.random.permutation(len(location))[0] neighbor_group = less_data[location[pool], :] if method == 'mean': new_case1 = neighbor_group[:, continue_index].mean(axis=0) # 连续样本的附近点向量上的点也是异常点 if method =='random': new_case1 =less_data[pool][continue_index] + np.random.rand()*(less_data[pool][continue_index]-neighbor_group[0][continue_index]) # 分类变量取mode new_case2 = [] for i in class_index: L = pd.DataFrame(neighbor_group[:, i]) new_case2.append(np.array(L.mode()[0])[0]) new_case.extend(new_case1) new_case.extend(new_case2) case_update = pd.concat([case_update, pd.DataFrame(new_case)], axis=1) print('已经生成了%s条新数据，完成百分之%.2f' % (times, times * 100 / amount)) times = times + 1 data_res = np.vstack((more_data, np.array(case_update.T))) data_res = pd.DataFrame(data_res) data_res.columns = data.columns return data_res# 数据分列def reload(data): feature = pd.concat([data.iloc[:, :2], data.iloc[:, 4:]], axis=1) tag = data.iloc[:, 3] return feature, tag# 数据切割def split_data(feature, tag): X_train, X_test, y_train, y_test = train_test_split(feature, tag, test_size=0.33, random_state=42) return X_train, X_test, y_train, y_testif __name__ == '__main__': path = sys.argv[0] data_all = pd.read_table(str(path)) print('数据读取完成！') # 更改数据格式 data_all = change_data_format(data_all) # 删除电话号码列 data_all = data_all.iloc[:, 1:] data_all, data_avaiable_index = nan_remove(data_all) print('空值列处理完毕！') data_all, _ = outlier_remove(data_all) print('异常点处理完成！') data_all = nan_fill(data_all) print('空值填充完成！') data_all = ohe(data_all) print('onehotencoding 完成！') data_all = smote(data_all) print('smote过程完成！') feature, tag = reload(data_all) X_train, X_test, y_train, y_test = split_data(feature, tag) print('数据预处理完成！') 大家自取自用，这个也没啥好转载的，没啥干货，只是方便大家日常工作，就别转了，谢谢各位编辑大哥了。 最后，感谢大家阅读，谢谢。]]></content>
      <categories>
        <category>代码集合</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见算法工程师面试题目整理(二)]]></title>
    <url>%2F2017%2F12%2F01%2F%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[接着上回写的《总结：常见算法工程师面试题目整理(1)》,继续填接下来的坑。 boost算法的思路是什么样的？讲一下你对adaboost 和 gbdt的了解？答：boost的核心思想不同于bagging，它在基于样本预测结果对照与真实值得差距，进行修正，再预测再修正，逐步靠近正确值。 我对adaboost和gbdt了解的也不算很全面：大概的梳理如下：不足：1.adaboost存在异常点敏感的问题2.gbdt一定程度上优化了adaboost异常点敏感的问题，但是存在难以并行的缺点3.两者的目标都是优化bias，必然导致训练出来的数据var的不稳定 亮点：1.发现非线性的特征关系，网格化的切分feature2.拟合的效果相较于其他分类器更加精准，且训练参数较少 Adaboost:adaboost初始数据权重都是1/M，然后通过训练每一个弱分类器Classifier使得在每一次y_pred误差最小，得到每一个弱Classifier的权重方法对：（αi，yi）然后提高错分了的数据的权重，降低正确分类的数据权重，循环训练，最后组合最后若干次的训练弱Classifier对，得到强分类器。其中，αi由误差决定：该弱分类器分类错误率em越大，则该若分类器作用越小。1.剖析了原理之后，我们发现，这样做对异常点非常敏感，异常点非常容易错分，会影响后续若干个弱分类器 gbdt:gbdt的核心在于下面这个公式：L（y，y_pred）：预测值与实际值间的误差F(x):前若干个弱分类器的组合关键的在于当前预测结果=对前若干个弱分类器+当前弱分类器修正，所以对前若干个分类器组合求偏导的方向进行梯度处理，保证L（x）出来的值最小。这边结果在于你选取什么样的误差函数： Loss即为损失函数，Derivative即为导数除此之外，在每一步弱分类器构建的同时，它还考虑了正则化：Ω=入T+μ*linalg.norm(f(xi))T为子叶节点数目，同时也对预测结果得分的值进行了l1或者l2压缩，避免过拟合。 我个人更喜欢用xgboost，在求解速度上，对异常值处理上面都要比gbdt要快，而且基于R、python版本都有package。 听说你做过用户关系，你用的什么方法？社群算法有了解，讲讲什么叫做Modularity Q？1.我用的是Jaccard相关。比如，用户1一共收过150个红包，发了100个红包，其中20个被用户2抢过用户2一共收过100个红包，发了50个红包，其中30个被用户1抢过similarity(user1=&gt;user2)=(30+20)/(150+100)similarity(user2=&gt;user1)=(30+20)/(50+100)similarity(user2=&gt;user1)=(30+20+30+20)/(150+100+50+100) 2.社区算法主要是用来衡量用户关系网中，不同用户、链接、信息之间的相似程度。本来这边我准备讲pagerank的，结果被打断了，说需要讲内部结构相关的，其实我觉得PageRank这边来描述更加合适。不过，无所谓，我这边谈的是一个很基本的叫做：Kernighan-Lin算法（后面简称了KL算法）KL算法中，先随机切分原数据集群，得到不同社区集，随机交换不同社区集内的不同点，观察优化值得变化程度是否为正向，循环即可。 共需执行次数：循环次数x集群A内点的个数x集群B内点的个数 感觉这边答的不行，被嫌弃了，有知道的大神可以自行去研究一下相关的社区算法，我这边只了解PageRank和LK。 3.Q-modularity： 这个简单，E：关系点连接线之间的个数，I：关系点连接线两端都在社群内的数量，O：关系点连接线有至少一端在社群外的连接线的数量 这个指标是用来衡量社群划分的稳定性的，讲真我也没用过，只是在周志华的算法的书上看过。 如果让你设计一套推荐算法，请说出你的思路？讲真，这个点，我起码说了有25分种，对面的面试管也很耐心的听完了，并且还给予了很多点的反馈，个人觉得非常受到尊重，我下面细节梳理一下。首先，我个人非常赞同阿里现在的推荐算法这边的设计思路：推荐＝人＋场景＋物其中，人＝新用户＋老用户＋综合特征＋…场景＝属性偏好＋周期属性＋黏度偏好＋…物＝相关性＋物品价值＋特殊属性＋…接下来，我简单的剖析三个最常见也最重要的问题： 冷启动很多人有一种错觉，只要业务上线时间长了就不存在所谓的冷启动问题，实则不是，新用户是持续进入的、流失用户也是在增长的、很多盲目用户（没有有价值行为）等等都可以归纳为冷启动问题，这类问题的核心在于你可用的数据很少，甚至没有，我这边采取的是热门推荐的方法。然而在热门推荐的算法中，我这边推荐一些方法：威尔逊区间法：综合考虑总的行为用户中，支持率与支持总数的平衡hacker new排序：综合考虑时间对支持率的影响pagerank排序：考虑用户流向下的页面权重排序梯度效率排序：考虑商品增速下的支持率的影响…方法很多，但是核心的一点是热门推荐是冷启动及实时推荐必不可少的一环，优化好实时推荐的算法是占到一个好的推荐算法的30%以上的权重的，切忌0推荐。 不同种算法产生的推荐内容互不冲突这个是苏宁易购的首页推荐位，1、2、3分别是三个推荐位，我们在做算法的时候常常会特别注意，不能用太多相关性比较高的变量，会产生共线性，但在推荐内容上，“58同城”的算法推荐团队之前有一份研究证明，同一个页面上由不同算法产出的推荐结果不存在相互影响。所以，我非常赞同不同的算法产出不同的结果同时展示，因为我们不知道对目标用户是概率模型、距离模型、线性模型等不同模型中哪个产出的结果更加合适。关于常用的推荐算法，我之前梳理过，这边也不再多加重复，需要仔细研究的可看我上面的图，或者看我之前的文章：《深度学习下的电商商品推荐》、《偏RSVD及扩展的矩阵分解方法》等等 你的对象是用户，不是冰冷的数字我在苏宁呆的时间不长，但是我有个感觉，身边算法工程师很容易把自己陷入数字陷阱，近乎疯狂去用各种算法去拟合当前的用户数据，以求得得到高的ctr或者转化率。不同的推荐场景需要使用不同的用户行为。举例假设存在经典的关系：买了炸鸡和番茄酱的用户，接下来的一周有35%的用户会来买汽水。所以，很多工程师会选择只要买了炸鸡和番茄酱的用户，就弹窗汽水，因为就35%的百分比而言，是非常高的支持度了。其实只要有用户画像的支持就会发现，这35%的用户中，80%的都是年龄在青少年，如果在推送之前做一个简单的逻辑判断只针对所有青少年进行推送汽水的话，35%轻而易举的上升到了70%，这是任何算都无法比拟的。 最上方的橙黄色的横条中，橙色代表原始的目标用户，黄色代表非目标用户，假设我们知道黑色方框所框选的用户的转化率达到最小置信度的时候，我们可以通过特征映射、非线性分解、用户画像刻画等不同方法得到左右完全不同的新的用户分布，在同样的用户框选占比下，效果也是完全不同的。真实推荐中，比如针对用户冬装推荐，我不仅仅以用户近期的搜索、浏览、购买商品等行为判断用户的偏好，我也根据他夏天的购买风格款式、他的年龄、生理性别、浏览性别等综合判断他可能会买什么。推荐算法才不会是冷漠的。 至于想要了解具体实现算法及创新的一些想法可以看上方的脑图，但是我觉得那并不是最重要。 什么是P、NP、NP-Hard、NP-Complete问题？P：很快可以得出解的问题NP：一定有解，但可很快速验证答案的问题 后面两个我没答出来，网上搜了下，分享下：NP-Hard：比所有的NP问题都难的问题NP-Complete：满足两点： 是NP-Hard的问题 是NP问题 个人不喜欢这种问题。 常见的防止过拟合的方法是什么？为什么l1、l2正则会防止过拟合？当被问了第一个问题的时候，我愣了下，因为我觉得挺简单的，为什么要问这个，我感觉接下来有坑。我回答的是：先甩出了下面的图解释了一波欠拟合、正常、过拟合：然后举了几个例子： 针对error递归的问题，l1，l2正则化 扩充数据量，使得数据更加符合真实分布 bagging等算法技巧 当问到为什么的时候，我觉得自己回答的不好，有点蛋疼：我说的是，l1以：l2以：l1中函数与约束点偏向相切于四个端点，端点处压缩了某个特征＝0；l2中函数与约束点偏向相切于圆，会造成某些特征值压缩的接近于0；根据奥卡姆剃刀原理，当两个假说具有完全相同的解释力和预测力时，我们以那个较为简单的假说作为讨论依据，而通常过拟合的模型的特征维度过高过多，所以一定程度可以缓解过拟合。 面试管以一种奇怪的眼神看着我，然后表示他其实想让我通过先验概率解释，不过我这样说仿佛也有道理。我回来之后就研究了一下，比如l2，大致如下：首先，我们确定两点：l2，其实就给了系数w一个期望是0，协方差矩阵是 1/alpha的先验分布。l1对应的是Laplace先验。 我们相当于是给模型参数w设置一个协方差为1/alpha 的零均值高斯分布先验。根据贝叶斯定律： 这一步我没看懂，我计算了半天也没由最大似然估计算出下面这个式子，有会的朋友可以私信我一下。 有了上面的式子就很简单了，alpha在0-正无穷之间，如果a接近0的话，左侧及为正常的MSE也就是没有做任何的惩罚。如果alpha越大的话，说明预测值越接近真实值的同时，协方差也控制的很小，模型越平稳，Var也越小，所以整体的模型更加有效，避免了过拟合导致训练数据拟合效果很差的问题。 到这里，我觉得常见的算法题目都讲完了，很多简单的知识点我没有提，上面这些算是比较经典的，我没答出来的，希望对大家有所帮助，最后谢谢大家的阅读。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见算法工程师面试题目整理(一)]]></title>
    <url>%2F2017%2F12%2F01%2F%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[最近抽风，出去面试了不少公司，和不少算法工程师招聘的朋友有所交流，整理了相关比较有意思的题目，供大家参考： 附：每题视情况给出答案或答案简介，如有疑问，欢迎私信 基于每日用户搜索内容，假设只有少量已知商品的情况下，如何根据用户搜索内容获取平台内没有的新商品？ 答案：这是一条类似于分词“新词获取问题”，答案是基于信息熵＋聚合度。 这边需要考虑排除，首先做stop词库，先去除形容词等。信息熵：比如用户搜索“曲面显示屏 白色”，假设现在我们的商品库中没有显示屏这个商品，我们需要判断“显示屏”是否是潜在的商品，我们需要考虑“显示屏”左词、右词出现的可能。换句话说，如果大家都在搜索“显示屏”商品的话，会出现大量的“便宜显示屏”、“可旋转显示屏”、“显示屏 黑色”等搜索短语，根据信息熵计算公式-p∑logp，“显示屏”前后出现的词语类别越多，信息熵越大，代表用户搜索的需求越旺盛，“显示屏”越有可能是没有的商品。 聚合度：根据信息熵的理论也会出现“显示”等高频出现的干扰词，再用聚合度，比如先计算出p(“显示”)、p(“屏”)、或p(“显”)、p(“示屏”)的概率，如果“显示”是一个高频合理的搜索词的话，p(“显示”)*p(“屏”)应该远远大于p(“显示屏”)，p(“显”)＊p(“示屏”)应该远远大于p(“显示屏”)的概率，而实际电商搜索中，用户连贯搜索“显示屏”的概率才是远超其它。 为什么logistic回归的要用sigmoid函数？优缺点？答案：优点：1.数据压缩能力，将数据规约在［0，1］之间2.导数形式优秀，方便计算缺点：1.容易梯度消失，x稍大的情况下就趋近一条水平线2.非0中心化，在神经网络算法等情况下，造成反向传播时权重的全正全负的情况。 为什么要用？答案1:logistic是基于Bernoulli分布的假设，也就是y|X~Bernoulli分布，而Bernoulli分布的指数族的形式就是1/(1+exp(-z))其实还有一个答案二，我当时没想起来，如就是：对于logistic多分类而言，x1、x2、…、xn，属于k类的概率正比于： 我们回到2类：x1、x2、…xn属于1的概率是： 分子分母同除以分子极为1/(1+exp(-z))，z＝w11-w01，个人觉得这样的证明才有说服力 对比牛顿法、梯度下降法的关系讲真，大学学完牛顿法就丢了，一时没回答出来，回来整理如下：答案：牛顿法快于梯度下降法，且是梯度下降法的极限。 首先，我们有展开式：f′(x+Δx)=f′(x)+f″(x)∗ΔxΔx=−μ∗f′(x)合并两个式子，有：f′(x+Δx)=f′(x)+f″(x)∗(−μ∗f′(x))令f′(x+Δx)＝0，μ＝1/f″(x)，极为牛顿法在随机梯度下降中的μ 两个盒子，50个红球，50个白球，问如何放球，抽到红球的概率最高？（每个盒子必须有球）答案：一个盒子1个红球，另外一个盒子剩余的99个球 先假设第一个盒子放x个红球，y个白球，另外的一个盒子里面就有50-x红球，50-y个白球.求的目标函数：p＝1/2(x/(x+y))+1/2((50-x)/(100-x-y))subject to. x+y&gt;0 &amp; 100-x-y&gt;0 常规解法如上，被坑了一手的是，面试的说没有常规解，我回来思考了半天，可能是盒子里面的排练顺序有差异，上层的抽取概率&gt;下层的抽取概率，所以需要通过EM算法，先得到若干次抽取的结果下，每层的最大概率密度函数，再结合上述的结果去回答。 常见的正则化有是么，有什么作用，为什么l1是会把feature压缩到0而l2做不到？答案：(1)l1,l2正则化l1对应python里面numpy.linalg.norm(ord=1)形如|w1|+|w2|+|w3|+…l2对应python里面numpy.linalg.norm(ord=2)形如w1^2+w2^2+w3^2+… (2)防止过拟合其它防止过拟合的方法还有：1.增加数据量2.采取bagging算法，抽样训练数据 (3)画图解决** 左边的l1，右边的l2，l1在作图只要不是特殊情况下与正方形的边相切，一定是与某个顶点优先相交，那必然存在横纵坐标轴中的一个系数为0，起到对变量的筛选的作用。l2的时候，其实就可以看作是上面这个蓝色的圆，在这个圆的限制下，点可以是圆上的任意一点，所以q＝2的时候也叫做岭回归，岭回归是起不到压缩变量的作用的，在这个图里也是可以看出来的。 分类模型如何选择？如何判断效果？如何计算AUC？你最熟悉的ensemble Classification model是什么？我这边参考了《Do we Need Hundreds of Classifiers to Solve Real World Classification Problems》里面的结论，有兴趣的自行去搜答案：整体上讲：数据量越大，神经网络越好；维度越多，bagging算法越优秀；数据量上不多不少的情况下，SVM效果最好；常用判断：roc、auc、ks、f1值、recall等；AUC计算方法：roc曲线下方的面积积分即可，或者大数定律的投点实验 最熟悉的集成分类模型，我说的是randomforest，详述了原理及实际应用的注意点，后来我问了面试管，主要在这块想了解的是实际解决的相关项目的真实性：1.randomforest是由若干颗cart树构成的，每棵树尽情生长不枝剪，最后采取加权投票或者均值的方式确定输出值2.每棵树的数据是采取bagging式的随机抽取特征及数据样本，两颗树之间的数据有可能会重复3.一般流程会先以sqrt(feature_number)作为每次输入的特征数，采取gridsearch的方法观察tree的数量由0-500，oob的变化这边被打断了，解释什么叫做oob，也就是out of bag，每次抽取的数据样本进行训练，没有被抽取到的数据作为检验样本，检验样本上的误差就叫做oob4.根据实际要求的精度上后期可以跟进调整：每次输入的特征个数、每棵树的最大深度、每个节点的分支方式（GINI还是信息增益率）、子节点最少数据量、父节点最少数据量等等这边又被打断了，问，什么叫做信息增益率？首先熵的计算如下：![](https://www.zhihu.com/equation?tex=E%28X%29%3D-%5Csum%7Bi%3D1%7D%5E%7Bn%7D%7Bp%7Bi%7Dlog%7B2%7D%28p%7Bi%7D+%29++%7D+)信息增益如下：![](https://www.zhihu.com/equation?tex=E%28A%29%3D%5Csum%7Bv%5Cin+value%28A%29%7D%7B%5Cfrac%7Bnum%28S%7Bv%7D%29+%7D%7Bnum%28S%29%7DE%28S%7Bv%7D+%29+%7D+)比如14个人，好人5个坏人9个。这14个人被通过性别划分开，10个男性中3个坏人，7个好人；4个女性中2个坏人，2个好人。 信息增益就是:IGain＝(-5/14)log(5/14)+(-9/14)log(9/14)-(10/14(-3/10log(3/10)-7/10log(7/10))+4/14(-1/2log(1/2)-1/2log(1/2)))看到这样的计算方式，必然会存在问题，假设我们身份证为区分类别的化，每个身份证号码都是独一无二的，势必存在存在1/n*log(1)=0这样的最佳划分，但是这样的结果就是将所有的情况分别作为子节点，很明显没有意义，所以引出下面的信息增益率。 信息增益率就是:比如上面分人的例子，Info＝-10/14log(10/14)-4/14log(4/14)很明显也可以看出，当你划分的子类别越多，你的info会越大，Gain_ratio就越小，信息增益率就越低，惩罚了刚才身份证分类这种行为。 这也是id3和c4.5之间最大的差异，c4.5以信息增益率代替率id3里面的信息增益，除此之外，id3只能对分类变量处理而c4.5既可以分类变量也可以连续变量，还是很强的，同时他们都可以做多分类，而后续的cart等做多分类的成本会增加（叠加的方式） 其实，这些都很基础但是时间长了，真的很绕人，我也是先自己默默的在纸上画了挺久才和面试管聊，有点出乎我的意料。 循环神经网络中介绍一个你熟悉的？我说的是LSTM。首先，先跑出了循环的机制，同时点明了RNN潜在隐藏节点对output的影响，做了下图： 及当前的预测结果，与input及上次的layer1节点下的结果相关。 正向循环：节点1的值 = sigmoid(np.dot(输入参数,神经元1) + np.dot(上次节点1的值,潜在神经元))输出值＝sigmoid(np.dot(节点1的值,神经元2)) 误差计算：真实y－输出值 delta：节点2处的deltas=误差计算*sigmoid(np.dot(节点1的值,神经元2))／(1-sigmoid(np.dot(节点1的值,神经元2))) 反向修正神经元：神经元2 += (节点1的值).T.dot(节点2处的delta)潜藏神经元 += (上次的节点1的值).T.dot(节点1处的delta)神经元1 += 输入值.T.dot(节点1处的delta) 核心强调了：sigmoid(np.dot(输入参数,神经元1) + np.dot(上次节点1的值,潜在神经元))，输出值与输出值及上次节点1处的输入值有关。然后讲了简单的在语义识别的实际作用。 kmeans的原理及如何选择k？如何选择初始点？原理是送分题，原理：在给定K值和K个初始类簇中心点的情况下,把每个点(亦即数据记录)分到离其最近的类簇中心点所代表的类簇中，优点在于易于理解和计算，缺点也是很明显，数据一多的情况计算量极大，且标签feature定义距离的难度大。 K的选择，我答的一般，欢迎大家补充，1.根据具体的业务需求，实际需求确定最后聚成的类的个数2.grid_search去试，看那种距离下，损失函数最小（其实这样回答不好，数据量大的情况下，机会不可能）这边的损失函数类别较多，可能包括组内间距和／组外间距和等3.随机抽样下的层次聚类作为预参考理论上，随机采样的数据分布满足原来的数据集的分布，尤其是大量采样次数下的情况，针对每一个较小的数据集合采取层次聚类确定最后的聚类个数，再针对原始的数据集合进行kmeans聚类 如何选取初始点？这个问题我被问过好多次，其实，不管是r或者python里面，或者大家日常使用中都是默认的随机选取，然后通过多次k-折等方法不断的去迭代，其实这样存在的问题就是如果初始点随机选取的有误，导致无论这么迭代都得不到最优的点，如： 在随机初始点的情况下，红色区域的部分点被蓝色和绿色侵占为己点，修正初始点，也就是将随机初始点的聚类中心全部上移的情况下，蓝色点区收回了原属于自己的点区。之前我恶补过一片论文：《K-means 初始聚类中心的选择算法》，里面提出了两个指标来衡量：1.k-dist某个点 p 到它的第k 个最近点的距离为点 p 的 k-dist 值。点的 k-dist 半径范围内至少包含k + 1 个点，理论上同一个聚类中改变k值不会引起k-dist值明显变化。将 k-dist 值由小到大排序，a、b、c表示平缓点，d，e，f为跃迁点。2.DK图k-dist 图中相邻两点的 k-dist 值之差记为 DK。k-dist 图中相邻两点pm和pm－1的 k-dist的差为DKm=k-distm －k-distm－1 ( m ＞ 1) 。由于 k-distm 非递减，显然 DKm ＞ 0。DK 值接近的连续邻近点处于 k-dist 图的同一条平缓曲线上，即处于同一个密度层次; DK 值大幅跳动的点处于密度转折曲线或噪声曲线上。3.选择对 DK 值从小到大排序，得到 DK 标准范围δ。依据 DK 标准范围内对应的数据点的分布情况，在 k-dist 图中找出 k’ 个平缓曲线，代表 k’ 个主要密度水平。选择每个密度水平的第一个点作为初始聚类中心。重复若干次，得到若干组的优化聚类中心，在根据优化聚类中心组下的组内间距和／组外间距和判断那个点组为最优点组。 其实这样的开销也挺大的，目前也没有看到其它比较易理解的kmeans的初始点计算的方式。 大致讲解一下最优化中拉格朗日乘子法的思路？KKT是什么？当我们求解一个函数的最小值，且这个函数也被某些确定的限制条件限制的时候： 我们可以将限制条件加入f(x)中一同进行后续的偏导计算： 至于KKT我了解的其实不多，也是回来之后恶补了一下，通过例子入手： 求解上面这个问题的化，我们需要考虑构造两个约束变量a1，b1，使得h1(x，a1)＝g1(x)＋a1^2＝a－x＋a1^2=0h2(x，b1)＝g2(x)＋b1^2＝b－x＋b1^2=0在根据普通拉格朗日乘子的方法对下面公式的每一项求偏导： 这个条件就是KKT条件其实我觉得，http://www.cnblogs.com/zhangchaoyang/articles/2726873.html，这篇文章写的挺好的，想要详细了解的可以仔细参考一下。 听说你做过风控，异常点检测你用过什么办法？之前正好整理过，内心大喜：1.6个西格玛的原理2.箱式图大于3/2QI＋Q3，小于Q1－3/2Qi3.基于距离离群检测（聚类），包括欧式、马氏距离、街道距离这边被打断了，问了马氏距离的细节，好处：追问了协方差Sigma怎么算：Cov(X,Y)=E(XY)-E(X)E(Y)追问了什么时候用马氏距离比较好：举例很有名的曲线分布图，如下： 4.pca的基于特征值压缩的方法5.基于isolation forest识别的方法这边被追问了一次原理：1234567method:1.从原始数据中随机选择一个属性feature；2.从原始数据中随机选择该属性的下的一个样本值value；3.根据feature下的value对每条记录进行分类，把小于value的记录放在左子集，把大于等于value的记录放在右子集；4.repeat 1-3 until： 4.1.传入的数据集只有一条记录或者多条一样的记录； 4.2.树的高度达到了限定高度； 以s(x,n)为判断数据是否异常的衡量指标。其中，h(x)为x对应的节点深度，c(n)为样本可信度，s(x,n)~[0,1]，正常数据来讲s(x,n)小于0.8，s(x,n)越靠近1，数据异常的可能性越大。详细的可以参见我的另一篇博客：http://www.jianshu.com/p/ac6418ee8e3f 本来准备一次写完的，后来写着写着发现真的挺多，准备写个系列，最后谢谢大家的阅读。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVM理论解析及python实现]]></title>
    <url>%2F2017%2F12%2F01%2FSVM%E7%90%86%E8%AE%BA%E8%A7%A3%E6%9E%90%E5%8F%8Apython%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[关于常见的分类算法在不同数据集上的分类效果，在《Do we Need Hundreds of Classifiers to Solve Real World Classification Problems?》这个篇论文上有比较完善的总结，因为文章内容比较长，这边我总结了下我认为比较关键的一些结论： 仅仅参考论文评价我们常用的： 神经网络的效果最好，13.2%的数据集中取得第一 SVM的效果其次，10.7%的数据集中取得第一 Bagging和Boost紧随其后，9%~10%左右的数据集取得第一 Elastic Net等的线性算法效果普通，5%-7%的数据集上取得第一 附加一些我个人平时调参的经验及感悟： 神经网络拟合的效果好是基于大量的数据量上，如果数据集较小，训练结果通常不如上述其他算法；除此之外，神经网络的训练成本高，关于控制非线性变换的隐藏层层数，控制线性力度的节点个数的设置需要大量的历史经验，相对成本非常高。 SVM对数据集合量以及维度没有很高的要求，而且可以解决线性问题（kernel=linear），非线性问题（kernel=RBF等），而且相对来说效果优秀。但是SVM的核心是计算最大分隔的间隔，如果全都是分类变量，效果会受一定的影响，而且需要额外的操作才能获取概率结果。 Bagging和Boost，能够解决非线性问题，Bagging基于抽样抽特征，控制Var的情况下降低Bias；Boost基于N个弱分类器的强化组合，控制Bias的情况下降低Var，对数据格式的要求也很低，实现上比较友好。缺点可能就是太一般，没有专业领域的亮点。 Elastic Net等线性回归算法，对数据量数据维度没有什么要求，部分算法会自己压缩feature，简单易操作，相比于上述任何一个算法都好实现，除此之外，还可以得到概率结果。缺点就是效果较差，如果在feature和label没有线性关系的时候无法得到理想结果。 除了上述的方法，还有比如KNN、线性判别分析、Naive Bayes等方法，每个都有自己适用的场景，也但是通常不做首要考虑的分类算法。 针对其中的SVM，本文接下来和大家解析三个方面：1.感知机、线性感知机、核感知机的理论概览2.如何利用python中的sklearn快速的实现svm分类3.SMO方法的核心功能实现 如果你只是想快速了解分类算法的概览，方便面试或者日常“交流”，到此就可以不用往下看了。如果你是数据分析师或者软件工程师，只是想快速了解如果使用，直接跳到2。如果你是机器学习工程师，需要对整个算法有个了解，贯穿整个SVM过程，直接看1，2。如果你是算法工程师，需要重构算法，或在当前解决核函数计算瓶颈的，请全文阅读，并阅读推荐书籍。 让我们开始正文： 感知机、线性感知机、核感知机的理论概览感知机我们日常说的SVM其实只是一个感知机，也就是没有任何的核函数的情况。 上面图中，对于二维数据来说，平面π1，π2，π3都可以将红色和蓝色的点给划分开。对于多维数据来说，这边的平面就可以引申为超平面，wx+b=0。 所以，我们可以说，对于数据集:如果我们可以得到超平面wx+b=0，使得y=1的点集合与y=-1的点的集合分隔在平面两边（如上图所示），那我们就说原始数据集D线性可分，wx+b=0为其超平面。 首先，我们定义损失函数为：L=max(-y(wx+b),0)，我们来看下，如果我们预测正确，y=1，我们预测的为wx+b&gt;0或者，y=-1，我们预测的为wx+b0,则不贡献梯度；否则，我们可以取-y(wx+b)为梯度，也就得到了上述的梯度公式。接下来的就是常规意义上的对w和b的偏导，然后梯度下降求极值。 线性感知机现在我们思考两个问题：a.上述的π1、π2、π3都是感知机，如何选取最优？b.下面这张图线性不可分，如何解决？ 我们先来看，平面π1外任意点到平面的距离如何计算：假设任意点为X(x，y)，垂点X1(x1，y1)，垂点在π1平面(wx+b=0)上，所以，我们有X-X1=ρw，w为平面π1的法向量。所以，我们有：||X-X1||**2=ρw(X-X1)=ρ(wx+b-(wx1+b))=ρ(wx+b)=ρ(wx+b)在计算距离的时候，我们需要去归一化，无量纲化。不难看出，距离的计算方式为： 所以，我们在超平面选取的时候，需要考虑两点：(1)所以的分类结果要保持正确： (2)保证决策面离正负样本都极可能的远： 里面的min的作用是计算所有的点到平面π的最小距离，外面的max的作用是尽可能的让最小距离最大，保证决策面离正负样本都尽可能的远。 假设(x1,y1)到决策平面的距离最近，所有y1(wx1+b)&gt;=1,所以目标函数：max(1/||w||)，可以优化为min(||w||^2/2)。但是如果发生1.2节最开始的线性不可分的问题的时候，y1(wx1+b)&gt;=1就无法实现，所有我们需要加∆的容忍度，也就是变成了y1(wx1+b)&gt;=1-∆。既然加了∆，我们也需要对∆进行控制：∆=1-y1(wx1+b)，有更新后的目标函数： 这边的[]+记为神经网络中常用的ReLU函数。有了这个目标函数，接下来就是正常的梯度下降，偏导后求解的过程。 核函数下的感知机上面考虑的问题均是线性可分的问题，假设数据分布如下： 无论通过平面π1、π2、还是π3均无法做到线性的分割。而核函数的目的就是通过内积的形式，将低维度的数据映射到高维度，通常采取的方式是w=∑αx的形式，带回到原来的损失函数：比如普通感知机的： 比如线性感知机 K(xi,xj)常用的有：多项式核函数：(xi+xj+1)^p 径向基核函数：exp(-ρ||xi-xj||^2) 至于之后的计算，还是可以和之前一致，将上述选择的核函数代入损失函数后采取梯度下降的方法，高效计算方式SMO算法在第三模块会简单的梳理一遍。 以上我们就大概的了解了感知机，linear svm，kernel svm的损失函数的来源及构造细节等等，接下来我们来看下如何快速的使用。 如何利用python中的sklearn快速的实现svm分类在python的sklearn包中，有SVM的包，其中SVC是分类，SVR是回归，可以快速简单的上手，下面上code，并在注释中解释：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import pandas as pdimport numpy as npimport matplotlib.pyplot as pltfrom sklearn import svmfrom sklearn.cross_validation import train_test_split#data add,数据读取risk_data=pd.read_table('/Users/slade/Desktop/Python File/data/data_all.txt')#data check，删除无用的列risk_data = risk_data.drop('Iphone',axis=1)#data scale，数据归一化（必备的操作），上述理论中也体现归一化后的距离计算的原因risk_data_mm = risk_data.max()-risk_data.min()risk_data_scale = pd.DataFrame([])for i in range(len(risk_data.columns)): new_columns = (risk_data.iloc[:,i]-risk_data.iloc[:,i].min())/risk_data_mm[i] risk_data_scale = pd.concat([risk_data_scale,pd.DataFrame(new_columns)],axis=1)#split data（将数据分割成训练集和测试集）train_data,test_data = train_test_split(risk_data_scale,test_size = 0.3)#update_train,update_test（因为我的数据集是非常不平衡的，这边我采取了欠采样的方法）train_badcase = train_data[train_data['tag']==1]train_goodcase = train_data[train_data['tag']!=1]sample_value=(10*train_badcase.count()[0])train_goodcase_sample = train_goodcase.sample(n=sample_value)train_data_update = pd.concat([train_badcase,train_goodcase_sample],axis = 0)y=train_data_update['tag']x=train_data_update.iloc[:,1:len(train_data_update.columns)]#svm（linear、rbf、sigmoid为核的SVM）clf_linear = svm.SVC(kernel='linear').fit(x,y)clf_rbf = svm.SVC(kernel='rbf').fit(x,y)clf_sigmoid = svm.SVC(kernel='sigmoid').fit(x,y)#test，训练数据处理y_test = test_data[['tag']]x_test = test_data.iloc[:,1:len(test_data.columns)]#模型效果对比#lineartest_pred=clf_linear.predict(x_test)y_test.index = range(y_test.count())union_actual_pred = pd.concat([y_test,pd.DataFrame(test_pred)],axis = 1)#show the resultrecall = union_actual_pred[union_actual_pred.iloc[:,0]==1][union_actual_pred.iloc[:,1]==1].count()/union_actual_pred[union_actual_pred.iloc[:,0]==1].count()percison = union_actual_pred[union_actual_pred.iloc[:,0]==1][union_actual_pred.iloc[:,1]==1].count() / union_actual_pred[union_actual_pred.iloc[:,1]==1].count()correction = union_actual_pred[union_actual_pred.iloc[:,0]==union_actual_pred.iloc[:,1]].count()/union_actual_pred.iloc[:,0].count()print 'about the linear svm , the recall is %s' %recallprint 'about the linear svm , the percison is %s' %percisonprint 'about the linear svm , the correction is %s' %correction#rbftest_pred=clf_rbf.predict(x_test)y_test.index = range(y_test.count())union_actual_pred = pd.concat([y_test,pd.DataFrame(test_pred)],axis = 1)#show the resultrecall = union_actual_pred[union_actual_pred.iloc[:,0]==1][union_actual_pred.iloc[:,1]==1].count()/union_actual_pred[union_actual_pred.iloc[:,0]==1].count()percison = union_actual_pred[union_actual_pred.iloc[:,0]==1][union_actual_pred.iloc[:,1]==1].count() / union_actual_pred[union_actual_pred.iloc[:,1]==1].count()correction = union_actual_pred[union_actual_pred.iloc[:,0]==union_actual_pred.iloc[:,1]].count()/union_actual_pred.iloc[:,0].count()print 'about the linear svm , the recall is %s' %recallprint 'about the linear svm , the percison is %s' %percisonprint 'about the linear svm , the correction is %s' %correction#sigmoidtest_pred=clf_sigmoid.predict(x_test)y_test.index = range(y_test.count())union_actual_pred = pd.concat([y_test,pd.DataFrame(test_pred)],axis = 1)#show the resultrecall = union_actual_pred[union_actual_pred.iloc[:,0]==1][union_actual_pred.iloc[:,1]==1].count()/union_actual_pred[union_actual_pred.iloc[:,0]==1].count()percison = union_actual_pred[union_actual_pred.iloc[:,0]==1][union_actual_pred.iloc[:,1]==1].count() / union_actual_pred[union_actual_pred.iloc[:,1]==1].count()correction = union_actual_pred[union_actual_pred.iloc[:,0]==union_actual_pred.iloc[:,1]].count()/union_actual_pred.iloc[:,0].count()print 'about the linear svm , the recall is %s' %recallprint 'about the linear svm , the percison is %s' %percisonprint 'about the linear svm , the correction is %s' %correction 上述粗略的给出了如何快速的通过svm进行一次训练，现在就svc中的参数进行剖析：C:惩罚力度，C越大代表惩罚程度越大，越不能容忍有点集交错的问题kernel:核函数，常规的有‘linear’, ‘poly’, ‘rbf’, ‘sigmoid’, ‘precomputed’ ，默认的是rbfdegree:当poly为核函数时启动，默认是3gamma:当‘rbf’, ‘poly’ 和 ‘sigmoid’为核函数时的参数设置，默认的是特征个数的倒数probability：是否输出概率值shrinking:是否自启动tol:停止训练的容忍度max_iter：最大的训练次数class_weight:因变量的权重decision_function_shape:因变量的形式：ovo一对一, ovr一对多, 默认’ovr’根据自己的需求，对上述的参数进行grid_search即可完成快速训练任务。 3.SMO方法的核心功能实现首先，我们需要明确，SVM学习过程可以转化为以下问题： 至于什么是KKT条件，请参照总结：常见算法工程师面试题目整理(二)中的回答。求解的方式也是比较复杂，这主要以梳理流程为主，我们的目的就是找到一组αi满足上述的约束，然后再根据该组的αi求解到w和b即可。 求解αi的过程如下：12341.选择两个拉格朗日乘子αi和αj2.固定其他拉格朗日乘子αk(k不等于i和j)，只对αi和αj优化w(α)3.根据优化后的αi和αj，更新截距b的值4.充分1-3直到收敛 针对上面的过程存在2个问题a.为什么要选择两个乘子？而不是更加方便计算的一个？在原始的约束条件中，存在：如果只选择一个为变化乘子的化，根据其他确定的乘子，该变化乘子也无法变化。 b.如何选择两个乘子αi和αj？ 检验样本是否满足KKT条件也就是检验样本是否满足以下条件： 第一个参数αi优先检验0&lt;αj&lt;C也就是π3和π1平面上的点是否满足条件，如果全部满足条件，再检验全部数据集是否满足条件。 第二个参数αj则可以简单地随机选取，虽然这不是特别好，但效果已然不错。也可以通过最大化αi的误差与αj的误差之差的绝对值去判断，但是计算量会变大，因为又做了一次全量数据循环。 当αi和αj有了之后再去对b进行修正： 即可。 这边的代码比较复杂，我就不贴了，百度上很多实现了的版本。 总的来说，我们对svm的过程有了个浅尝辄止的了解，部分算法工程师需要要深入的了解其深刻完整的含义，仍需完整完善的学习，《统计学习方法 》一书讲的深入透彻，建议可以研读一下。 部分软件工程师在运用中可能需要各种版本的svm，这边也贴出地址，供参考Support Vector Machine for Complex Outputs 最后，谢谢大家的阅读。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>超平面分割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[能够快速实现的协同推荐]]></title>
    <url>%2F2017%2F12%2F01%2F%E8%83%BD%E5%A4%9F%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8D%8F%E5%90%8C%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[对于中小型的公司，用户的数据量及公司产品的个数都是较小规模的，需要提供给用户的推荐系统实现的重心也从人性化变成了实现成本，协同推荐就是非常常见、有效且可以快速实现的方法，也是本文想介绍的。 常规的快速简单推荐系统实现方法不排除以下几种： 热门推荐所有人打开浏览的内容都一致，惊喜性会有所缺失，但是实现特别简单，稍加逻辑带给用户的体验感满足了基本需求。 SVD+推荐之前也讨论过实现方法了，附上链接：SVD及扩展的矩阵分解方法 基于模型推荐这个比较偏向业务场景，可以说是经典的场景化模型，之前写过一篇基于用户特征的偏好推荐，可以参考一下：苏宁易购的用户交叉推荐 协同推荐这个也是几乎每个公司都会用的，也是非常非常常见有效的算法之一 协同推荐介绍首先，我们先来了解一下什么叫做协同推荐。基于用户的协同过滤推荐算法是最早诞生的，1992年提出并用于邮件过滤系统，两年后1994年被 GroupLens 用于新闻过滤。一直到2000年左右，该算法都是推荐系统领域最著名的算法。算是非常古董级别的算法之一了，但是古董归古董，它的效果以及实现的成本却奠定了它在每个公司不可取代的地位。 基于用户的协同推荐123用户u1喜欢的电影是A，B，C用户u2喜欢的电影是A, C, E, F用户u3喜欢的电影是B，D 假设u1、u2、u3用户喜欢的电影分布如上，基于用户的协同推荐干了这么一件事情，它根据每个用户看的电影（A、B、C、…）相似程度，来计算用户之间的相似程度，将高相似的用户看过但是目标用户还没有看过的电影推荐给目标用户。 基于商品的协同推荐123456电影A被u1，u2看过电影B被u1，u3看过电影C被u1，u2看过电影D被u3看过电影E被u2看过电影F被u2看过 假设A～F电影被用户观影的分布如上，基于商品的协同推荐干了这么一件事情，它根据电影（A、B、C、…）被不同用户观看相似程度，来计算电影之间的相似程度，根据目标用户看过的电影的高相似度的电影推荐给目标用户。 看起来以上的逻辑是非常简单的，其实本来也是非常简单的，我看了下，网上关于以上的代码实现还是比较林散和有问题的，优化了python版本的code，并详细解释了每一步，希望，对初学者有所帮助。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#time 2017-09-17#author：shataowei#based-item#所要的基础包比较简单from collections import defaultdictimport mathimport timestartTime = time.time()#读取数据的过程#/Users/slade/Desktop/machine learning/data/recommender/u1.basedef readdata(location): list2item = &#123;&#125; #商品对应的用户列表(1:[[1,2],[2,3]]代表商品1对应用户1的行为程度为2,商品1对应的用户2的行为程度为3) list2user = &#123;&#125; #用户对应的商品列表(1:[[1,2],[2,3]]代表用户1对应商品1的行为程度为2,用户1对应的商品2的行为程度为3) f = open(location,'r') data = f.readlines() data = [x.split('\t') for x in data] f.close() for i in data: if int(i[1]) not in list2item.keys(): list2item[int(i[1])] = [[int(i[0]),int(i[2])]] else: list2item[int(i[1])].append([int(i[0]),int(i[2])]) if int(i[0]) not in list2user.keys(): list2user[int(i[0])] = [[int(i[1]),int(i[2])]] else: list2user[int(i[0])].append([int(i[1]),int(i[2])]) return list2item,list2user#list2item,list2user=readdata('/Users/slade/Desktop/machine learning/data/recommender/u1.base')## 基于item的协同推荐#0.将用户行为程度离散化：浏览：1，搜索：2，收藏：3，加车：4，下单未支付5#1.计算item之间的相似度：item共同观看次数/单item次数连乘#2.寻找目标用户观看过的item相关的其他item列表#3.计算其他item的得分：相似度*用户行为程度，求和#0 hive操作# 1.1统计各商品出现次数def itemcf_itemall(userlist = list2user): I=&#123;&#125; for key in userlist: for item in userlist[key]: if item[0] not in I.keys(): I[item[0]] = 0 I[item[0]] = I[item[0]] + 1 return I# 1.2计算相似矩阵def itemcf_matrix(userlist = list2user): C=defaultdict(defaultdict) W=defaultdict(defaultdict)#根据用户的已购商品来形成对应相似度矩阵 for key in userlist: for item1 in userlist[key]: for item2 in userlist[key]: if item1[0] == item2[0]: continue if item2 not in C[item1[0]].keys(): C[item1[0]][item2[0]] = 0 C[item1[0]][item2[0]] = C[item1[0]][item2[0]] + 1#计算相似度，并填充上面对应的相似度矩阵 for i , j in C.items(): for z , k in j.items(): W[i][z] = k/math.sqrt(I[i]*I[z])#k/math.sqrt(I[i]*I[z])计算相似度，其中k为不同商品交集，sqrt(I[i]*I[z])用来压缩那些热门商品必然有高交集的问题 return W#2.寻找用户观看的其他itemdef recommendation(userid,k): score_final = defaultdict(int) useriditem = [] for item,score in list2user[userid]:#3.计算用户的item得分，k来控制用多少个相似商品来计算最后的推荐商品 for i , smimilarity in sorted(W[item].items() , key = lambda x:x[1] ,reverse =True)[0:k]: for j in list2user[userid]: useriditem.append(j[0]) if i not in useriditem: score_final[i] = score_final[i] + smimilarity * score#累加每一个商品用户的评分与其它商品的相似度积的和作为衡量#最后的10控制输出多少个推荐商品 l = sorted(score_final.items() , key = lambda x : x[1] , reverse = True)[0:10] return l#I = itemcf_itemall()#W = itemcf_matrix()#result_userid = recommendation(2,k=20)endTime = time.time()print endTime-startTime python来实现基于item的协同推荐就完成了，核心的相似度计算可以根据实际问题进行修改，整体流程同上即可，当然数据量大的时候分布式去写也是可以的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104#time 2017-09-17#author：shataowei#based-userfrom collections import defaultdictimport mathimport timestartTime = time.time()#读取数据#/Users/slade/Desktop/machine learning/data/recommender/u1.basedef readdata(location): list2item = &#123;&#125; #商品对应的用户列表 list2user = &#123;&#125; #用户对应的商品列表 f = open(location,'r') data = f.readlines() data = [x.split('\t') for x in data] f.close() for i in data: if int(i[1]) not in list2item.keys(): list2item[int(i[1])] = [[int(i[0]),int(i[2])]] else: list2item[int(i[1])].append([int(i[0]),int(i[2])]) if int(i[0]) not in list2user.keys(): list2user[int(i[0])] = [[int(i[1]),int(i[2])]] else: list2user[int(i[0])].append([int(i[1]),int(i[2])]) return list2item,list2user#list2item,list2user=readdata('/Users/slade/Desktop/machine learning/data/recommender/u1.base')#基于用户的协同推荐#0.先通过hive求出近一段时间（根据业务频率定义），用户商品的对应表#1.求出目标用户的邻居，并计算目标用户与邻居之间的相似度#2.列出邻居所以购买的商品列表#3.针对第二步求出了商品列表，累加所对应的用户相似度，并排序求top#0.hive操作#1.1求出目标用户的邻居，及对应的相关程度def neighbour(userid,user_group = list2user,item_group = list2item): neighbours = &#123;&#125; for item in list2user[userid]: for user in list2item[item[0]]: if user[0] not in neighbours.keys(): neighbours[user[0]] = 0 neighbours[user[0]] = neighbours[user[0]] + 1 return neighbors#通常来说，基于item的推荐对于商品量较大的业务会构成一个巨大的商品矩阵，这时候如果用户人均购买量较低的时候，可以考虑使用基于user的推荐，它在每次计算的时候会只考虑相关用户，也就是这边的neighbours(有点支持向量基的意思)，大大的降低了计算量。#neighbours = neighbour(userid=2)#1.2就算用户直接的相似程度,这边用的余弦相似度：点积/模的连乘def similarity(user1,user2): x=0 y=0 z=0 for item1 in list2user[user1]: for item2 in list2user[user2]: if item1[0]==item2[0]: x1 = item1[1]*item1[1] y1 = item2[1]*item2[1] z1 = item1[1]*item2[1] x = x + x1 y = y + y1 z = z + z1#避免分母为0 if x * y == 0 : simi = 0 else: simi = z / math.sqrt(x * y) return simi#1.3计算目标用户与邻居之间的相似度：def N_neighbour(userid,neighbours,k): neighbour = neighbours.keys() M = [] for user in neighbour: simi = similarity(userid,user) M.append((user,simi)) M = sorted(M,key = lambda x:x[1] ,reverse = True)[0:k] return M#M = N_neighbour(userid,neighbours,k=200)#2.列出邻居所购买过的商品并计算商品对应的推荐指数def neighbour_item(M=M): R = &#123;&#125; M1 = dict(M) for neighbour in M1: for item in list2user[neighbour]: if item[0] not in R.keys(): R[item[0]] = M1[neighbour] * item[1] else: R[item[0]] = R[item[0]] + M1[neighbour] * item[1]#根据邻居买过什么及与邻居的相似度，计算邻居买过商品的推荐度 return R# R = neighbour_item(M)#3.排序得到推荐商品Rank = sorted(R.items(),key=lambda x:x[1],reverse = True)[0:50]endTime = time.time()print endTime-startTime python来实现基于user的协同推荐就完成了，核心的相似度计算可以根据实际问题进行修改，基于user的实现过程中，用了邻居这个概念，大大降低了计算量，我用了大概20万用户，2千的商品数，基于user的推荐实现速度大概为基于商品的10分之一，效果差异却相差不大。 协同推荐是非常简单的推荐入门算法之一，也是必须要手动快速代码实现的算法之一，希望能给大家一些帮助。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Tensorflow的神经网络解决用户流失概率问题]]></title>
    <url>%2F2017%2F12%2F01%2F%E5%9F%BA%E4%BA%8ETensorflow%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%A7%A3%E5%86%B3%E7%94%A8%E6%88%B7%E6%B5%81%E5%A4%B1%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言：用户流失一直都是公司非常重视的一个问题，也是AAARR中的Retention的核心问题，所以各大算法竞赛都很关注。比如最近的：KKBOX的会员流失预测算法竞赛，如何能够搭建一个精准的模型成了大家探索的重要问题。本文主要讲解神经网络、TensorFlow的概述、如何利用python基于TensorFlow神经网络对流失用户进行分类预测，及可能存在的一些常见问题，作为深度学习的入门阅读比较适合。 行业做法：通常的行业预测用户流失大概分以下几种思路： 利用线性模型(比如Logistic)＋非线性模型Xgboost判断用户是否回流逝 这种方法有关是行业里面用的最多的，效果也被得意验证足够优秀且稳定的。核心点在于特征的预处理，Xgboost的参数挑优，拟合程度的控制，这个方法值得读者去仔细研究一边。问题也是很明显的，会有一个行业baseline，基本上达到上限之后，想有有提升会非常困难，对要求精准预测的需求会显得非常乏力。 规则触发 这种方法比较古老，但是任然有很多公司选择使用，实现成本较低而且非常快速。核心在于，先确定几条核心的流失指标(比如近7日登录时长)，然后动态的选择一个移动的窗口，不停根据已经流失的用户去更新流失指标的阈值。当新用户达到阈值的时候，触发流失预警。效果不如第一个方法，但是实现简单，老板也很容易懂。 场景模型的预测 这个方法比较依赖于公司业务的特征，如果公司业务有部分依赖于评论，可以做文本分析，比如我上次写的基于word2vec下的用户流失概率分析。如果业务有部分依赖于登录打卡，可以做时间线上的频次预估。这些都是比较偏奇门易巧，不属于通用类别的，不过当第一种方法达到上线的时候，这种方法补充收益会非常的大。 其实还有很多其它方法，我这边也不一一列出了，这个领域的方法论还是很多的。 神经网络 核心上面这张图片诠释了神经网络正向传播的流程，先通过线性变换(上图左侧)Σxw+b将线性可分的数据分离，再通过非线性变换(上图右侧)Sigmoid函数将非线性可分的数据分离，最后将输入空间投向另一个输出空间。 根据上面所说，我们可以知道，通过增加左侧线性节点的个数，我们可以强化线性变换的力度；而通过增加层数，多做N次激活函数(比如上面提到的Sigmoid)可以增强非线性变换的能力。 通过矩阵的线性变换+激活矩阵的非线性变换，将原始不可分的数据，先映射到高纬度，再进行分离。但是这边左侧节点的个数，网络的层数选择是非常困难的课题，需要反复尝试。 参数训练刚才我们了解了整个训练的流程，但是如何训练好包括线性变换的矩阵系数是一个还没有解决的问题。 我们来看下面的过程：input ==&gt; Σxw+b(线性变换) ==&gt; f(Σxw+b)(激活函数) ==&gt; …(多层的话重复前面过程) ==&gt; output(到此为止，正向传播结束，反向修正矩阵weights开始) ==&gt; error=actual_output-output(计算预测值与正式值误差)==&gt;output处的梯度==&gt;调整后矩阵weight=当前矩阵weight+errorx学习速率xoutput处的负梯度核心目的在于通过比较预测值和实际值来调整权重矩阵，将预测值与实际值的差值缩小。比如：梯度下降的方法，通过计算当前的损失值的方向的负方向，控制学习速率来降低预测值与实际值间的误差。 利用一行代码来解释就是 synaptic_weights += dot(inputs, (real_outputs - output) * output * (1 - output))*η这边output * (1 - output))是在output处的Sigmoid的倒数形式，η是学习速率。 神经网络流程小结123456789101数据集获取（有监督数据整理）2神经网络参数确定，有多少层，多少个节点，激活函数是什么，损失函数是什么3数据预处理，pca，标准化，中心化，特征压缩，异常值处理4初始化网络权重5网络训练 5.1正向传播 5.2计算loss 5.3计算反向梯度 5.4更新梯度 5.5重新正向传播 这边只是简单介绍了神经网络的基础知识，针对有一定基础的朋友唤醒记忆，如果纯小白用户，建议从头开始认真阅读理解一遍过程，避免我讲的有偏颇的地方对你进行误导。 TensorFlow理论上讲，TensorFlow工具可以单独写一本书，用法很多而且技巧性的东西也非常的复杂，这边我们主要作为工具进行使用，遇到新技巧会在code中解释，但不做全书的梳理，建议去买一本《TensorFlow实战Google深度学习框架》，简单易懂。 TensorFlow是谷歌于2015年11月9日正式开源的计算框架，由Jeff Dean领导的谷歌大脑团队改编的DistBelief得到的，在ImageNet2014、YouTube视频学习，语言识别错误率优化，街景识别，广告，电商等等都有了非常优秀的产出，是我个人非常喜欢的工具。 除此之外，我在列出一些其他的框架工具供读者使用： 接下来看一下最基本的语法，方便之后我们直接贴代码的时候可以轻松阅读。 张量：可以理解为多维array 或者 list，time决定张量是什么tf.placeholder(time,shape,name) 变量：同一时刻下的不变的数据tf.Variable(value,name) 常量：永远不变的常值tf.constant(value) 执行环境开启与关闭，在环境中才能运行TensorFlow语法sess=tf.Session()sess.close()sess.run(op) 初始化所有权重：类似于变量申明tf.initialize_all_variables() 更新权重：tf.assign(variable_to_be_updated,new_value) 加值行为，利用feed_dict里面的值来训练[output]函数sess.run([output],feed_dict={input1:value1,input2:value2})利用input1，input2，来跑output的值 矩阵乘法，类似于dottf.matmul(input,layer1) 激活函数，relutf.nn.relu()，除此之外，还有tf.nn.sigmoid，tf.nn.tanh等等 用户流失分析说了那么多前置的铺垫，让我们来真实的面对我们需要解决的问题： 首先，我们拿到了用户是否流失的历史数据集20724条，流失与飞流失用户占比在1:4，这部分数据需要进行一下预处理，这边就不细讲预处理过程了，包含缺失值填充(分层填充)，异常值处理(isolation foest)，数据平衡(tomek link)，特征选择(xgboost importance)，特征变形(normalizing)，特征分布优化等等，工程技巧我之前的文章都有讲解过，不做本文重点。 taiking is cheap,show me the code. 12345678#author:shataowei#time:20170924#基础包加载import numpy as npimport pandas as pdimport tensorflow as tfimport mathfrom sklearn.cross_validation import train_test_split 12345678910111213141516171819202122232425262728#数据处理data = pd.read_table(&apos;/Users/slade/Desktop/machine learning/data/data_all.txt&apos;)data = data.iloc[:,1:len(data.columns)]data1 = (data - data.mean())/data.std()labels = data[&apos;tag&apos;]items = data1.iloc[:,1:len(data1.columns)]all_data = pd.concat([pd.DataFrame(labels),items],axis = 1)#数据集切分成训练集和测试集，占比为0.8：0.2train_X,test_X,train_y,test_y = train_test_split(items,labels,test_size = 0.2,random_state = 0)#pandas读取进来是dataframe，转换为ndarray的形式train_X = np.array(train_X)test_X = np.array(test_X)#我将0或者1的预测结果转换成了[0,1]或者[1,0]的对应形式，读者可以不转train_Y = []for i in train_y: if i ==0: train_Y.append([0,1]) else: train_Y.append([1,0])test_Y = []for i in test_y: if i ==0: test_Y.append([0,1]) else: test_Y.append([1,0]) 下面我们就要开始正式开始训练神经网络了，123456789101112131415161718192021222324252627input_node = 9 #输入的feature的个数，也就是input的维度output_node = 2 #输出的[0,1]或者[1,0]的维度layer1_node = 500 #隐藏层的节点个数，一般在255-1000之间，读者可以自行调整batch_size = 200 #批量训练的数据，batch_size越小训练时间越长，训练效果越准确（但会存在过拟合）learning_rate_base = 0.8 #训练weights的速率ηregularzation_rate = 0.0001 #正则力度training_steps = 10000 #训练次数，这个指标需要类似grid_search进行搜索优化#设定之后想要被训练的x及对应的正式结果y_x = tf.placeholder(tf.float32,[None,input_node])y_ = tf.placeholder(tf.float32,[None,output_node])#input到layer1之间的线性矩阵weightweight1 = tf.Variable(tf.truncated_normal([input_node,layer1_node],stddev=0.1))#layer1到output之间的线性矩阵weightweight2 = tf.Variable(tf.truncated_normal([layer1_node,output_node],stddev=0.1))#input到layer1之间的线性矩阵的偏置biases1 = tf.Variable(tf.constant(0.1,shape = [layer1_node]))#layer1到output之间的线性矩阵的偏置biases2 = tf.Variable(tf.constant(0.1,shape=[output_node]))#正向传播的流程，线性计算及激活函数relu的非线性计算得到resultdef interence(input_tensor,weight1,weight2,biases1,biases2): layer1 = tf.nn.relu(tf.matmul(input_tensor,weight1)+biases1) result = tf.matmul(layer1,weight2)+biases2 return resulty = interence(x,weight1,weight2,biases1,biases2) 正向传播完成后，我们要反向传播来修正weight1234567891011121314151617181920global_step = tf.Variable(0,trainable = False)#交叉熵，用来衡量两个分布之间的相似程度cross_entropy = tf.nn.softmax_cross_entropy_with_logits(labels = y_,logits=y)cross_entropy_mean = tf.reduce_mean(cross_entropy)#l2正则化，这部分的理论分析可以参考我之前写的：http://www.jianshu.com/p/4f91f0dcba95regularzer = tf.contrib.layers.l2_regularizer(regularzation_rate)regularzation = regularzer(weight1) + regularzer(weight2)#损失函数为交叉熵+正则化loss = cross_entropy_mean + regularzation#我们用learning_rate_base作为速率η，来训练梯度下降的loss函数解train_op = tf.train.GradientDescentOptimizer(learning_rate_base).minimize(loss,global_step = global_step)#y是我们的预测值，y_是真实值，我们来找到y_及y(比如[0.1，0.2])中最大值对应的index位置，判断y与y_是否一致correction = tf.equal(tf.argmax(y,1),tf.argmax(y_,1))#如果y与y_一致则为1，否则为0，mean正好为其准确率accurary = tf.reduce_mean(tf.cast(correction,tf.float32)) 模型训练结果1234567891011121314151617#初始化环境，设置输入值，检验值init = tf.global_variables_initializer()sess = tf.Session()sess.run(init)validate_feed = &#123;x:train_X,y_:train_Y&#125;test_feed = &#123;x:test_X,y_:test_Y&#125;#模型训练，每到1000次汇报一次训练效果for i in range(training_steps): start = (i*batch_size)%len(train_X) end = min(start+batch_size,16579) xs = train_X[start:end] ys = train_Y[start:end] if i%1000 ==0: validate_accuary = sess.run(accurary,feed_dict = validate_feed) print &apos;the times of training is %d, and the accurary is %s&apos; %(i,validate_accuary) sess.run(train_op,feed_dict = &#123;x:xs,y_:ys&#125;) 训练的结果如下：12345678910111213142017-09-24 12:11:28.409585: W tensorflow/core/platform/cpu_feature_guard.cc:45] The TensorFlow library wasn&apos;t compiled to use SSE4.2 instructions, but these are available on your machine and could speed up CPU computations.2017-09-24 12:11:28.409620: W tensorflow/core/platform/cpu_feature_guard.cc:45] The TensorFlow library wasn&apos;t compiled to use AVX instructions, but these are available on your machine and could speed up CPU computations.2017-09-24 12:11:28.409628: W tensorflow/core/platform/cpu_feature_guard.cc:45] The TensorFlow library wasn&apos;t compiled to use AVX2 instructions, but these are available on your machine and could speed up CPU computations.2017-09-24 12:11:28.409635: W tensorflow/core/platform/cpu_feature_guard.cc:45] The TensorFlow library wasn&apos;t compiled to use FMA instructions, but these are available on your machine and could speed up CPU computations.the times of training is 0, and the accurary is 0.736775the times of training is 1000, and the accurary is 0.99246the times of training is 2000, and the accurary is 0.993003the times of training is 3000, and the accurary is 0.992943the times of training is 4000, and the accurary is 0.992943the times of training is 5000, and the accurary is 0.99234the times of training is 6000, and the accurary is 0.993124the times of training is 7000, and the accurary is 0.992943the times of training is 8000, and the accurary is 0.993124the times of training is 9000, and the accurary is 0.992943 初步看出，在训练集合上，准确率在能够99%以上，让我们在看看测试集效果 1test_accuary = sess.run(accurary,feed_dict = test_feed) Out[5]: 0.99034983,也是我们的测试数据集效果也是在99%附近，可以看出这个分类的效果还是比较高的。 初次之外，我们还可以得到每个值被预测出来的结果，也可以通过工程技巧转换为0-1的概率：1234567result_y = sess.run(y,feed_dict=&#123;x:train_X&#125;)result_y_update=[]for i in result_y: if i[0]&gt;=i[1]: result_y_update.append([1,0]) else: result_y_update.append([0,1]) ==&gt;12345678Out[7]:array([[-1.01412344, 1.21461654], [-3.66026735, 3.81834102], [-3.78952932, 3.79097509], ..., [-3.71239662, 3.65721083], [-1.59250259, 1.89412308], [-3.35591984, 3.24001145]], dtype=float32) 以上就实现了如果用TensorFlow里面的神经网络技巧去做一个分类问题，其实这并不TensorFlow的全部，传统的Bp神经网络，SVM也可以到达近似的效果，在接下来的文章中，我们将继续看到比如CNN图像识别，LSTM进行文本分类，RNN训练不均衡数据等复杂问题上面的优势。 ##可能存在的问题在刚做神经网络的训练前，要注意一下是否会犯以下的错误。 数据是否规范化模型计算的过程时间长度及模型最后的效果，均依赖于input的形式。大部分的神经网络训练过程都是以input为1的标准差，0的均值为前提的；除此之外，在算梯度算反向传播的时候，过大的值有可能会导致梯度消失等意想不到的情况，非常值得大家注意 batch的选择在上面我也提了，过小的batch会增加模型过拟合的风险，且计算的时间大大增加。过大的batch会造成模型的拟合能力不足，可能会被局部最小值卡住等等，所以需要多次选择并计算尝试。 过拟合的问题是否在计算过程中只考虑了损失函数比如交叉熵，有没有考虑l2正则、l2正则，或者有没有进行dropout行为，是否有必要加入噪声，在什么地方加入噪声（weight？input？），需不需要结合Bagging或者bayes方法等 激活函数的选择是否正确比如relu只能产出&gt;=0的结果，是否符合最后的产出结果要求。比如Sigmoid的函数在数据离散且均大于+3的数据集合上会产生梯度消失的问题，等等 到这里，我觉得一篇用TensorFlow来训练分类模型来解决用户流失这个问题就基本上算是梳理完了。很多简单的知识点我没有提，上面这些算是比较重要的模块，希望对大家有所帮助，最后谢谢大家的阅读。]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>CRM预估</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于SSD下的图像内容识别（二）]]></title>
    <url>%2F2017%2F12%2F01%2F%E5%9F%BA%E4%BA%8ESSD%E4%B8%8B%E7%9A%84%E5%9B%BE%E5%83%8F%E5%86%85%E5%AE%B9%E8%AF%86%E5%88%AB%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[上一节粗略的描述了如何关于图像识别，抠图，分类的理论相关，本节主要用代码，来和大家一起分析每一步骤。看完本节，希望你也能独立完成自己的图片、视频的内容实时定位。 首先，我们需要安装TensorFlow环境，建议利用conda进行安装，配置，90%尝试单独安装的人最后都挂了。 其次，我们需要安装从git上下载训练好的模型，git clone https://github.com/balancap/SSD-Tensorflow如果没有安装git的朋友，请自行百度安装。 最后找到你下载的位置进行解压，unzip ./SSD-Tensorflow/checkpoints/ssd_300_vgg.ckpt.zip这边务必注意，网上90%的教程这边就结束了，其实你这样是最后跑不通代码的，你需要把解压的文件进行移动到checkpoint的文件夹下面，这个问题git上这个同学解释了，详细的去看下https://github.com/balancap/SSD-Tensorflow/issues/150 最后的最后，下载你需要检测的网路图片，就ok了 预处理步骤完成了，下面让我们看代码。加载相关的包：123456789101112import osimport mathimport randomimport sysimport numpy as npimport tensorflow as tfimport cv2import matplotlib.pyplot as pltimport matplotlib.cm as mpcmsys.path.append('./SSD-Tensorflow/')from nets import ssd_vgg_300, ssd_common, np_methodsfrom preprocessing import ssd_vgg_preprocessing 配置相关TensorFlow环境123gpu_options = tf.GPUOptions(allow_growth=True)config = tf.ConfigProto(log_device_placement=False, gpu_options=gpu_options)isess = tf.InteractiveSession(config=config) 做图片的格式的处理，使他满足input的条件123456789101112131415161718192021222324#我们用的TensorFlow下的一个集成包slim，比tensor要更加轻便slim = tf.contrib.slim#训练数据中包含了一下已知的类别，也就是我们可以识别出以下的东西，不过后续我们将自己自己训练自己的模型，来识别自己想识别的东西l_VOC_CLASS = [ 'aeroplane', 'bicycle', 'bird', 'boat', 'bottle', 'bus', 'car', 'cat', 'chair', 'cow', 'diningTable', 'dog', 'horse', 'motorbike', 'person', 'pottedPlant', 'sheep', 'sofa', 'train', 'TV']# 定义数据格式net_shape = (300, 300)data_format = 'NHWC' # [Number, height, width, color]，Tensorflow backend 的格式# 预处理将输入图片大小改成 300x300，作为下一步输入img_input = tf.placeholder(tf.uint8, shape=(None, None, 3))image_pre, labels_pre, bboxes_pre, bbox_img = ssd_vgg_preprocessing.preprocess_for_eval( img_input, None, None, net_shape, data_format, resize=ssd_vgg_preprocessing.Resize.WARP_RESIZE)image_4d = tf.expand_dims(image_pre, 0) 下面我们来载入SSD作者已经搞定的模型123456789101112# 定义 SSD 模型结构reuse = True if 'ssd_net' in locals() else Nonessd_net = ssd_vgg_300.SSDNet()with slim.arg_scope(ssd_net.arg_scope(data_format=data_format)): predictions, localisations, _, _ = ssd_net.net(image_4d, is_training=False, reuse=reuse)# 导入官方给出的 SSD 模型参数#这边修改成你自己的路径ckpt_filename = '/Users/slade/SSD-Tensorflow/checkpoints/ssd_300_vgg.ckpt'isess.run(tf.global_variables_initializer())saver = tf.train.Saver()saver.restore(isess, ckpt_filename)ssd_anchors = ssd_net.anchors(net_shape) 下面让我们把SSD识别出来的结果在图片中表示出来1234567891011121314151617181920212223242526#不同类别，我们以不同的颜色表示def colors_subselect(colors, num_classes=21): dt = len(colors) // num_classes sub_colors = [] for i in range(num_classes): color = colors[I*dt] if isinstance(color[0], float): sub_colors.append([int(c * 255) for c in color]) else: sub_colors.append([c for c in color]) return sub_colors#画出在图中的位置def bboxes_draw_on_img(img, classes, scores, bboxes, colors, thickness=5): shape = img.shape for i in range(bboxes.shape[0]): bbox = bboxes[I] color = colors[classes[I]] # Draw bounding box... p1 = (int(bbox[0] * shape[0]), int(bbox[1] * shape[1])) p2 = (int(bbox[2] * shape[0]), int(bbox[3] * shape[1])) cv2.rectangle(img, p1[::-1], p2[::-1], color, thickness) # Draw text... s = '%s:%.3f' % ( l_VOC_CLASS[int(classes[i])-1], scores[I]) p1 = (p1[0]-5, p1[1]) cv2.putText(img, s, p1[::-1], cv2.FONT_HERSHEY_SIMPLEX, 1, color, 2)colors_plasma = colors_subselect(mpcm.plasma.colors, num_classes=21) 让我们开始训练吧123456789101112131415def process_image(img, select_threshold=0.3, nms_threshold=.8, net_shape=(300, 300)): #先获取SSD网络的层相关的参数 rimg, rpredictions, rlocalisations, rbbox_img = isess.run([image_4d, predictions, localisations, bbox_img], feed_dict=&#123;img_input: img&#125;) #获取分类结果，位置 rclasses, rscores, rbboxes = np_methods.ssd_bboxes_select( rpredictions, rlocalisations, ssd_anchors, select_threshold=select_threshold, img_shape=net_shape, num_classes=21, decode=True) rbboxes = np_methods.bboxes_clip(rbbox_img, rbboxes) rclasses, rscores, rbboxes = np_methods.bboxes_sort(rclasses, rscores, rbboxes, top_k=400) rclasses, rscores, rbboxes = np_methods.bboxes_nms(rclasses, rscores, rbboxes, nms_threshold=nms_threshold) # 让我们在图中画出来就行了 rbboxes = np_methods.bboxes_resize(rbbox_img, rbboxes) bboxes_draw_on_img(img, rclasses, rscores, rbboxes, colors_plasma, thickness=2) return img 预处理的函数都写完了，我们就可以执行了。12345#读取数据img = cv2.imread("/Users/slade/Documents/Yoho/picture_recognize/test7.jpg")img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)plt.imshow(process_image(img))plt.show() img的数据形式如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950In [8]: imgOut[8]:array([[[ 35, 59, 43], [ 37, 60, 44], [ 38, 61, 45], ..., [ 73, 99, 62], [ 74, 99, 60], [ 72, 97, 57]], [[ 37, 60, 44], [ 37, 60, 44], [ 37, 60, 44], ..., [ 66, 92, 57], [ 67, 93, 56], [ 67, 92, 53]], [[ 37, 60, 44], [ 36, 59, 43], [ 37, 58, 43], ..., [ 56, 83, 48], [ 60, 86, 51], [ 61, 87, 50]], ..., [[ 96, 101, 95], [107, 109, 104], [ 98, 97, 95], ..., [ 84, 126, 76], [ 72, 118, 72], [ 78, 126, 86]], [[ 98, 103, 96], [114, 116, 111], [112, 113, 108], ..., [ 94, 137, 84], [ 87, 133, 86], [105, 153, 111]], [[ 99, 105, 95], [110, 113, 106], [134, 135, 129], ..., [127, 170, 116], [121, 167, 118], [131, 180, 135]]], dtype=uint8) 处理后的结果如下： 是不是非常无脑，上面的代码直接复制就可以完成。 下面在拓展一下视频的处理方式，其实相关的内容是一致的。利用moviepy.editor包里面的VideoFileClip的切片的功能，然后对每一次切片的结果进行process_image过程就可以了，这边就不贴代码了，需要的朋友私密我。 最后感谢大家阅读。]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>图像识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于SSD下的图像内容识别（一）]]></title>
    <url>%2F2017%2F12%2F01%2F%E5%9F%BA%E4%BA%8ESSD%E4%B8%8B%E7%9A%84%E5%9B%BE%E5%83%8F%E5%86%85%E5%AE%B9%E8%AF%86%E5%88%AB%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[鸽了将近有一个月的时间没有更新东西，真的不是因为我懒，主要在忙一些工作上的事情，然后就是被安装caffe环境折磨的死去活来。我本来用的上mba来搭caffe环境的，一直在报一个框架问题，索性一怒之下换了mbp，下面就将我在SSD学习过程中遇到的问题和大家一起分享一下。 首先，先看一下我们能达到什么样的效果：比如,这样的： 再比如这样的： 甚至还可以这样：https://v.qq.com/x/page/a0567wd27jz.htmlhttps://v.qq.com/x/page/j05679xhryx.html这边吐槽一下，简书makedown不支持上传视频，简直差评！ 那问题来了，在真实的业务场景中，我们有哪些应用呢？比如天猫的拍照购： 有货的相似推荐：这些都是非常优秀的应用场景。 我们需要做哪些基本的步骤：抠出图片中关键的人或者物如果只需要抠出图片中的核心信息的话，其实只需要加载python里面的selectivesearch包就可以（这里多说一句，建议都是使用conda安装所有包和库，不然你会后悔的）。我们先来看下效果： 这个是怎么实现的呢？12345678910111213141516171819202122232425import cv2import selectivesearchimport matplotlib.pyplot as pltimport matplotlib.patches as mpatchesimport numpy as npimg = cv2.imread('/Users/slade/Documents/Yoho/picture_recognize/heshen.jpg')#图片识别分割img_lbl, regions =selectivesearch.selective_search( img, scale=500, sigma=0.9, min_size=20)#这边的regions里面就有一个个划分出来的boxregions[0]#Out[3]: &#123;'labels': [0.0], 'rect': (0, 0, 619, 620), 'size': 177325&#125;,其中‘rect’定位了box的位置，‘size’确定了box的大小# 接下来我们把窗口和图像打印出来，对它有个直观认识fig, ax = plt.subplots(ncols=1, nrows=1, figsize=(6, 6))ax.imshow(img)for reg in regions: x, y, w, h = reg['rect'] rect = mpatches.Rectangle( (x, y), w, h, fill=False, edgecolor='red', linewidth=1) ax.add_patch(rect)plt.show() 搜索完成后展示图：很明显，这里面的方框太多了，所以我们需要把一些过小的，过大的，不规则的全部去掉：12345678910111213141516171819202122232425262728293031323334353637383940candidates = []for r in regions: # 重复的不要 if r['rect'] in candidates: continue # 太小和太大的不要 if r['size'] &lt; 200 or r['size']&gt;20000: continue x, y, w, h = r['rect'] # 太不方的不要 if w / h &gt; 1.8 or h / w &gt; 1.8: continue candidates.append((x,y,w,h))#剔除大box内的小boxcandidates_sec = []for i in candidates: if len(candidates_sec)==0: candidates_sec.append(i) else: Flag=False replace=-1 index=0 for j in candidates_sec: ##新box在小圈 则删除 if i[0]&gt;=j[0] and i[0]+i[2]&lt;=j[0]+j[2] and i[1]&gt;=j[1] and i[1]+i[3]&lt;=j[1]+j[3]: Flag=True break ##新box不在小圈 而在老box外部 替换老box elif i[0]&lt;=j[0] and i[0]+i[2]&gt;=j[0]+j[2] and i[1]&lt;=j[1] and i[1]+i[3]&gt;=j[1]+j[3]: replace=index break index+=1 if not Flag: if replace&gt;=0: candidates_sec[replace]=i else: candidates_sec.append(i) 然后我们看看更新完后的图片效果：1234567fig, ax = plt.subplots(ncols=1, nrows=1, figsize=(6, 6))ax.imshow(img)for x, y, w, h in candidates_sec: rect = mpatches.Rectangle( (x, y), w, h, fill=False, edgecolor=&apos;red&apos;, linewidth=1) ax.add_patch(rect)plt.show() 在根据重复优化一下，就可以得到最初的那张图片，基本上来说，就可以完成抠图这个事情了。 相关理论概述：上面这样的识别从数学角度上是怎么样实现的呢？这边先引入一篇文章：2014年CVPR上的经典paper：《Rich feature hierarchies for Accurate Object Detection and Segmentation》，这篇文章的算法思想又被称之为：R-CNN（Regions with Convolutional Neural Network Features），是物体检测领域曾经获得state-of-art精度的经典文献。论文较为复杂冗长，我这边主要先看一下我们关系的抠图模块： 抠若干个box过程：先切分图片到若干子区域的集合S1.在计算集合S中找出相似性最大的区域max_similarity{ri,rj}2.合并S_new=ri∪rj3.从S集合中，移走所有与ri,rj的子集4.将新集合S_new与相邻区域的相似度5.repeat step2直到S集合为空这边相似度的计算考虑了三个方面：颜色相似，纹理相似，空间交错相似，分别解释如下：颜色相似：其中对每个区域，我们都可以得到一个一维的颜色分布直方图：假设两个直方图波峰和波谷高度重合，那么计算下来的值比较大；反之如果波峰和波谷错开的，那么累加的值一定比较小。 纹理相似：这边会用到SIFI算法，也是一个比较经典的算法。selectivesearch论文采用方差为1的高斯分布在8个方向做梯度统计，然后将统计结果（尺寸与区域大小一致）以bins=10计算直方图。（这个我也没有仔细去看，只是skip learn了一下） 空间相似：这个最简单，代码呈现了：123456789def sim_fill(r1, r2, imsize): """ calculate the fill_similarity over the image """ bbsize = ( (max(r1["max_x"], r2["max_x"]) - min(r1["min_x"], r2["min_x"])) * (max(r1["max_y"], r2["max_y"]) - min(r1["min_y"], r2["min_y"])) ) return 1.0 - (bbsize - r1["size"] - r2["size"]) / imsize 若干个box筛选的过程：首先，我们定义：IOU为两个bounding box的重叠度，如下图所示：矩形框A、B的一个重合度IOU计算公式为：IOU=(A∩B)/(A∪B)就是矩形框A、B的重叠面积占A、B并集的面积比例:IOU=SI/(SA+SB-SI) 再引入非极大值抑制（NMS）概念：抑制不是极大值的元素，搜索局部的极大值。翻译一下就是：比如之前看的这张图片：很明显还是很多box是相互inner的，虽然没有被相互包含进去，我们可以先选择最大的box，看其他box与这个最大的box的IOU值，删除IOU值大于预先设定的阈值的box，重复这个过程就是一个方框删除的过程。真实的NMS还会涉及到canny detection等等的细节问题，这边只是让大家快速入门使用起来，如需详细了解，请自行百度。 若干个box内容对应：我们虽然识别出了方框内存在物体，但是我们仍需要将物体与标签对应起来，这边的方法就是很多了，RCNN里面的方法：SVM，还有现在非常热门的CNN都可以对识别出来的子图片进行识别分类：VOC物体检测任务是一个非常入门的分类问题。你可以通过任何一种你觉得可以的分类方法进行识别训练。 简单的流程化的识别拆分讲解这边就结束了，主要讲了candidates_boxs的产生，candidates_boxs通过基本属性的初筛，candidates_boxs根据IOU原则下的NMS进行复选，再将复选出来的box根据你已经训练好的分类模型确定到底是啥？可以用下面这个图概述一下： To-do:我们还有很多没讲完的，后面会持续更新：主要包括：1.如何配置一个快速训练的环境？2.如何实现（输入图片，产出结果）整套识别流程？3.如何自己训练一个图片分类器？4.如何做快速迁移一个自己需要的及时图片识别流？]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>图像识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态最优化经典面试题]]></title>
    <url>%2F2017%2F12%2F01%2F%E5%8A%A8%E6%80%81%E6%9C%80%E4%BC%98%E5%8C%96%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近看到了一条史前的算法面试题，觉得挺有意思的，虽然网上已经有了很多完善的答案，但是我还是想自己整理一遍，强化印象，同时也和大家分享一下这道12年的Google题目： 一幢 200 层的大楼，给你两个鸡蛋。如果在第 n 层扔下鸡蛋，鸡蛋不碎，那么从第 n-1 层扔鸡蛋，都不碎。这两只鸡蛋一模一样，不碎的话可以扔无数次。最高从哪层楼扔下时鸡蛋不会碎？ 先形象的理解一下这道题目，假设第一个蛋我们放在了i层，有两种case，碎或者不碎。先看简单的结果，case1:如果碎了，为了求出层数，那么我接下来的那颗蛋需要从第1层开始尝试i-1次，因为我们不允许冒第二次碎的风险了，这很好理解。case2:如果没碎，我们得知一条新的信息，那就是我们要求的目标层在i层之上，但是我们依旧不知道是哪一层，假设是m层（m&gt;i）,那么同样的，和第i层一样，面临2个case，碎或者不碎。 这时候，我们的前提是在最恶劣的情况下，保证我们的每次的风险都尽可能的小，至少要少于上一次的风险。 我们可以让新的m的高度为i+i-1,其中，i是第一次我们放的层数，i-1是我们选择的风险若于第一次风险的层数高度，类推下去：i+i-1+i-2+i-3+…+1=200，得到i=20，就是我们第一次应该放的位置，同理第二次如果没有碎应该放的就是39… 我个人对这道题目的理解中，其实就为了平分风险，让每次碎的高度都相等，也就是i-1 = m-i-1+1==&gt;m=2i-1 这边的python代码网上也有很多，这边我罗列一个我写的，可能和别人的不一样，实现效率也可能较慢，建议大家在网上搜完善版本的，仅供大家熟悉上述的描述：12345678910111213#n为层数，m为蛋数，f函数为求最优层数def f(n, m):#如果是0层的，返回最优层数为0 if n == 0: return 0#如果只有一个鸡蛋，必须要从最低层开始试，所以为当前最安全层n if m == 1: return n#这边我们来看，f(i - 1, m - 1)是如果i层碎了，我们需要计算i-1层下的情况，同时减少一颗蛋；#f(n - i, m)是i层没碎，那相当于安全层从0变成了n，要计算的就是相当于有 f(n, m)变成了 f(n - i, m)#最后在最大化风险下找出其中风险最小的层数即可 best_floor = min([max([f(i - 1, m - 1), f(n - i, m)]) for i in range(1, n + 1)] + 1) return best_floor 结果：12In [74]:print(f(100, 2))14 这边f(200,2)实在没跑出来，时间太久了，所以跑了100，2的结果，迭代次数超多，具体我没有算过，建议优化一下计算的代码再执行。 最后谢谢大家阅读。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户生命周期]]></title>
    <url>%2F2017%2F11%2F02%2F%E7%94%A8%E6%88%B7%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[摘要：设计一套完整的用户生命周期策略，极大程度上会提高用户活跃，降低用户流失，反应用户留存，为平台运营的不可或缺的一环 定义用户生命周期是指用户从加入平台开始，熟悉平台，参与平台，最终流失的整个过程。用户的生命周期相对于自身而言，是一种参与度的变化，参与度也可以称之为活跃度。 ###如何定义参与度？以电商平台而言，冒泡（打开app），浏览，点击，搜索，收藏，加购物车，下单，评论等都是用户参与平台的主要行为，综合考虑（但不限于此）这些因素， 活跃度：1θ = α1* pv + α2 * click + α3* search + α4 * clc + α5* cart + α6* order + α7* comment + bubble 其中，θ是活跃度，pv是用户浏览量，click是用户点击量，search是用户搜索量，clc是用户收藏量，cart是用户加购物车次，order为用户订单量，comment为用户评论量α1 为全部用户冒泡次数 与 全部用户浏览量之比；α2 为全部用户冒泡次数 与 全部用户点击量之比；… 这样保证了，所有平台参与行为与用户活跃情况成正相关，同时动态变化的降低了操作成本低的变量的权重，也满足奥卡姆剃刀原理后续再利用活跃度来直接衡量生命周期状态。 如何定义生命周期？ 以电商平台为例，考虑用户的行为，先来定义生命周期状态划分逻辑：1.计算用户连续N(N&gt;3)个周期内的参与度组成特征向量2.形成不同生命周期下的模式特征向量3.分类用户的特征向量如下： 生命周期状态 生命周期类型 描述 初生期 新增用户 处于新生用户没有用户记录 成长期 显性成长 最近三次生命周期状态都是成长期 成长期 隐性成长 最近三次生命周期状态不全是成长期 稳定期 低稳定 处于平稳期阶段，参与度低于1/4分位数 稳定期 中稳定 处于平稳期阶段，参与度介于1/4-3/4分位数 稳定期 高稳定 处于平稳期阶段，参与度高于3/4分位数 衰退期 轻微衰退 连续x个周期进入衰退期或流失期 衰退期 重度微衰退 连续x个周期进入衰退期或流失期 流失期 流失期 刚进入流失期 沉默期 沉默期 长期处于流失期 定义完整的用户生命周期状态后，再对用户的生命周期做session切分，根据聚类算法，将样本用户进行聚类，形成聚类中心，判断用户距离聚类中心距离，匹配用户所处的生命周期详细位置，反过来输出分位数，判断用户生命周期类型。 下面思考如何优化kmeans解决这个问题：考虑到业务开发的效率等原因，常规的聚类算法中，kmeans常常为优先考虑的算法，但实际运用过程中，需要根据不同的问题有差异化的优化。 1.考虑用户的特征偏移可能存在用户的活跃属性间断，比如用户外出出差一周，导致某个单位统计时间内平台参与度下降，用户的活跃属性下降，而实际用户为真实高活跃用户，只是出现异常间断点，影响用户活跃的最终判断，利用语义分析中的最佳路径计算方式解决这个问题。这三条线中，蓝色和青色线的分布走势类似，而红色线条的差异较大；计算蓝色–&gt;红色的欧式距离，蓝色–&gt;青色的欧式距离，发现蓝色–&gt;青色的欧式距离反而大于蓝色–&gt;红色的欧式距离，时间波动的情况下，欧式距离偏差较大。 所以，常规意义上的kmeans等基于欧式距离的算法这种情况下，使用较为局限。所以在整体思路不变的情况下，就距离计算，我们可以参考语音分析里面的DP（最佳路径规划算法），构造邻接矩阵，寻找最小最小路径和 实际在计算蓝色曲线到青色曲线的距离的时候，同时计算AB（蓝色曲线当前位置A点到前一个时间段青色曲线位置B）、AC（蓝色曲线当前位置A点到当前时间段青色曲线位置C），AD（蓝色曲线当前位置A点到后一个时间段青色曲线位置D）的距离，综合判断一个点最短路径；再根据曲线上的每一个点，会形成一个矩阵，判断矩阵的每个点的最佳路径即可 可以用如下的公式表述：其中，就是路径选择的过程 以上述的计算方式替换掉常规的kmeans中的欧式距离，提高了相似度的计算精度。 2.常规等距划分session不适用于生命周期 就用户平台活跃而言，不同用户可采用的用户时间窗口不同，新加入的用户可能可获取的时间长度较短；用户判断过程中的session与平台确定已知的生命周期session固定判断长度也是不相同的。同时，kmeans中的距离判断方法不能同时考虑到不同session下的距离计算问题 最简单常规的计算方式：是补全较短的session的时间窗口，在相同的时间窗口之下，再去计算较短的时间窗口与较长的时间窗口下的生命周期的均值，这样会人为干涉过多，数据质量较低，图b即为数据补齐 “STS距离”计算方式：在长时间窗口{r}集合中，寻找时间窗口长度子集，使得子集中的元长度与s曲线缺失的长度一致，在以s断点处开始向后寻找{r}子集合中的所有满足的元，再以均值时间序列替换原来的子集中的元作为r和s的拟合曲线，循环往复计算中心曲线2，如图c 有了补齐长度下的中心曲线，再便可采用kmeans的常规方式，计算各时间长度窗口下的生命周期的距离 3.附加限制属性再最后落地生命周期的长度的时候，考虑到商品平台的特殊属性，比如： 商品周期性（奶粉用户周期购买等） 用户偏好属性(酒店用户品质偏好等） 平台的时间依赖情况(夏季冬季季节偏好等） ……以上即为如何通过kmeans来确定一个用户所属的生命周期阶段 本文参考文献如下：1.不等长时间序列下的滑窗相似度2.kmeans距离计算方式剖析]]></content>
      <categories>
        <category>特征刻画</category>
      </categories>
      <tags>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交叉销售算法]]></title>
    <url>%2F2017%2F11%2F01%2F%E4%BA%A4%E5%8F%89%E9%94%80%E5%94%AE%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近做了一个交叉销售的项目，梳理了一些关键点，分享如下，希望对大家有所启发核心目标：在有限资源下，尽可能的提供高转化率的用户群，辅助业务增长初步效果：商家ROI值为50以上，用户日转化率提升10倍以上，用户日最低转化效果5pp以上以下为正文：数据准备：1.商品相关性存在商品A,B,C…，商品之间用户会存在行为信息的关联度，这边可以参考协调过滤算法中的Item-based，这边拓展为用户在不同商品之间的操作行为的差异性。 可以形成如下的特征矩阵： 这边相关的常见度量方式有以下几种：a.距离衡量包括浏览、点击、搜索等等各种行为的欧式、马氏、闵式、切比雪夫距离、汉明距离计算b.相似度衡量包括余弦相似度、杰卡德相似度衡量c.复杂衡量包括相关性衡量，熵值衡量，互信息量衡量，相关距离衡量2.商品行为信息探求商品及其对应行为信息的笛卡尔积的映射关系，得到一个商品+用户的行为魔方商品集合：{商品A、商品B、…}商品属性集合：{价格、是否打折、相比其他电商平台的比价、是否缺货…}用户行为集合：{浏览次数、浏览时长、末次浏览间隔、搜索次数、末次搜索间隔…}通过商品集合商品属性集合用户行为集合,形成高维的商品信息魔方，再通过探查算法，筛选优秀表现的特征，这里推荐的有pca，randomforest的importance，lasso变量压缩，相关性压缩，逐步回归压缩等方法，根据数据的属性特点可适当选取方法最后，我们会得到如下一个待选特征组： 3.商品购买周期针对每一件商品，都是有它自身的生命周期的，比如，在三个月内买过冰箱的用户，95%以上的用户是不会选择二次购买的；而在1个月的节点上，会有20%的用户会选择二次购买生活用纸。所以我们需要做的一件事情就是不断更新，平台上面每个类目下面的商品的自身生命周期。除此之外，考虑在过渡时间点，用户的需求变化情况，是否可以提前触发需求；这边利用，艾宾浩斯遗忘曲线和因子衰减规律拟合： 确定lamda和b，计算每个用户对应的每个类目，当前时间下的剩余价值：f(最高价值)lamdab 4.商品挖掘特征，用户挖掘特征业务运营过程中，通过数据常规可以得到1.基础结论，2.挖掘结论。基础结论就是统计结论，比如昨日订单量，昨日销售量 ，昨日用户量；挖掘结论就是深层结论，比如昨日活跃用户数，每日预估销售量，用户生命周期等存在如下的探索形式，这是一个漫长而又非常有价值的过程： 模型整合再确定以上四大类的数据特征之后，我们通过组合模型的方法，判断用户的交叉销售结果 1.cart regression确保非线性密度均匀数据拟合效果，针对存在非线性关系且数据可被网格切分的产业用户有高的预测能力2.ridge regression确保可线性拟合及特征繁多数据的效果，针对存在线性关系的产业用户有高的预测能力3.Svm-liner确保线性且存在不可忽视的异常点的数据拟合效果，针对存在异常用户较多的部分产业用户有高的预测能力4.xgboost确保数据复杂高维且无明显关系的数据拟合效果，针对存在维度高、数据杂乱、无模型规律的部分产业用户有高的预测能力以上的组合模型并非固定，也并非一定全部使用，在确定自身产业的特点后，择优选择，然后采取投票、加权、分组等组合方式产出结果即可。 附上推荐Rcode简述，cart regression：123456789101112fit &lt;- rpart(y~x, data=database, method=&quot;class&quot;,control=ct, parms = list(prior = c(0.7,0.3), split = &quot;information&quot;));# xval是n折交叉验证# minsplit是最小分支节点数，设置后达不到最小分支节点的话会继续分划下去# minbucket：叶子节点最小样本数# maxdepth：树的深度# cp全称为complexity parameter，指某个点的复杂度，对每一步拆分,模型的拟合优度必须提高的程度# kyphosis是rpart这个包自带的数据集# na.action：缺失数据的处理办法，默认为删除因变量缺失的观测而保留自变量缺失的观测。# method：树的末端数据类型选择相应的变量分割方法:# 连续性method=“anova”,离散型method=“class”,计数型method=“poisson”,生存分析型method=“exp”#parms用来设置三个参数:先验概率、损失矩阵、分类纯度的度量方法（gini和information）# cost我觉得是损失矩阵，在剪枝的时候，叶子节点的加权误差与父节点的误差进行比较，考虑损失矩阵的时候，从将“减少-误差”调整为“减少-损失” ridge regression：123456library（glmnet）glmmod&lt;-glmnet(x,y,family = &apos;guassian&apos;,alpha = 0)最小惩罚：glmmod.min&lt;-glmnet(x,y,family = &apos;gaussian&apos;,alpha = 0,lambda = glmmod.cv$lambda.min)1个标准差下的最小惩罚：glmmod.1se&lt;-glmnet(x,y,family = &apos;gaussian&apos;,alpha = 0,lambda = glmmod.cv$lambda.1se) Svm-liner ：123456789library(e1071)svm(x, y, scale = TRUE, type = NULL, kernel = &quot;&quot;,degree = 3, gamma = if (is.vector(x)) 1 else 1 / ncol(x),coef0 = 0, cost = 1, nu = 0.5, subset, na.action = na.omit)#type用于指定建立模型的类别:C-classification、nu-classification、one-classification、eps-regression和nu-regression#kernel是指在模型建立过程中使用的核函数#degree参数是指核函数多项式内积函数中的参数，其默认值为3#gamma参数给出了核函数中除线性内积函数以外的所有函数的参数，默认值为l#coef0参数是指核函数中多项式内积函数与sigmoid内积函数中的参数，默认值为0#参数cost就是软间隔模型中的离群点权重#参数nu是用于nu-regression、nu-classification和one-classification类型中的参数 xgboost:123456789library(xgboost)xgb &lt;- xgboost(data = data.matrix(x[,-1]), label = y, eta = 0.1,max_depth = 15, nround=25, subsample = 0.5,colsample_bytree = 0.5,seed = 1,eval_metric = &quot;merror&quot;,objective = &quot;multi:softprob&quot;,num_class = 12, nthread = 3)#eta：默认值设置为0.3。步长，控制速度及拟合程度#gamma:默认值设置为0。子树叶节点个数#max_depth:默认值设置为6。树的最大深度#min_child_weight:默认值设置为1。控制子树的权重和#max_delta_step：默认值设置为0。控制每棵树的权重#subsample： 默认值设置为1。抽样训练占比#lambda and alpha：正则化 最后通过组合算法的形式产出最终值： 典型算法代表：randomforest,adaboost,gbdt 之前写的没有用markdown，所以看起来很费力，还丢图，这次优化了一下视图，谢谢。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随机森林-枝剪问题]]></title>
    <url>%2F2017%2F10%2F02%2F%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97-%E6%9E%9D%E5%89%AA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[通常情况下， 随机森林不需要后剪枝。 剪枝的意义是：防止决策树生成过于庞大的子叶，避免实验预测结果过拟合，在实际生产中效果很差 剪枝通常有两种： PrePrune：预剪枝，及早的停止树增长，在每个父节点分支的时候计算是否达到了限制值 PostPrune：后剪枝，基于完全生长（过拟合）的树上进行剪枝，砍掉一些对衡量函数影响不大的枝叶 剪枝的依据： 常见的有错误率校验（判断枝剪是降低了模型预测的正确率），统计学检验，熵值，代价复杂度等等 总结看来，枝剪的目的是担心全量数据在某棵树上的拟合过程中，过度判断了每个点及其对应类别的关系，有如以下这张图（以rule1&amp;rule2代替了rule3）： 随机森林： 定义：它是一种模型组合（常见的Boosting，Bagging等，衍生的有gbdt），这些算法最终的结果是生成N(可能会有几百棵以上）棵树，组合判断最终结果。 如何组合判断？ 1.通常我们会规定随机森林里面的每棵树的选参个数，常见的有log，sqrt等等，这样的选取是随机选则的，这样有一个好处，让每一棵树上都有了尽可能多的变量组合，降低过拟合程度 2.树的个数及树的节点的变量个数，通常的来说，最快捷的方式是先确定节点的变量个数为sqrt（变量的个数），然后在根据oob的准确率反过来看多个棵树时最优，确定了树的个数的时候再反过来确定mtry的个数，虽然有局限，但是也并不存在盲目性 3.我个人理解，随机森林中的每一棵树我们需要它在某一片的数据中有非常好的拟合性，它并不是一个全数据拟合，只需要在它负责那块上有最佳的拟合效果。每次遇到这些数据(特征)的时候，我们在最后汇总N棵树的结果的时候，给这些数据对应的那块模型以最高权重即可 最后总结一下，就是随机森林里面的每棵树的产生通过选特征参数选数据结构，都已经考虑了避免共线性避免过拟合，剩下的每棵树需要做的就是尽可能的在自己所对应的数据(特征)集情况下尽可能的做到最好的预测结果；如同，公司已经拆分好部门，你不需要考虑这样拆分是不是公司运营最好的一个组合方式，你需要做的就是当公司需要你的时候，尽可能的做好自己的事情，就酱。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树枝剪问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试之常见决策树异同]]></title>
    <url>%2F2017%2F09%2F01%2F%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%86%B3%E7%AD%96%E6%A0%91%E5%BC%82%E5%90%8C%2F</url>
    <content type="text"><![CDATA[历史回顾：1984年提出的cart，1986年提出的ID3，1993年提出的c4.5 理论上总的来说，C4.5是基于ID3优化后产出的算法，主要优化了关于节点分支的计算方式，优化后解决了ID3分支过程中总喜欢偏向取值较多的属性ID3是信息增益分支： 而CART一般是GINI系数分支： C4.5一般是信息增益率分支： 工程上总的来说：CART和C4.5之间主要差异在于分类结果上，CART可以回归分析也可以分类，C4.5只能做分类；C4.5子节点是可以多分的，而CART是无数个二叉子节点；以此拓展出以CART为基础的“树群”random forest ， 以回归树为基础的“树群”GBDT 样本数据的差异：ID3只能对分类变量进行处理，C4.5和CART可以处理连续和分类两种自变量ID3对缺失值敏感，而C4.5和CART对缺失值可以进行多种方式的处理只从样本量考虑，小样本建议考虑c4.5、大样本建议考虑cart。c4.5处理过程中需对数据集进行多次排序，处理成本耗时较高，而cart本身是一种大样本的统计方法，小样本处理下泛化误差较大 目标因变量的差异：ID3和C4.5只能做分类，CART（分类回归树）不仅可以做分类（0/1）还可以做回归（0-1）ID3和C4.5节点上可以产出多叉（低、中、高），而CART节点上永远是二叉（低、非低） 样本特征上的差异：特征变量的使用中，多分的分类变量ID3和C4.5层级之间只单次使用，CART可多次重复使用 决策树产生过程中的优化差异：C4.5是通过枝剪来修正树的准确性，而CART是直接利用全部数据发现所有树的结构进行对比]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVD及扩展的矩阵分解方法]]></title>
    <url>%2F2017%2F08%2F27%2FSVD%E5%8F%8A%E6%89%A9%E5%B1%95%E7%9A%84%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[svd是现在比较常见的算法之一，也是数据挖掘工程师、算法工程师必备的技能之一，这边就来看一下svd的思想，svd的重写，svd的应用。这边着重的看一下推荐算法中的使用，其实在图片压缩，特征压缩的工程中，svd也有着非常不凡的作用。 svd的思想矩阵因子模型（潜在因子模型）假设，我们现在有一个用户u对商品i的程度矩阵，浏览是1，搜索是2，加车是3，下单是4，付款是5:实际情况下，用户不可能什么商品都买，所以，该矩阵必然是一个稀疏矩阵，任意一个矩阵必然可以被分解成2个矩阵的乘积： k就是潜在因子的个数，举个例子，你去买衣服，你可能买了裙子，露背装，我去买衣服，我买了牛仔裤，潮牌T恤，影响我们购买商品的差异的原因可能有很多点，但是必然有些原因占比重要些，比如性别，收入，有一些可能不那么重要比如天气，心情。而拆分成的Pu矩阵表示了这些潜在因子对我或者你的影响程度，Qi矩阵表示了各种商品对这些潜在因子的影响程度。当我们尽可能的通过拆分矩阵的形式，目标使得拆分后的两个矩阵的乘积最匹配最上方的用户商品矩阵的已知的数据值，从而可以通过这两个矩阵的乘积填补掉空缺的值。 Baseline Predictors这个是08年的，Koren在NetFlix大赛的一个思路，后续也延伸了svd多种变种，比如Asvd，有偏的Rsvd，对偶算法下的Svd++，这些算法的核心在于解决了Svd上面我们提到的那个矩阵庞大稀疏的问题，后续我们再看。 Baseline Predictors使用向量bi表示电影i的评分相对于平均评分的偏差，向量bu表示用户u做出的评分相对于平均评分的偏差，将平均评分记做μ。 新的得分计算方式如下：Rui＝μ+bi+bu准备引入了商品及用户的实际分布的情况，有效的降低在测试数据上面的效果。 svd数学原理首先，线代或者高等代数里面告诉我们：一个向量可以通过左乘一个矩阵的方式来进行拉伸，旋转，或者同时拉伸旋转。所以，无论什么矩阵M，我们都可以找到一组正交基v1、v2，使得Mv1、Mv2也是正交的，不妨记其方向为为μ1、μ2。Mv1=δ1u1；Mv2=δ2u2；存在向量x，在v1、v2空间里的表示为：x=（x·v1）v1+（x·v2）v2，所以有，Mx有：Mx=（x·v1）Mv1+（x·v2）Mv2Mx=（x·v1）δ1u1+（x·v2）δ2u2Mx=δ1u1(v1.T)x+δ2u2(v2.T)xM=δ1u1(v1.T)+δ2u2(v2.T)所以就有了那个非常有名的公式：M=UΣV.TU是有一组正交基构成的，V也是有一组正交基构成的，Σ是由δ1、δ2构成的，几何意义上来说，M的作用就是把一个向量由V的正交空间变换到U的正交空间上，而通过Σ的大小来控制缩放的力度。 我们还需要知道一些简单的推论， 通过MM.T，我们知道，δ的平方是MM.T的特征值 奇异值δ的数量决定了M=UΣV.T的复杂度，而奇异值的大小变化差异程度很大，通常前几个奇异值的平方就能占到全部奇异值的平方的90%，所以，我们可以通过控制奇异值的数量来优化原始矩阵乘积，去除掉一下噪声数据 svd重写基础的svd首先，我们在刚开始就知道，评分矩阵R可以用两个矩阵P和Q的乘积来表示： 其中，U表示用户数，I表示商品数，K=就是潜在因子个数。首先通过那些已知的数据比如下方红色区域内的数据去训练这两个乘积矩阵： 那么未知的评分也就可以用P的某一行乘上Q的某一列得到了： 这是预测用户u对商品i的评分，它等于P矩阵的第u行乘上Q矩阵的第i列。这个是最基本的SVD算法，下面我们们来看如何确定Pu、Qi： 假设已知的评分为：rui则真实值与预测值的误差为： 继而可以计算出总的误差平方和： 只要通过训练把SSE降到最小那么P、Q就能最好地拟合R了。常规的来讲，梯度下降是非常好的求解方式，常见的包括随机梯度下降，批量梯度下降。随机梯度下降一定程度会避免局部最小但是计算量大，批量梯度计算量小但是会存在鞍点计算误区的问题。 先求得SSE在Puk变量（也就是P矩阵的第u行第k列的值）处的梯度： 现在得到了目标函数在Puk处的梯度了，那么按照梯度下降法，将Puk往负梯度方向变化。令更新的步长（也就是学习速率）为 则Puk的更新式为 同样的方式可得到Qik的更新式为 Rsvd很明显，上述这样去求的矩阵QP必然会存在过度拟合的问题，导致对实际数据预测的时候，效果远差于训练数据，仿造elastic net的思维： 对所有的变量就加入正则惩罚项，重新计算上面的梯度如下： 这就是正则svd，也叫做Rsvd，也是我们用的比较多的svd的方法。 偏移Rsvd在最开始讲了，Koren在NetFlix大赛里面除了考虑了对原始数据的拟合情况，也考虑了用户的评分、商品的平均得分相对于整体数据的偏移情况，有了新的得分公式：Rui＝μ+bi+bu，影响的只有eui，后面的Pu、qi的正则不受影响，但是新增了bi、bu的正则项，重新计算每一项的偏导数：bu、bi的更新式子：其余的都不发生改变，这就叫做有偏移下的Rsvd 无论是Rsvd还是有偏移的Rsvd，当原始的用户对商品的评分矩阵过大，比如有3亿用户，3亿商品，形成9亿商品集合的时候，这就是一个比较不可能完成的存储任务，而且里面绝大多数都是0的稀疏矩阵。 Asvd及Svd++这边，我们引入两个集合：R(u)表示用户u评过分的商品集合，N(u)表示用户u浏览过但没有评过分的商品集合，Xj和Yj是商品的属性。Asvd的rui的评分方式： Svd++的rui的评分方式： 无论是Asvd还是Svd++，都干掉了原来庞大的P矩阵，取而代之的是两个用户浏览评分矩阵大大缩小了存储的空间，但是随着而来的是一大把更多的未知参数及迭代的复杂程度，所有在训练时间上而言，会大大的增加。 我这边只重写了一下Rsvd的python版本，网上挺多版本的迭代条件有一定问题，稍作处理了一下，并写成了函数，大家可以参考一下：1234567891011121314151617181920212223242526272829303132333435def svd(mat, feature, steps=2000, gama=0.02, lamda=0.3):#feature是潜在因子的数量，mat为评分矩阵 slowRate = 0.99 preRmse = 0.0000000000001 nowRmse = 0.0 user_feature = matrix(numpy.random.rand(mat.shape[0], feature)) item_feature = matrix(numpy.random.rand(mat.shape[1], feature)) for step in range(steps): rmse = 0.0 n = 0 for u in range(mat.shape[0]): for i in range(mat.shape[1]): if not numpy.isnan(mat[u,i]):#这边是判断是否为空，也可以改为是否为0:if mat[u,i]&gt;0: pui = float(numpy.dot(user_feature[u,:], item_feature[i,:].T)) eui = mat[u,i] - pui rmse += pow(eui, 2) n += 1 for k in range(feature):#Rsvd的更新迭代公式 user_feature[u,k] += gama*(eui*item_feature[i,k] - lamda*user_feature[u,k]) item_feature[i,k] += gama*(eui*user_feature[u,k] - lamda*item_feature[i,k])#n次迭代平均误差程度 nowRmse = sqrt(rmse * 1.0 / n) print 'step: %d Rmse: %s' % ((step+1), nowRmse) if (nowRmse &gt; preRmse): pass else: break#降低迭代的步长 gama *= slowRate step += 1 return user_feature, item_feature 直接调用的结果如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768step: 1956 Rmse: 0.782449675844step: 1957 Rmse: 0.782449675843step: 1958 Rmse: 0.782449675843step: 1959 Rmse: 0.782449675843step: 1960 Rmse: 0.782449675842step: 1961 Rmse: 0.782449675842step: 1962 Rmse: 0.782449675842step: 1963 Rmse: 0.782449675841step: 1964 Rmse: 0.782449675841step: 1965 Rmse: 0.78244967584step: 1966 Rmse: 0.78244967584step: 1967 Rmse: 0.78244967584step: 1968 Rmse: 0.782449675839step: 1969 Rmse: 0.782449675839step: 1970 Rmse: 0.782449675839step: 1971 Rmse: 0.782449675838step: 1972 Rmse: 0.782449675838step: 1973 Rmse: 0.782449675838step: 1974 Rmse: 0.782449675837step: 1975 Rmse: 0.782449675837step: 1976 Rmse: 0.782449675837step: 1977 Rmse: 0.782449675836step: 1978 Rmse: 0.782449675836step: 1979 Rmse: 0.782449675836step: 1980 Rmse: 0.782449675835step: 1981 Rmse: 0.782449675835step: 1982 Rmse: 0.782449675835step: 1983 Rmse: 0.782449675835step: 1984 Rmse: 0.782449675834step: 1985 Rmse: 0.782449675834step: 1986 Rmse: 0.782449675834step: 1987 Rmse: 0.782449675833step: 1988 Rmse: 0.782449675833step: 1989 Rmse: 0.782449675833step: 1990 Rmse: 0.782449675833step: 1991 Rmse: 0.782449675832step: 1992 Rmse: 0.782449675832step: 1993 Rmse: 0.782449675832step: 1994 Rmse: 0.782449675831step: 1995 Rmse: 0.782449675831step: 1996 Rmse: 0.782449675831step: 1997 Rmse: 0.782449675831step: 1998 Rmse: 0.78244967583step: 1999 Rmse: 0.78244967583step: 2000 Rmse: 0.78244967583Out[15]:(matrix([[-0.72426432, 0.40007415, 1.16887518], [-0.73130968, 0.40240702, 1.14708432], [ 0.34759923, 1.35065656, -0.29573789], [ 1.17462156, -0.04964694, 0.73881335], [ 2.04035441, -0.06798676, 1.28078727], [ 0.30446306, 1.71648612, -0.4109819 ], [ 1.71963828, -0.00833196, 1.25983483], [-0.86341514, 0.47750529, 1.36135332], [-0.48881234, 0.57942923, 0.77110915], [ 0.29282908, 1.5164249 , -0.39811768], [ 0.35369432, -0.00964055, 0.22328158]]), matrix([[ 1.3381854 , -0.05425608, 0.87036818], [ 1.07547853, -0.04515239, 0.69607952], [ 1.39038494, -0.05799558, 0.90186332], [-0.60218508, 0.36233309, 0.92136536], [ 0.39117217, 1.9272062 , -0.50710187], [-0.93202395, 0.52982297, 1.43309143], [-0.19393338, 0.40429152, 0.29994372], [ 1.40108031, 0.06915628, 0.87647945], [ 1.39446638, -0.05197355, 0.920216 ], [ 0.31981929, 1.84114505, -0.40108819], [-0.82317832, 0.52798144, 1.51619052]])) svd在推荐算法中的使用数据集中行代表用户user，列代表物品item，其中的值代表用户对物品的打分。基于SVD的优势在于：用户的评分数据是稀疏矩阵，可以用SVD将原始数据映射到低维空间中，然后计算物品item之间的相似度，更加高效快速。 整体思路：用户未知得分的商品评分计算方式：1.用户的评分矩阵==》用户已经评分过得商品的得分2.商品的用户评分==》用户已经评分过得商品和其他每个商品的相关性3.“用户已经评分过得商品的得分”*“用户已经评分过得商品和某个未知评分商品的相关系数”=某个未知商品该用户的评分 计算上面三个步骤，我们需要：1.考虑采取上面相关性的计算方式2.考虑潜在因子的个数 依旧python代码，我会在代码中注释讲解：1.首先相关性1234567891011121314151617181920212223242526272829# 欧拉距离相似度，评分可用，程度不建议def oulasim(A, B): distince = la.norm(A - B) # 第二范式：平方的和后求根号 similarity = 1 / (1 + distince) return similarity# 余弦相似度，评分、1/0、程度都可以用def cossim(A, B): ABDOT = float(dot(A, B)) ABlen = la.norm(A) * la.norm(B) if ABlen == 0: similarity = '异常' else: similarity = ABDOT / float(ABlen) return similarity# 皮尔逊相关系数def pearsonsim(A, B): A = A - mean(A) B = B - mean(B) ABDOT = float(dot(A, B)) ABlen = la.norm(A) * la.norm(B) if ABlen == 0: similarity = '异常' else: similarity = ABDOT / float(ABlen) return similarity 2.指定用户及对应商品的相似度123456789101112131415161718192021222324252627282930# svddef recommender(datamat,user,index,function): n = shape(datamat)[1] # 商品数目 U, sigma, VT = la.svd(datamat) # 规约最小维数 sigma2 = sigma ** 2 k = len(sigma2) n_sum2 = sum(sigma2) nsum = 0 max_sigma_index = 0#奇异值的平方占比总数的90%，确定潜在因子数 for i in sigma: nsum = nsum + i ** 2 max_sigma_index = max_sigma_index + 1 if nsum &gt;= n_sum2 * 0.9: break # item new matrix item = datamat.T * U[:, 0:max_sigma_index] * matrix(diag(sigma[0:max_sigma_index])).I key=item[index,:] total_similarity=0 rank_similarity=0 for i in range(k):#如果用户没有评分或者与用户选择想知道的商品一致则跳过，不跳过计算出来前者是得分0，后者直接是用户已评分的结果，没有意义 if datamat[user,i]==0 or i==index:continue similarity=function(key,item[i,:].T) total_similarity=total_similarity+similarity#用户的评分*相关系数 rank_similarity=rank_similarity+similarity*datamat[user,i]*similarity score = rank_similarity/total_similarity return score 比如：用户1在商品1的得分为3.99分12In [18]: recommender(data,1,1,cossim)Out[18]: 3.98921610058786 3.指定商品，与所有其它商品的相似度123456789101112def recommender(datamat, item_set, method): col = shape(datamat)[1] # 物品数量 item = datamat[:, item_set] similarity_matrix = zeros([col, 1]) for i in range(col): index = nonzero(logical_and(item &gt; 0, datamat[:, i] &gt; 0))[0] if sum(index) &gt; 0: similarity = method(datamat[index, item_set].T, datamat[index, i]) else: similarity = '-1' similarity_matrix[i] = similarity return similarity_matrix 比如：商品0，对其它所有商品的相似度：12345678910111213In [24]: recommender(data,0,cossim)Out[24]:array([[ 1. ], [ 0.99439606], [ 0.99278096], [-1. ], [-1. ], [-1. ], [-1. ], [ 0.98183139], [ 0.97448865], [-1. ], [ 1. ]]) 4.直接算出所有商品间的相似度：1234567def similarity(datamat, method): item_sum = shape(datamat)[1] similarity = pd.DataFrame([]) for i in range(item_sum): res = recommender(datamat, i, method) similarity = pd.concat([similarity, pd.DataFrame(res)], axis=1) return similarity 比如商品的相似矩阵：123456789101112131415161718192021222324252627In [25]: similarity(data,cossim)Out[25]: 0 0 0 0 0 0 0 \0 1.000000 0.994396 0.992781 -1.000000 -1.000000 -1.000000 -1.0000001 0.994396 1.000000 0.999484 -1.000000 -1.000000 -1.000000 -1.0000002 0.992781 0.999484 1.000000 -1.000000 -1.000000 -1.000000 -1.0000003 -1.000000 -1.000000 -1.000000 1.000000 -1.000000 0.990375 1.0000004 -1.000000 -1.000000 -1.000000 -1.000000 1.000000 -1.000000 1.0000005 -1.000000 -1.000000 -1.000000 0.990375 -1.000000 1.000000 1.0000006 -1.000000 -1.000000 -1.000000 1.000000 1.000000 1.000000 1.0000007 0.981831 0.956858 0.955304 -1.000000 1.000000 -1.000000 -1.0000008 0.974489 0.956858 0.955304 -1.000000 -1.000000 -1.000000 -1.0000009 -1.000000 -1.000000 -1.000000 1.000000 0.994536 1.000000 0.38461510 1.000000 1.000000 1.000000 1.000000 -1.000000 0.981307 1.000000 0 0 0 00 0.981831 0.974489 -1.000000 1.0000001 0.956858 0.956858 -1.000000 1.0000002 0.955304 0.955304 -1.000000 1.0000003 -1.000000 -1.000000 1.000000 1.0000004 1.000000 -1.000000 0.994536 -1.0000005 -1.000000 -1.000000 1.000000 0.9813076 -1.000000 -1.000000 0.384615 1.0000007 1.000000 0.991500 1.000000 1.0000008 0.991500 1.000000 -1.000000 1.0000009 1.000000 -1.000000 1.000000 1.00000010 1.000000 1.000000 1.000000 1.000000 5.指定用户下的top5商品推荐123456789def fianl_recommender(datamat,user,function): unratedItems=nonzero(datamat[user,:].A==0)[1] if len(unratedItems)==0: print &apos;ok&apos; score=[] for i in unratedItems: i_score=recommender(datamat,user,i,function) score.append((i,i_score)) score=sorted(score,key=lambda x:x[1],reverse=True) return score[:5] 比如指定用户1，最适合推荐的商品如下：1234567In [31]: fianl_recommender(data,1,pearsonsim)Out[31]:[(7, 3.3356853252871588), (8, 3.3349455396520296), (0, 3.33492840157654), (2, 3.334920725716121), (1, 3.334919898261294)] 最后，谢谢大家阅读。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>矩阵分解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习下的电商商品推荐]]></title>
    <url>%2F2017%2F08%2F19%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8B%E7%9A%84%E7%94%B5%E5%95%86%E5%95%86%E5%93%81%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[常见算法套路电商行业中，对于用户的商品推荐一直是一个非常热门而且重要的话题，有很多比较成熟的方法，但是也各有利弊，大致如下： 基于商品内容：比如食物A和食物B，对于它们价格、味道、保质期、品牌等维度，可以计算它们的相似程度，可以想象，我买了包子，很有可能顺路带一盒水饺回家。优点：冷启动，其实只要你有商品的数据，在业务初期用户数据不多的情况下，也可以做推荐缺点：预处理复杂，任何一件商品，维度可以说至少可以上百，如何选取合适的维度进行计算，设计到工程经验，这些也是花钱买不到的典型：亚马逊早期的推荐系统 基于关联规则：最常见的就是通过用户购买的习惯，经典的就是“啤酒尿布”的案例，但是实际运营中这种方法运用的也是最少的，首先要做关联规则，数据量一定要充足，否则置信度太低，当数据量上升了，我们有更多优秀的方法，可以说没有什么亮点，业内的算法有apriori、ftgrowth之类的优点：简单易操作，上手速度快，部署起来也非常方便缺点：需要有较多的数据，精度效果一般典型：早期运营商的套餐推荐 基于物品的协同推荐：假设物品A被小张、小明、小董买过，物品B被小红、小丽、小晨买过，物品C被小张、小明、小李买过；直观的看来，物品A和物品C的购买人群相似度更高（相对于物品B），现在我们可以对小董推荐物品C，小李推荐物品A，这个推荐算法比较成熟，运用的公司也比较多优点：相对精准，结果可解释性强，副产物可以得出商品热门排序缺点：计算复杂，数据存储瓶颈，冷门物品推荐效果差典型：早期一号店商品推荐 基于用户的协同推荐：假设用户A买过可乐、雪碧、火锅底料，用户B买过卫生纸、衣服、鞋，用户C买过火锅、果汁、七喜；直观上来看，用户A和用户C相似度更高（相对于用户B），现在我们可以对用户A推荐用户C买过的其他东西，对用户C推荐用户A买过买过的其他东西，优缺点与基于物品的协同推荐类似，不重复了。 基于模型的推荐：svd++、特征值分解、概率图、聚分类等等。比如潜在因子分解模型，将用户的购买行为的矩阵拆分成两组权重矩阵的乘积，一组矩阵代表用户的行为特征，一组矩阵代表商品的重要性，在用户推荐过程中，计算该用户在历史训练矩阵下的各商品的可能性进行推荐。优点：精准，对于冷门的商品也有很不错的推荐效果缺点：计算量非常大，矩阵拆分的效能及能力瓶颈一直是受约束的典型：惠普的电脑推荐 基于时序的推荐：这个比较特别，在电商运用的少，在Twitter，Facebook，豆瓣运用的比较多，就是只有赞同和反对的情况下，怎么进行评论排序，详细的可以参见我之前写的一篇文章：应用：推荐系统-威尔逊区间法 基于深度学习的推荐：现在比较火的CNN(卷积神经网络)、RNN(循环神经网络)、DNN(深度神经网络)都有运用在推荐上面的例子，但是都还是试验阶段，但是有个基于word2vec的方法已经相对比较成熟，也是我们今天介绍的重点。优点：推荐效果非常精准，所需要的基础存储资源较少缺点：工程运用不成熟，模型训练调参技巧难典型：当前电商的会员商品推荐 item2vec的工程引入现在某电商的商品有约3亿个，商品的类目有10000多组，大的品类也有近40个，如果通过传统的协同推荐，实时计算的话，服务器成本，计算能力都是非常大的局限，之前已经有过几篇应用介绍：基于推荐的交叉销售、基于用户行为的推荐预估。会员研发部门因为不是主要推荐的应用部门，所以在选择上，我们期望的是更加高效高速且相对准确的简约版模型方式，所以我们这边基于了word2vec的原始算法，仿造了itemNvec的方式。 首先，让我们对itemNvec进行理论拆分： part one：n-gram目标商品的前后商品对目标商品的影响程度这是两个用户userA，userB在易购上面的消费time line，灰色方框内为我们观察对象，试问一下，如果换一下灰色方框内的userA、userB的购买物品，直观的可能性有多大？ 直观的体验告诉我们，这是不可能出现，或者绝对不是常出现的，所以，我们就有一个初始的假设，对于某些用户在特定的类目下，用户的消费行为是连续影响的，换句话说，就是我买了什么东西是依赖我之前买过什么东西。如何通过算法语言解释上面说的这件事呢？大家回想一下，naive bayes做垃圾邮件分类的时候是怎么做的？假设“我公司可以提供发票、军火出售、航母维修”这句话是不是垃圾邮件？ P1(“垃圾邮件”|“我公司可以提供发票、军火出售、航母维修”)=p(“垃圾邮件”)p(“我公司可以提供发票、军火出售、航母维修”/“垃圾邮件”)/p(“我公司可以提供发票、军火出售、航母维修”)=p(“垃圾邮件”)p(“发票”，“军火”，“航母”/“垃圾邮件”)/p(“发票”，“军火”，“航母”) 同理P2(“正常邮件”|“我公司可以提供发票、军火出售、航母维修”)=p(“正常邮件”)p(“发票”，“军火”，“航母”/“正常邮件”)/p(“发票”，“军火”，“航母”) 我们只需要比较p1和p2的大小即可，在条件独立的情况下可以直接写成：P1(“垃圾邮件”|“我公司可以提供发票、军火出售、航母维修”)=p(“垃圾邮件”)p(“发票”/“垃圾邮件”)p(“军火”/“垃圾邮件”)p(“航母”/“垃圾邮件”)P2(“正常邮件”|“我公司可以提供发票、军火出售、航母维修”)=p(“正常邮件”)p(“发票”/“正常邮件”)p(“军火”/“正常邮件”)p(“航母”/“正常邮件”) 但是，我们看到，无论“我公司可以提供发票、军火出售、航母维修”词语的顺序怎么变化，不影响它最后的结果判定，但是我们这边的需求里面前面买的东西对后项的影响会更大。冰箱=&gt;洗衣机=&gt;衣柜=&gt;电视=&gt;汽水，这样的下单流程合理冰箱=&gt;洗衣机=&gt;汽水=&gt;电视=&gt;衣柜，这样的下单流程相对来讲可能性会更低但是对于naive bayes，它们是一致的。所以，我们这边考虑顺序，还是上面那个垃圾邮件的问题。P1(“垃圾邮件”|“我公司可以提供发票、军火出售、航母维修”)=p(“垃圾邮件”)p(“发票”)p(“军火”/“发票”)p(“军火”/“航母”)P1(“正常邮件”|“我公司可以提供发票、军火出售、航母维修”)=p(“正常邮件”)p(“发票”)p(“军火”/“发票”)p(“军火”/“航母”)这边我们每个词只依赖前一个词，理论上讲依赖1-3个词通常都是可接受的。以上的考虑顺序的bayes就是基于著名的马尔科夫假设（Markov Assumption）：下一个词的出现仅依赖于它前面的一个或几个词下的联合概率问题，相关详细的理论数学公式就不给出了，这边这涉及一个思想。 part two：Huffman Coding更大的数据存储形式我们常用的user到item的映射是通过one hot encoding的形式去实现的，这有一个非常大的弊端就是数据存储系数且维度灾难可能性极大。回到最初的那组数据：现在商品有约4亿个，商品的类目有10000多组，大的品类也有近40个，同时现在会员数目达到5亿，要是需要建造一个用户商品对应的购买关系矩阵做基于用户的协同推荐的话，我们需要做一个4亿X6亿的1/0矩阵，这个是几乎不可能的，Huffman采取了一个近似二叉树的形式进行存储：我们以商品购买量为例，讲解一下如何以二叉树的形式替换one hot encoding存储方式：假设，促销期间，经过统计，有冰箱=&gt;洗衣机=&gt;烘干机=&gt;电视=&gt;衣柜=&gt;钻石的用户下单链条（及购买物品顺序如上），其中冰箱总售出15万台，洗衣机总售出8万台，烘干机总售出6万台，电视总售出5万台，衣柜总售出3万台，钻石总售出1万颗 12341.给定&#123;15,8,6,5,3,1&#125;为二叉树的节点，每个树仅有一个节点，那就存在6颗单独的树2.选择节点权重值最小的两颗树进行合并也就是&#123;3&#125;、&#123;1&#125;，合并后计算新权重3+1=43.将&#123;3&#125;，&#123;1&#125;树从节点列表删除，将3+1=4的新组合树放回原节点列表4.重新进行2-3，直到只剩一棵树为止 针对每层每次分支过程，我们可以将所有权重大的节点看做是1，权重小的节点看做是0，相反亦可。现在，我们比如需要知道钻石的code，就是1000，也就是灰色方框的位置，洗衣机的code就是111；这样的存储利用了0/1的存储方式，也同时考虑了组合位置的排列长度，节省了数据的存储空间。 part three：node probility最大化当前数据出现可能的概率密度函数对于钻石的位置而言，它的Huffman code是1000，那就意味着在每一次二叉选择的时候，它需要一次被分到1，三次被分到0，而且每次分的过程中，只有1/0可以选择，这是不是和logistic regression里面的0/1分类相似，所以这边我们也直接使用了lr里面的交叉熵来作为loss function。 其实对于很多机器学习的算法而言，都是按照先假定一个模型，再构造一个损失函数，通过数据来训练损失函数求argmin(损失函数)的参数，放回到原模型。 让我们详细的看这个钻石这个例子： p(1|No.1层未知参数)=sigmoid(No.1层未知参数) p(0|No.2层未知参数)=sigmoid(No.2层未知参数)同理，第三第四层：p(0|No.3层未知参数)=sigmoid(No.3层未知参数)p(0|No.4层未知参数)=sigmoid(No.4层未知参数)然后求p(1|No.1层未知参数)xp(0|No.2层未知参数)xp(0|No.3层未知参数)xp(0|No.4层未知参数)最大下对应的每层的未知参数即可，求解方式与logistic求解方式近似，未知参数分布偏导，后续采用梯度下降的方式（极大、批量、牛顿按需使用） part four：approximate nerual network商品的相似度刚才在part three里面有个p(1|No.1层未知参数)这个逻辑，这个NO.1层未知参数里面有一个就是商品向量。举个例子：存在1000万个用户有过：“啤酒=&gt;西瓜=&gt;剃须刀=&gt;百事可乐”的商品购买顺序10万个用户有过：“啤酒=&gt;苹果=&gt;剃须刀=&gt;百事可乐”的商品购买顺序，如果按照传统的概率模型比如navie bayes 或者n-gram来看，P（啤酒=&gt;西瓜=&gt;剃须刀=&gt;百事可乐）&gt;&gt;p（啤酒=&gt;苹果=&gt;剃须刀=&gt;百事可乐），但是实际上这两者的人群应该是同一波人，他们的属性特征一定会是一样的才对。 我们这边通过了随机初始化每个商品的特征向量，然后通过part three的概率模型去训练，最后确定了词向量的大小。除此之外，还可以通过神经网络算法去做这样的事情。 Bengio 等人在 2001 年发表在 NIPS 上的文章《A Neural Probabilistic Language Model》介绍了详细的方法。我们这边需要知道的就是，对于最小维度商品，我们以商品向量（0.8213，0.8232，0.6613，0.1234，…）的形式替代了0-1点（0，0，0，0，0，1，0，0，0，0…），单个的商品向量无意义，但是成对的商品向量我们就可以比较他们间的余弦相似度，就可以比较类目的相似度，甚至品类的相似度。 python代码实现1.数据读取12345678910# -*- coding:utf-8 -*-import pandas as pdimport numpy as npimport matplotlib as mtfrom gensim.models import word2vecfrom sklearn.model_selection import train_test_splitorder_data = pd.read_table(&apos;C:/Users/17031877/Desktop/SuNing/cross_sell_data_tmp1.txt&apos;)dealed_data = order_data.drop(&apos;member_id&apos;, axis=1)dealed_data = pd.DataFrame(dealed_data).fillna(value=&apos;&apos;) 2.简单的数据合并整理12345678910# 数据合并dealed_data = dealed_data[&apos;top10&apos;] + [&quot; &quot;] + dealed_data[&apos;top9&apos;] + [&quot; &quot;] + dealed_data[&apos;top8&apos;] + [&quot; &quot;] + \ dealed_data[&apos;top7&apos;] + [&quot; &quot;] + dealed_data[&apos;top6&apos;] + [&quot; &quot;] + dealed_data[&apos;top5&apos;] + [&quot; &quot;] + dealed_data[ &apos;top4&apos;] + [&quot; &quot;] + dealed_data[&apos;top3&apos;] + [&quot; &quot;] + dealed_data[&apos;top2&apos;] + [&quot; &quot;] + dealed_data[&apos;top1&apos;]# 数据分列dealed_data = [s.encode(&apos;utf-8&apos;).split() for s in dealed_data]# 数据拆分train_data, test_data = train_test_split(dealed_data, test_size=0.3, random_state=42) 3.模型训练12345# 原始数据训练# sg=1,skipgram;sg=0,SBOW# hs=1:hierarchical softmax,huffmantree# nagative = 0 非负采样model = word2vec.Word2Vec(train_data, sg=1, min_count=10, window=2, hs=1, negative=0) 接下来就是用model来训练得到我们的推荐商品，这边有三个思路，可以根据具体的业务需求和实际数据量来选择：3.1 相似商品映射表12345678910111213# 最后一次浏览商品最相似的商品组top3x = 1000result = []result = pd.DataFrame(result)for i in range(x): test_data_split = [s.encode(&apos;utf-8&apos;).split() for s in test_data[i]] k = len(test_data_split) last_one = test_data_split[k - 1] last_one_recommended = model.most_similar(last_one, topn=3) tmp = last_one_recommended[0] + last_one_recommended[1] + last_one_recommended[2] last_one_recommended = pd.concat([pd.DataFrame(last_one), pd.DataFrame(np.array(tmp))], axis=0) last_one_recommended = last_one_recommended.T result = pd.concat([pd.DataFrame(last_one_recommended), result], axis=0) 考虑用户最后一次操作的关注物品x，干掉那些已经被用户购买的商品，剩下的商品表示用户依旧有兴趣但是因为没找到合适的或者便宜的商品，通过商品向量之间的相似度，可以直接计算出，与其高度相似的商品推荐给用户。 3.2 最大可能购买商品根据历史上用户依旧购买的商品顺序，判断根据当前这个目标用户近期买的商品，接下来他最有可能买什么？比如历史数据告诉我们，购买了手机+电脑的用户，后一周内最大可能会购买背包，那我们就针对那些近期购买了电脑+手机的用户去推送电脑包的商品给他，刺激他的潜在规律需求。123456789101112131415161718192021222324252627282930# 向量库rbind_data = pd.concat( [order_data[&apos;top1&apos;], order_data[&apos;top2&apos;], order_data[&apos;top3&apos;], order_data[&apos;top4&apos;], order_data[&apos;top5&apos;], order_data[&apos;top6&apos;], order_data[&apos;top7&apos;], order_data[&apos;top8&apos;], order_data[&apos;top9&apos;], order_data[&apos;top10&apos;]], axis=0)x = 50start = []output = []score_final = []for i in range(x): score = np.array(-100000000000000) name = np.array(-100000000000000) newscore = np.array(-100000000000000) tmp = test_data[i] k = len(tmp) last_one = tmp[k - 2] tmp = tmp[0:(k - 1)] for j in range(number): tmp1 = tmp[:] target = rbind_data_level[j] tmp1.append(target) test_data_split = [tmp1] newscore = model.score(test_data_split) if newscore &gt; score: score = newscore name = tmp1[len(tmp1) - 1] else: pass start.append(last_one) output.append(name) score_final.append(score) 3.3 联想记忆推荐在3.2中，我们根据了这个用户近期购买行为，从历史已购用户的购买行为数据发现规律，提供推荐的商品。还有一个近似的逻辑，就是通过目标用户最近一次的购买商品进行推测，参考的是历史用户的单次购买附近的数据，详细如下： 这个实现也非常的简单，这边代码我自己也没有写，就不贴了，采用的还是word2vec里面的predict_output_word(context_words_list, topn=10)，Report the probability distribution of the center word given the context words as input to the trained model 其实，这边详细做起来还是比较复杂的，我这边也是简单的贴了一些思路，如果有不明白的可以私信我，就这样，最后，谢谢阅读。]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于自然语言识别下的流失用户预警]]></title>
    <url>%2F2017%2F08%2F15%2F%E5%9F%BA%E4%BA%8E%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E8%AF%86%E5%88%AB%E4%B8%8B%E7%9A%84%E6%B5%81%E5%A4%B1%E7%94%A8%E6%88%B7%E9%A2%84%E8%AD%A6%2F</url>
    <content type="text"><![CDATA[update:17.12.20 : 关于IDF处描述，经@余海跃同学提醒，细化了解释内容，感谢！ 在电商运营过程中，会有大量的用户反馈留言，包括吐槽的差评，商品不满的地方等等，在用户运营生态中，这部分用户是最有可能流失也是最影响nps的人群，通过对其评价的语义分析，每日找出潜在的流失人群进行包括”电话回访”,”补券安慰”，”特权享受”等行为，有效的降低了用户的流失。根据实际的业务营销效果，在模型上线后，abtest检验下模型识别用户人群进行营销后的流失率比随意营销下降9.2%，效果显著。 当前文本文义识别存在一些问题：（1）准确率而言，很多线上数据对特征分解的过程比较粗糙，很多直接基于df或者idf结果进行排序，在算法设计过程中，也是直接套用模型，只是工程上的实现，缺乏统计意义上的分析； （2）文本越多，特征矩阵越稀疏，计算过程越复杂。常规的文本处理过程中只会对文本对应的特征值进行排序，其实在文本选择中，可以先剔除相似度较高的文本，这个课题比较大，后续会单独开一章进行研究； （3）扩展性较差。比如我们这次做的流失用户预警是基于电商数据，你拿去做通信商的用户流失衡量的话，其质量会大大下降，所以重复开发的成本较高，这个属于非增强学习的硬伤，目前也在攻克这方面的问题。 首先，我们来看下，整个算法设计的思路：1234567891.通过hive将近期的用户评价hadoop文件下载为若干个text文件2.通过R语言将若干个text整合读取为一个R内的dataframe3.利用R里面的正则函数将文本中的异常符号‘#！@￥%%’，英文，标点等去除（这边可以在hive里面提前处理好，也可以在后续的分词过程中利用停顿词去除）4.文本分词，这边可以利用R中的Rwordseg，jiebaR等，我写这篇文章之前看到很多现有的语义分析的文章中，Rwordseg用的挺多，所以这边我采用了jiebaR5.文本分词特征值提取,常见的包括互信息熵，信息增益，tf-idf，本文采取了tf-idf，剩余方法会在后续文章中更新6.模型训练 这边我采取的方式是利用概率模型naive bayes+非线性模型random forest先做标签训练，最后用nerual network对结果进行重估（原本我以为这样去做会导致很严重的过拟合，但是在实际操作之后发现，过拟合并不是很严重，至于原因我也不算很清楚，后续抽空可以研究一下） 下面，我们来剖析文本分类识别的每一步 定义用户属性首先，我们定义了已经存在的流失用户及非流失用户，易购的用户某品类下的购买周期为27天，针对前60天-前30天下单购物的用户，观察近30天是否有下单行为，如果有则为非流失用户，如果没有则为流失用户。提取每一个用户最近一次商品评价作为msg。 文本合成通过hive -e的方式下载到本地，会形成text01，text02…等若干个文本，通过R进行文本整合：12345678910111213141516171819#先设置文本路径path &lt;- &quot;C:/Users/17031877/Desktop/Nlp/answer/Cmsg&quot;completepath &lt;- list.files(path, pattern = &quot;*.txt$&quot;, full.names = TRUE)#批量读入文本readtxt &lt;- function(x) &#123; ret &lt;- readLines(x) #每行读取 return(paste(ret, collapse = &quot;&quot;)) #通过paste将每一行连接起来&#125;#lappy批量操作，形成list，个人感觉对非关系数据，list处理更加便捷msg &lt;- lapply(completepath, readtxt)#用户属性user_status &lt;- list.files(path, pattern = &quot;*.txt$&quot;)#stringsAsFactors=F，避免很多文本被读成因子类型comment &lt;- as.data.frame(cbind(user_status, unlist(msg)),stringsAsFactors = F)colnames(comment) &lt;- c(&quot;user_status&quot;, &quot;msg&quot;) 基础的数据整合就完成了。 数据整理也可以看到，基础数据读取完成后，还是很多评论会有一些不规则的数据，包括‘#￥%……&amp;’，英文，数字，下面通过正则、停顿词的方式进行处理： 正则化处理123456789101112131415161718192021222324252627282930#直接处理comment$msg &lt;- gsub(pattern = &quot; &quot;, replacement =&quot;&quot;, comment$msg) #gsub是字符替换函数，去空格comment$msg&lt;- gsub(&quot;[[:digit:]]*&quot;, &quot;&quot;, comment$msg) #清除数字[a-zA-Z]comment$msg&lt;- gsub(&quot;[a-zA-Z]&quot;, &quot;&quot;, comment$msg) #清除英文字符comment$msg&lt;- gsub(&quot;\\.&quot;, &quot;&quot;, comment$msg) #清除全英文的dot符号--------------------------------------------------------------------------------------------------#如果是常做nlp处理，可以写成函数打包，后期直接library就可以了#数值删除removeNumbers = function(x)&#123; ret = gsub(&quot;[0-9]&quot;,&quot;&quot;,x) return(ret) &#125;#字符删除removeLiters = function(x)&#123; ret = gsub(&quot;[a-z|A-Z]&quot;,&quot;&quot;,x) return(ret) &#125;#各种操作符处理,\s表示空格,\r表示回车,\n表示换行removeActions = function(x)&#123; ret = gsub(&quot;\\s|\\r|\\n&quot;, &quot;&quot;, x) return(ret) &#125;comment$msg=removeNumbers(comment$msg)comment$msg=removeLiters(comment$msg)comment$msg=removeActions (comment$msg) 这边需要对正则化里面的一些表示有所了解，详细可以百度，一般我都是具体需求具体去看，因为太多，自己又懒，所以没记 停顿词12345#加载jiebaR包library(jiebaR)#找jiebaR存停顿词的地方，自行将需要处理掉的符号存进去，我这边是C:/Program Files/R/R-3.3.3/library/jiebaRD/dict/stop_words.utf8tagger&lt;-worker(stop_word=&quot;C:/Program Files/R/R-3.3.3/library/jiebaRD/dict/stop_words.utf8&quot;) 至于位置可以通过直接输入worker()查看， 当前的是没有stop_word的，所有词存储的位置在：C:/Program Files/R/R-3.3.3/library/jiebaRD/dict/下 文本分词12345678#jieba 分词,去除停顿词library(jiebaR)tagger&lt;-worker(stop_word=&quot;C:/Program Files/R/R-3.3.3/library/jiebaRD/dict/stop_words.utf8&quot;)words=list()for (i in 1:nrow(comment))&#123; tmp=tagger[comment[i,2]] words=c(words,list(tmp))&#125; 直接先分词，但是分词结果会存在很多只有一个字比如‘的’、‘你’、‘我’等或者很多无意义的长句‘中华人民共和国’、‘长使英雄泪满襟’等，需要把这些词长异常明显无意义的词句去掉。12345678910111213141516171819202122232425#词长统计whole_words_set=unlist(words)whole_words_set_rank=data.frame(table(whole_words_set))whole_words_set_dealed=c()for (i in 1:nrow(whole_words_set_rank))&#123; tmp=nchar(as.character(whole_words_set_rank[i,1])) whole_words_set_dealed=c(whole_words_set_dealed,tmp)&#125;whole_words_set_dealed=cbind(whole_words_set_rank,whole_words_set_dealed)whole_words_set_dealed=whole_words_set_dealed[whole_words_set_dealed$whole_words_set_dealed&gt;1&amp;whole_words_set_dealed$whole_words_set_dealed&lt;5,]whole_words_set_dealed=whole_words_set_dealed[order(whole_words_set_dealed$Freq,decreasing=T),]#words的删除异常值,排序whole_words_set_sequence=wordskey_word=nrow(words)for (i in 1:key_word)&#123; for (j in 1:length(words[[i]]))&#123; tmp=ifelse(nchar(words[[i]][j])&gt;1 &amp; nchar(words[[i]][j])&lt;5,words[[i]][j],&apos;&apos;) whole_words_set_sequence[[i]][j]=tmp &#125;&#125;for (i in 1:key_word)&#123; whole_words_set_sequence[[i]]=whole_words_set_sequence[[i]][whole_words_set_sequence[[i]]!=&apos;&apos;]&#125; tf-idf词特征值重要性排序首先，我们大致看一下排序的数据依旧： TF = 某词在文章中出现的次数/文章包含的总词数（或者文章有价值词次数）DF = （包含某词的文档数）/（语料库的文档总数）IDF = log（（语料库的文档总数）/（包含某词的文档数+1））这边的+1是为了避免（语料库的文档总数）/（包含某词的文档数）=1，log(1)=0，使得最后的重要性中出现0的情况，与有意义的前提相互驳斥。TF-IDF = TF*IDF 分别看下，里面的每一项的意义：TF，我们可以看出，在同一个评论中，词数出现的越多，代表这个词越能成为这篇文章的代表，当然前提是非无意义的助词等。 IDF，我们可以看出，所以评论中，包含目标词的评论的占比，占比数越高，目标词的意义越大，假设1000条评论中，“丧心病狂”在一条评论里面重复了10次，但是其他999条里面一次也没有出现，那就算“丧心病狂”非常能代表这条评论，但是在做文本集特征考虑的情况下，它的价值也是不大的。 注意，经@余海跃同学提醒，这边的IDF解释不清晰，详细剖析如下：首先idf的定义是如下这样的：（D为所有文章，d为单篇文章）通常，会考虑类似近拉普拉斯平滑（+1）这样的方法修正idf值，在NLP领域，真正的意思如你所理解的：随着single word出现在的doc数量的增加，idf值应该是下降的，我们认为，一个词在越多文档中出现，该词代表文章的概述的能力越弱。其实，我在《应用：基于自然语言识别下的流失用户预警》实际R代码编写过程中也是这么去做的，但是当时我考虑了另一个方面：电商的评论与传统的文学文本差异还是很大的，单条评论中独特的词（只出现过一次的词或者短句）非常之多。这意味着：如果原封不动的按照idf去计算的话，最后识别出来的判别标签，也就是’文本分词特征值’会变得非常多，而且对泛化情况的识别能力非常的差。体现在对做后续的有监督分类的时候，如果不做处理会造成异常过拟合的问题。所以，我这边表述的想法是将idf值过大的一些词，也就是single word出现的doc过少的一些词剔除，再根据剩余的其他特征词计算idf提取关键特征词，我这边设定的阈值范围是：特征词至少在3.5%以上的评论中出现过。当然，你完全可以选择另外一种方法，完全按照idf计算，在最后做特分类之前，做特征筛选，去除掉一些冗余特征词变量。 下面，我们来看代码：123456789101112131415161718192021222324252627282930313233343536373839#tfidf_partone 为对应的tftdidf_partone=whole_words_set_sequencefor (i in 1:key_word)&#123;tmp1=as.data.frame(prop.table(table(whole_words_set_sequence[[i]])))tdidf_partone[[i]]=tmp1&#125;#tdidf_partfour 为对应的idftdidf_parttwo=unique(unlist(whole_words_set_sequence))tdidf_max=length(tdidf_parttwo)tdidf_partthree=tdidf_parttwofor (i in 1:tdidf_max)&#123;tmp=0aimed_word=tdidf_parttwo[i] for (j in 1:key_word)&#123; tmp=tmp+sum(tdidf_parttwo[i] %in% whole_words_set_sequence[[j]]) &#125;tdidf_partthree[i]=log(as.numeric(key_word)/(tmp+1))&#125;tdidf_partfour=cbind(tdidf_parttwo,tdidf_partthree)tdidf_partfive=tdidf_partonecolnames(tdidf_partfour)&lt;-c(&apos;Var1&apos;,&apos;Freq1&apos;)for (i in 1:key_word)&#123;tdidf_partfive[[i]]=merge(tdidf_partone[[i]],tdidf_partfour,by=c(&quot;Var1&quot;))&#125;#计算tf-idf结果，并排序key_wordtdidf_partsix=tdidf_partfivefor (i in 1:key_word)&#123;tmp=tdidf_partfive[[i]][,2:3]tdidf_partsix[[i]][,2]=as.numeric(tmp[,1])*as.numeric(tmp[,2])tdidf_partsix[[i]]=tdidf_partsix[[i]][order(tdidf_partsix[[i]][,2],decreasing=T),][]&#125;key_word=c()for (i in 1:key_word)&#123;tmp=tdidf_partsix[[i]][1:5,1]key_word=rbind(key_word,as.character(tmp))&#125; 理论上讲，如果这边数据存储方式用的是data.frame的话，可以利用spply、apply等批量处理函数，这边用得是list的方式，对lpply不是很熟悉的我，选择了for的循环，后续这边会优化一下，这样太消耗资源了。 模型训练这边，我最后采取的是概率模型naive bayes+非线性模型random forest先做标签训练，最后用nerual network对结果进行重估方式，但是在训练过程中，我还有几种模型的尝试，这边也一并贴出来给大家做参考。 数据因子化的预处理这边得到了近400维度的有效词，现在将每一维度的词遍做一维的feature，同时，此处的feature的意义为要么评论存在该词，要么评论中不存在该词的0-1问题，需要因子化一下。12345678910111213141516171819202122232425262728#整合数据well_dealed_data=cbind(as.character(comment[,1]),key_word)names=as.data.frame(table(key_word))[,1]names_count=length(names)names=as.matrix(names,names_count,1)feature_matrix=matrix(rep(0,names_count*key_word),key_word,names_count)for (i in 1:names_count)&#123; for(j in 1:key_word)&#123; feature_matrix[j,i]=ifelse(names[i] %in% key_word[j,],1,0) &#125;&#125;#art=1,literature=-1,标签0-1化feature_matrix=cbind(well_dealed_data[,1],feature_matrix)feature_matrix[feature_matrix[,1]==&apos;aimed&apos;,1]=&apos;1&apos;feature_matrix[feature_matrix[,1]==&apos;unaimed&apos;,1]=&apos;-1&apos;feature_matrix=as.data.frame(feature_matrix)num=1:(ncol(feature_matrix)-1)value_name=paste(&quot;feature&quot;,num)value_name=c(&apos;label&apos;,value_name)colnames(feature_matrix)=value_name#feature0-1化for (i in 1:ncol(feature_matrix))&#123;feature_matrix[,i]=as.factor(as.numeric(as.character(feature_matrix[,i])))&#125; 数据切分训练测试这边就不适用切分函数了，自己写了一个更加快速。123n_index=sample(1:nrow(feature_matrix),round(0.7*nrow(feature_matrix)))train_feature_matrix=feature_matrix[n_index,]test_feature_matrix=feature_matrix[-n_index,] 模型训练backpropagation neural network这边需要用网格算法对size和decay进行交叉检验，这边不贴细节，可以百度搜索详细过程。123456789101112library(nnet)nn &lt;- nnet(label~., data=train_feature_matrix, size=2, decay=0.01, maxit=1000, linout=F, trace=F)#train数据集效果nn.predict_train = predict(nn,train_feature_matrix,type = &quot;class&quot;)result_combind_train=cbind(as.numeric(as.character(train_feature_matrix$label)),nn.predict_train)correction_train=nrow(result_combind_train[result_combind_train[,1]==result_combind_train[,2],])/nrow(result_combind_train)#test数据集效果nn.predict_test = predict(nn,test_feature_matrix,type = &quot;class&quot;)result_combind_test=cbind(as.numeric(as.character(test_feature_matrix$label)),nn.predict_test)correction_test=nrow(result_combind_test[result_combind_test[,1]==result_combind_test[,2],])/nrow(result_combind_test) Linear Support Vector Machine这边需要用网格算法对cost进行交叉检验，这边不贴细节，可以百度搜索详细过程。123456789101112library(e1071)svmfit &lt;- svm(label~., data=train_feature_matrix, kernel = &quot;linear&quot;, cost = 10, scale = FALSE) # linear svm, scaling turned OFF#train数据集效果svmfit.predict_train=predict(svmfit, train_feature_matrix, type = &quot;probabilities&quot;)result_combind_train=cbind(as.numeric(as.character(train_feature_matrix$label)),as.numeric(as.character(svmfit.predict_train)))correction_train=nrow(result_combind_train[result_combind_train[,1]==result_combind_train[,2],])/nrow(result_combind_train)#test数据集效果svmfit.predict_test = predict(svmfit,test_feature_matrix,type = &quot;class&quot;)result_combind_test=cbind(as.numeric(as.character(test_feature_matrix$label)),as.numeric(as.character(svmfit.predict_test)))correction_test=nrow(result_combind_test[result_combind_test[,1]==result_combind_test[,2],])/nrow(result_combind_test) 贝叶斯分类器这边我没调参，我觉得这边做的好坏在于数据预处理中剩下来的特征词123456789101112library(e1071)sms_classifier &lt;- naiveBayes(train_feature_matrix[,-1], train_feature_matrix$label)#train数据集效果sms.predict_train=predict(sms_classifier, train_feature_matrix)result_combind_train=cbind(as.numeric(as.character(train_feature_matrix$label)),as.numeric(as.character(sms.predict_train)))correction_train=nrow(result_combind_train[result_combind_train[,1]==result_combind_train[,2],])/nrow(result_combind_train)#test数据集效果sms.predict_test = predict(sms_classifier,test_feature_matrix)result_combind_test=cbind(as.numeric(as.character(test_feature_matrix$label)),as.numeric(as.character(sms.predict_test)))correction_test=nrow(result_combind_test[result_combind_test[,1]==result_combind_test[,2],])/nrow(result_combind_test) 随机森林这边因为是最后的整合模型，需要调参的地方比较多，首先根据oob确定在mtry=log（feature）下的最优trees数量，在根据确定的trees的数量，反过来去确定mtry的确定值。除此之外，还需要对树的最大深度，子节点的停止条件做交叉模拟，是整体模型训练过程中最耗时的地方123456789101112library(randomForest)randomForest=randomForest(train_feature_matrix[,-1], train_feature_matrix$label)#train数据集效果rf.predict_train=predict(randomForest, train_feature_matrix)result_combind_train=cbind(as.numeric(as.character(train_feature_matrix$label)),as.numeric(as.character(rf.predict_train)))correction_train=nrow(result_combind_train[result_combind_train[,1]==result_combind_train[,2],])/nrow(result_combind_train)#test数据集效果rf.predict_test = predict(randomForest,test_feature_matrix)result_combind_test=cbind(as.numeric(as.character(test_feature_matrix$label)),as.numeric(as.character(rf.predict_test)))correction_test=nrow(result_combind_test[result_combind_test[,1]==result_combind_test[,2],])/nrow(result_combind_test) 就单模型下的test集合的准确率如下： 整体上看，nnet是过拟合的，所以在测试集上的效果折扣程度最大；naive bayes模型的拟合效果应该是最弱的，但是好在它的开发成本低，逻辑简单，有统计意义；svm和randomforest这边的效果不相上下。本次训练的数据量在20w条左右，理论上讲再扩大数据集的话，randomforest的效果应该会稳定，svm会下降，nnet会上升。 模型集成 这边的train_data的准确率在92.1%，test_data的准确率在84.3%，与理想的test_data90%以上的准确率还是有差距，所以后续准备：1.细化流失用户的定义方式，当前定义过于笼统粗糙2.以RNN的模型去替代BpNN去做整合训练，探索特征到特征本身的激活会对结果的影响3.重新定义词重要性，考虑互信息熵及isolation forest的判别方式 最后谢谢大家的阅读。]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据预处理-异常值识别]]></title>
    <url>%2F2017%2F08%2F09%2F%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86-%E5%BC%82%E5%B8%B8%E5%80%BC%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[系统总结了常用的异常值识别思路，整理如下： 空间识别分位数识别代表的执行方法为箱式图： 上四分位数Q3，又叫做升序数列的75%位点下四分位数Q1，又叫做升序数列的25%位点箱式图检验就是摘除大于Q3+3/2*（Q3-Q1），小于Q1-3/2*（Q3-Q1）外的数据，并认定其为异常值；针对全量样本已知的问题比较好，缺点在于数据量庞大的时候的排序消耗R语言中的quantile函数，python中的percentile函数可以直接实现。 距离识别最常用的就是欧式距离，比如：两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的欧氏距离： 可以直观感受的到，图中，距离蓝色B点距离为基准衡量的话，红色A1，红色A2，红色A3为距离较近点，A4为距离较远的异常点。 但是这样看问题会有一个隐患，我们犯了“就点论点”的错误没有考虑到全局的问题，让我在看下面这张图： 还是刚才那张图，橙色背景为原始数据集分布，这样看来A4的位置反而比A1、A3相对更靠近基准点B，所以在存在纲量不一致且数据分布异常的情况下，可以使用马氏距离代替欧式距离判断数据是否离群。 其中，μ为feature的均值，X为观察值，Σ为feature的协方差矩阵马氏距离除了用来判断点是否异常，也可以用来判断两个数据集相识度，在图像识别，反欺诈识别中应用的也是非常普遍；问题在于太过于依赖Σ，不同的base case对应的Σ都是不一致的，不是很稳定 密度识别密度识别的方式方法比较多，这边就提供其中比较经典的，首先我们可以通过密度聚类中大名鼎鼎的dbscan入手，这边只讲思路，详细的算法过程另行介绍。简单的来讲，下面这张图可以协助理解 我们可以通过随机选择联通点，人为设置联通点附近最小半径a，半径内最小容忍点个数b，再考虑密度可达，形成蓝色方框内的正常数据区域，剩下的黄色区域内的点即为异常点。 除此之外，密度识别里面还有一种方式，是参考单点附近的点密度判断，伪代码如下：12345671.从特征集合中任选历史上没有被选择过的两维2.将原始点集映射到该两维平面上，刻画点集中心a3.以点集中心a，x为半径画圆，不断扩大x的值，直到被覆盖的点集数/原始点集数的最低阈值4.没有被覆盖到的点集打上outlier_label5.repeat 1-46.统计点对应的outlier_label个数7.排序高则优先为异常点 这边参考了Clique的映射+Denclue的密度分布函数的思路，注意问题就是计算量大，所以对小样本的适用程度更高一些，针对大样本多特征的数据可以考虑对样本进行子集抽样，再根据子集进行1-5，汇总后整体进行6-7步骤，实际检验效果仍然可以达到不抽样的85%以上 拉依达准则这个方法更加偏统计一些，设计到一些距离的计算，勉强放在空间识别里面 这种判别处理原理及方法仅局限于对正态或近似正态分布的样本数据处理，它是以数据充分大为前提的，当数据较少的情况下，最好不要选用该准则。 正态分布（高斯分布）是最常用的一种概率分布，通常正态分布有两个参数μ和σ为标准差。N(0,1)即为标准正态分布。 从上面这张图可以看出，当数据对象值偏离均值3倍标准差的时候，该数据合理的出现可能性小于3‰，所以可以直接认定，数据偏离均值±3倍标准差时，为异常点。但是最后再次强调一遍：它是以数据充分大为前提的，当数据较少的情况下，最好不要选用该准则。 计量识别G-test或者说是likelihood Ratio方法G-test这类方法运用在医学方面较多，常用于检验观测变量值是否符合理论期望的比值。现在也用在电商、出行、搜索领域检验一些无监督模型的质量、数据质量。 当我们新上一个模型，部分用户的反馈特别异常，我们不知道是不是异常数据，在接下来的分析中需不需要剔除，我们可以用统计学方法予以取舍。其中O为观测值，E为期望值，假如我们的网站每天24个小时的订单量分布稳定，分时段计算出一个均值，E1，E2，..E24，新模型产出后，我们问题用户群对应的24个小时的订单分布值O1,O2,…..O24,套用上面的公式，我们就可以计算出一个G值出来。 然后在根据G-test的base值，观察目标用户可信的最大置信度，判断置信度是否符合我们的最低要求；likelihood Ratio方法类似，相关论文可以直接搜索。 模型拟合这类方法属于简单有监督识别，常见的包括贝叶斯识别，决策树识别，线性回归识别等等。 需要提前知道两组数据：正常数据及非正常类数据，再根据它们所对应的特征，去拟合一条尽可能符合的曲线，后续直接用该条曲线去判断新增的数据是否正常。举个例子：金融借贷中，我们事先活动一批正常借贷用户，和逾期不还用户，我们通过打分卡模型去识别已知用户的特征，假设得到芝麻分、手机使用时长、是否为男性为关键特征。接下来判断未知标签的新增数据是否为正常用户的话，直接根据之前判断出来的拟合打分卡曲线去做0-1概率预估就行了。 但是模型拟合的方式使用情况较为局限，绝大多数异常识别问题是无法拿到前置的历史区分数据，或者已分好的数据不能够覆盖全量可能，导致时间判断误差较大，顾一般只做emsemble model的其中一种组合模块，不建议做主要依赖标注。 明尼苏达州大学有过一篇异常论文识别的总结，里面关于有监督模型、半监督模型、无监督模型等模型拟合讲的非常细致，如果感兴趣可以研究一下，附上论文Survey：http://cucis.ece.northwestern.edu/projects/DMS/publications/AnomalyDetection.pdf 变维识别首先，我们来看一下PCA的伪代码123451.去除平均值,方便后续协方差，方差矩阵的计算2.计算协方差矩阵及其特征值和特征向量3.将特征值从大到小排序，特征值可以反映方差贡献度，特征值越大，方差贡献度越大4.保留最大的N个特征值以及它们的所对应的特征向量5.将数据映射到上述 N 个特征向量构造的新空间中 pca的核心思路在于尽可能通过feature的组合代替原始feature，使得原始数据的方差最大化。通过pca可以得到第一主成分、第二主成分…。对于正常数据集来说，正常数据量远远大于异常数据，所以正常数据所贡献的方差远远大于异常数据；通过pca得到的排名靠前的主成分解释了原始数据较大的方差占比，所以理论上讲，第一主成分反映了正常值的方差，最后一个主成分反映了异常点的方差。通过第一主成分对原始数据进行映射后，原始数据中的正常样本和异常样本的属性不会随之改变。 存在一个p个维度的数据集orgin_data，X为其协方差矩阵，通过奇异值分解可以得到： 其中，D为对角阵，其每一个值为X所对应的特征值；P的每一列为X的所对应的特征向量，并将D中的特征值从大到小排列，相应的改变P所对应的列向量。我们选取top(j)个D中的特征值，及其P所对应的特征向量构成(p,j) 维的矩阵 pj ，再将目标数据集orgin_data进行映射：new_data = orgin_data*pj；new_data是一个 (N,j) 维的矩阵。如果考虑拉回映射的话（也就是从主成分空间映射到原始空间），重构之后的数据集合是:back_data=transpose(pj*transpose(new_data))=new_data*transpose(pj),是使用 top-j 的主成分进行重构之后形成的数据集，是一个 (N,p) 维的矩阵。 所以，我们有如下的outlier socres的定义： ev(j) subject to. 解释一下上面两个公式，先计算score中orgindata的列减去前j个主成分映射回原空间的newdata下的欧式范数值；再考虑不同主成分所需乘以的权重，这边，我们认为，第一主成分所代表的数据中正常数据更多，所以权重越小；当j取到最后一维的主成分下，我们认为权重最高，达到1。 对于outlier socres过高的点，即为异常点。 神经网络识别之前比较火的神经网络分析，同样可以用来做有监督的异常点识别，这边介绍一下Replicator Neural Networks (RNNs)。 这边我们通过图像可以看出：1.输入层中，输入变量个数与输出层中，输出变量一致2.中间层的节点数小于输入输出层节点3.整个训练过程是一个先压缩后解压的过程 常规的，我们通过mse来看模型的误差我们来大致了解一下RNN的运行逻辑，首先，最左边的为输入层即为原始数据，最右层的为输出层即为输出数据。中间各层的激活函数不同，入参经过激活函数所得到的出参的值也不一致，但是在同一层激活函数都是一致的。对于我们异常识别而言，第二层和第四层 (k=2,4)，激活函数选择为 tanh图像如下，可以将原始数据压缩在-1到1之间，使得原始数据有界。 对于中间层 (k=3) 而言，激活函数是一个类阶梯 (step-like) 函数。其中，N为阶梯分层数，a3为提升的效率。N的个数越多，层次分的更多。 比如N=5的形式下： 比如N=3的形式下： 这样做的好处就是，随着N的增加可以将异常点或者异常点群集中在某一个离散阶梯范围内。通过对RNN的有监督训练，构造异常样本分类器，进行异常值识别。 isolation forest2010年南大的周志华教授提出了一个基于二叉树的异常值识别算法，在工业界来说，效果是非常不错的，最近我也做了一个流失用户模型，实测效果优秀。 和random forest一样，isolation forest是由isolation tree构成，先看一下isolation tree的逻辑：1234567method:1.从原始数据中随机选择一个属性feature；2.从原始数据中随机选择该属性的下的一个样本值value；3.根据feature下的value对每条记录进行分类，把小于value的记录放在左子集，把大于等于value的记录放在右子集；4.repeat 1-3 until： 4.1.传入的数据集只有一条记录或者多条一样的记录； 4.2.树的高度达到了限定高度； 大致的思路如下图： 理论上，异常数据一般都是离群数据，非常容易在早期就被划分到最终子节点。所以，通过计算每个子节点的深度h(x)，来判断数据为异常数据的可能性。论文中，以s(x,n)为判断数据是否异常的衡量指标。 其中，h(x)为x对应的节点深度，c(n)为样本可信度，s(x,n)~[0,1]，正常数据来讲s(x,n)小于0.8，s(x,n)越靠近1，数据异常的可能性越大。 单棵树的可信性不足，所以我们通过用emsemble model的思路，去构造一个forest的树群来提高准确性。但是作为isolation forest的时候，需要对原s(x,n)的公式有所更改，通过E(h(x))来替代h(x),其中E(h(x))为数据x在各棵树上的h(x)的平均。同时，1.因为树的个数大大增加，所以需要控制计算的开销，所以每个棵树我们可以采取数据抽样的方式，使得抽样数据集远远小于原始数据集，且根据周志华老师的论文，采样大小超过256效果就提升不大了。2.我们可以控制深度，使得没棵树的最大深度limit length=ceiling(log2(样本大小))，当树深度大于最大深度时，其产生的子节点绝大多数均为正常数据节点，失去异常检验的意义。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何校验用户画像的准确性？]]></title>
    <url>%2F2017%2F07%2F20%2F%E5%A6%82%E4%BD%95%E6%A0%A1%E9%AA%8C%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E7%9A%84%E5%87%86%E7%A1%AE%E6%80%A7%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[在用户研究的课题中，用户画像是几乎每个公司都会去做的，浅层的包括统计类的：上月购买量，上周活跃天数等；深层的包括洞察类的：潜在需求偏好，生命周期阶段等；前者的校验简单，后者的校验需要通过一些特别的方式。本文就洞察类画像校验做一系列的梳理。 省略掉预处理设计的过程，画像校验的步骤主要集中在画像开发，画像上线，画像更新中，并且三个阶段中，每个阶段的校验方式完全不同 用户画像开发中当我们所开发的用户画像是类似于用户的下单需求、用户的购车意愿、用户是否有注册意愿这一类存在历史的正负样本的有监督的问题，我们可以利用历史确定的数据来校验我们的画像准确性。比如，银行在设计用户征信的画像前，会有一批外部购买的坏样本和好样本，其实画像问题就转化为分类问题去解决评估了。1.1 Recall、Pecision、K-S、F1曲线、Roc曲线、Confusion Matrix、AUC针对这类问题，已经有较为成熟的理论基础，直接利用测试样本判断的准确程度判断画像是否准确 这张图是一张非常常见也是有效的来总结Recall、Pecision、Lift曲线、Roc曲线、Confusion Matrix的图。FPR = FP/(FP + TN)Recall=TPR=TP/(TP+FN)Precision=TP/(TP+FP)F1曲线:2*Precision*Recall/(Precision+Recall)Roc曲线：TPR vs FPR，也就是Precision vs RecallAuc：area under the roc curve ，也就是roc曲线下面的面积，积分或者投点法均可求解。这边不详细讲细节，需要的可以参考精确率、召回率、F1 值、ROC、AUC 各自的优缺点是什么？ 1.2 交叉验证并不是所有画像都是有监督训练的画像，举个例子，用户的性别画像，是一个无监督的刻画，当你无法通过app端资料填写直接获取到的时候，你只能够通过其他数据特征的对用户进行分群。 1234567891011121314input :Data Set：测试数据集output :model：画像模型label：0(无效)，1（有效）methods：1.从原始数据集中确定画像模型关键features2.关键features分层，分为train features、test features3.train featrues训练画像4.test freatrues校验画像5.输出值对（model，label）6.重复2~5 首先，我们在总的数据集中筛选出所有关键影响特征，每次将筛选出的特征分为两块，测试特征训练特征，利用训练特征建立模型，再利用测试特征去判断模型是否合理（比如女鞋用户群的女鞋购买次数小于男性用户群，则次模型异常，删除），最后集成所有合理模型。这样的逻辑中，我们将所有异常不合理的模型全部剔除，训练过程中就校验了用户画像的准确性 用户画像上线后ABTest不得不说，abtest是用户画像校验最为直观有效的校验方式。 用户分流模块： 123456789101112methods:1. 全量用户流量为Users，切分流量为三块Users：A1、Users：A2、Users：B，且满足Users：A1+Users：A2=Users：B2. 对流量Users：A1、Users：A2不做任何动作3. 对流量Users：B做相应的模型预测，保存结果4. 以用户活跃度为例子，选取观察日期周下平均登陆次数y为代价函数，if y（Users：A1）=y（Users：A2）then if y（Users：B）&gt; y（Users：A1+Users：A2） then 模型有效（差值越大代表准确越高） else 模型无效（差值越小代表准确越差）else 模型无效5.准确程度量化：K=(p*exp(-(dist(y(Users:B),y(Users:A1+Users:A2)))^2/(2*最小容忍度^2)))^(-1) 一句话解释，就是A1=A2保证分配随机，A3好于A1+A2的效果检验画像是否准确？多准确？ 用户画像更新用户回访在画像刻画完成后，必然会存在画像优化迭代的过程，客服回访是非常常见且有效的方式。比如，我们定义了一波潜在流失用户10万人，随机抽取1000人，进行回访，根据回访结果做文本挖掘，提取关键词，看消极词用户的占比； 机制检测再比如，我们定义了一波忠诚用户10万人，随机抽取100人，后台随机获取用户安装app的列表，看用户同类app的下载量数目的分布； 横轴为用户手机中同类竞品安装量的个数，纵轴为对应的随机抽样的100人中的个数人群1分布为忠诚用户画像最准确的，同类app下载量集中在1附近，定义的用户极为准确人群2分布杂乱，人群3分布在下降量异常高的数值附近，定义人群不准确用户画像是数据运营运营的基础，也是做深度挖掘的一个不可或缺的模块，只有先打好画像基础，确保画像质量，后续的深挖行为才有突破的可能，最后，谢谢大家阅读。]]></content>
      <categories>
        <category>特征刻画</category>
      </categories>
      <tags>
        <tag>用户画像</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据量下的划分聚类方法]]></title>
    <url>%2F2017%2F07%2F19%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E4%B8%8B%E7%9A%84%E5%88%92%E5%88%86%E8%81%9A%E7%B1%BB%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在常规聚类案例中，数据一般都是以iris集或者不足GB级的数据作为测试案例，实际商业运用中，数据量级要远远大于这些。比如滴滴出行15年日均单量就达到1000万单，出行轨迹的数据存储达到上百TB，常规的k均值聚类，二分聚类等无法完成如此量级的数据聚类，这边就提供一个以CLARANS为基础的算法思路。 什么是聚类?定义是这样的，把一个数据对象，划分成子集的过程，使得子集内相似度大，子集外相似度小。这样的一个过程叫做聚类。 大学课程老师以一个公式概括过这样的过程：max(子集内相似度/子集间相似度)，我觉得也很形象便于理解。 什么是划分聚类？聚类方法有很多种，包括基于划分、基于密度、基于网格、基于层次、基于模型等等，这边主要介绍基于划分的聚类方法，剩余的方法会在后续的文章中持续更新[如果不鸽的话]。划分聚类一般是：采取互斥族（子集）划分，说的更直白一点就是每个点属于且仅属于一个族（子集）。 常见的划分聚类有哪些？k均值划分：12345678910input：- k：族的个数- D：输入数据集合output：k个族（子集）的数据集合methods：1.在D中任选（常用的包库中都是这样做，但是建议自己写的同学以密度先分块，在密度块中任选）k个对象作为初始中心2.计算剩余对象到k对象的聚类，聚类远近分配到对应的族3.更新族均值作为新的族中心4.重复2-4直到中心不变化 如图过程： 以上为最简单的k均值，很容易看出，它存在几个问题，首先计算量非常的大，假设有m条数据，k个中心点，那距离计算的次数就是o(mkt)=k*(m-k)*迭代次数t，重复t次直到收敛的过程是非常大的计算过程；再而，如果数据均为‘男、女’，‘高、中、低’等，那距离定义就是非常不合理的，此外，初始k难确定，非凸数据，离群点等等都存在问题 围绕中心划分（PAM）：刚才说到了异常点会影响k均值，那么我们看看为什么？假设与点1、2、3、8、9、10、25，一眼就知道(1、2、3)，(8，9，10)为族，但如果由k均值的话，以k=2为例，((1，2，3)，(8，9，10，25))，mse=196；((1，2，3，8)，(9，10，25))，mse=189.7；它重复以mse为损失函数，而不去考虑数据是否合理，所以针对的，我们有绝对误差标准： 这样做，通过全局距离最小化，可以一定程度上避免异常点的问题，但是，思考一下计算量是什么？是o(n**2)，这意味着对数据量大的问题，这就是一个典型的NP问题（一定有解，但是不一定在有限时间资源内可以被解出来）。1234567891011121314input:- k：族的个数- D：输入数据集合output：k个族（子集）的数据集合methods:1.D中任选k个对象最为初始种子2.仿照k均值分配剩余对象3.随机选取非种子对象O4.计算若是以O为中心下的总损失函数代价S=原始种子下的绝对误差E-新的对象O下的绝对误差E5.如果S&gt;0,则以新对象O替换旧的种子对象，否则不变化6.重复2-5，直到收敛 我们看这个图好理解一点，就是存在族（集合）中任一点p，当前的初始种子为Q1，随机选取剩余其他对象为族中心Qrandom1，计算PQ1的距离与PQrandom1的距离，图中dist(PQ1)dist(PQrandom2)，则更新族中心为Qrandom2,此时绝对误差E会变化，计算是否降低了绝对误差E以确定是否更好族中心。如何解决大数据量下的聚类问题？其实看了以上两个算法，大同小异，但是都不可避免有一个弱点，就是计算量上都是随着初始数据量的增大而几何增长的，所以这边需要对数据量进行控制。 大家回想一下，同样的对数据量进行控制的算法有哪些给我们有启发？数据平衡算法这种方法好像可以减少数据量，哪有没有历史成功案例支持呢？基于决策树引申出的集成算法貌似存在一个叫做adaboost、randomforest这类的算法，好像就用了数据平衡的算法。 那么，我们是否可以用在聚类里面呢？答案是可以的，我们现在看一个由上述思路得到的CLARANS算法，实际开发中，我们team对其进行了优化，内部称之为’CLARANS+’在理解CLARANS+之前，我们先理解CLARA: 从这张图上，我们可以很清晰的看出，CLARA首先通过类似randomforest里面的随机抽样的方法，将原始数据集随机抽样成若干个子数据集sample data，理论上采样的子集分布应该与原分布近似，所以样本中心点必然与原分布中心近似。 在数据量较少的子集上，我们可以重复确定每个子集的中心Medoid，这边计算中心的方法有很多，包括上述讲到的K均值，PAM，也可以参考相似度比如常见的余弦相似，likelihood rate，高斯核相似等等 最后采取随机抽取，或者投票加权等方法确定原始样本的中心即可。 CLARA的有效性依赖于样本的大小，分布及质量，所以该算法一定程度上会依赖于初始抽样的质量。除此之外，每一个随机样本的计算负责度为O（ks*s+k（n-k）），s为样本的大小，k为族数，n为总对象数，若抽取样本子集过少，其简化计算的程度也越低。 说到这里，CLARA的算法是确定了中心后不在改变，这就有一定的运气成分，假设确定的k个钟均离最佳中心很远的情况下，CLARA最后无论如何去选已知中心，都得不到最优秀的聚类中心。 所以，我们来看看可以提高CLARA的聚类质量及可伸缩性的CLARANS算法 上述思路不变，但在CLARA确定中心之后，我们新增了一步，就是按照PAM中的方法一样，我们在子集上选取一个与当前中心x(Medoid)不一样的对象y(New Medoid)，计算用y(New Medoid)替换x(Medoid)后绝对误差是否下降，下降则替换否则不变，重复l次之后，我们可以认为此时的中心点为局部中心最优解；整体数据集所有子集均重复m次后，得出的中心点为全局局部最优解。如下图： 实际上，我们可以做的还很多理论上讲，以上的算法结果已经尽可能的保证了数据的合理压缩，压缩后的数据集内的中心点足够鲁棒，但是实际运用过程中，我们没有尽可能的考虑到开头说的那句：什么是聚类?定义是这样的，把一个数据对象，划分成子集的过程，使得子集内相似度大，子集外相似度小。这样的一个过程叫做聚类。 所以，我们尝试性的做了CLARANS+，我们把CLARANS里面确定出来的每个sample data子集里面最优秀的top k个New Medoids映射回同一个空间：以绿色和天蓝色数据集为例子： 橘色方框内为CLARANS最后确定中心后做的随机或者加权投票后采纳的被橘黄色框框住的天蓝色数据与绿色数据的中心点，很明显可以看出，这样导致的结果违背了“子集外相似度最小的原则”。 我们，仿照Lasso对应lambda.1se的方式，考虑除了最优点外，在其可接受的范围附近，认为他们同样属于最优点，也就是top k个New Medoids重新选择距离最远的点作为最优中心，也就是如下图中的紫色方框中的点： 通过实际的业务测试，我们建议top k个点中的个默认为2-3比较好（数据分布差异大选择2，否则选择3）,如果不能确定，就默认为3。 以上理论方法就解释了如何在大量数据量下，简单快速的寻找到最优中心点的过程，谢谢大家。 参考文献：[1] Jiawei Han.[数据挖掘概念与技术]2001，8[2] 毛国君等.数据挖掘原理与算法[M].北京:清华大学出版社,2005.[3] 数据平衡算法[4] 基于决策树引申出的集成算法[5] http://scikit-learn.org/stable/modules/clustering.html#clustering[6] https://en.wikipedia.org/wiki/Clustering]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>理论解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据抽样平衡方法重写]]></title>
    <url>%2F2017%2F07%2F13%2F%E6%95%B0%E6%8D%AE%E6%8A%BD%E6%A0%B7%E5%B9%B3%E8%A1%A1%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%2F</url>
    <content type="text"><![CDATA[之前在R里面可以通过调用Rose这个package调用数据平衡函数，这边用python改写了一下，也算是自我学习了。 R：12345678910# 设定工作目录setwd(path)# 安装包install.packages("ROSE")library(ROSE)# 检查数据data(hacide)table(hacide.train$cls) 0 1980 20 过抽样实现：1234data_balanced_over &lt;- ovun.sample(cls ~ ., data = hacide.train, method = &quot;over&quot;,N = 1960)$datatable(data_balanced_over$cls)0 1980 980 这边需要注意是ovun不是over 欠采样实现：1234data_balanced_under &lt;- ovun.sample(cls ~ ., data = hacide.train, method = &quot;under&quot;, N = 40, seed = 1)$datatable(data_balanced_under$cls)0 120 20 这边需要注意的是欠采样是不放回采样，同时对数据信息的损失也是极大的 组合采样实现：1234data_balanced_both &lt;- ovun.sample(cls ~ ., data = hacide.train, method = &quot;both&quot;, p=0.5, N=1000, seed = 1)$datatable(data_balanced_both$cls)0 1520 480 method的不同值代表着不同的采样方法，p这边是控制正类的占比，seed保证抽取样本的固定，也就是种子值。 在python上，我也没有发现有现成的package可以import，所以就参考了R的实现逻辑重写了一遍，新增了一个分层抽样group_sample,删除了过采样，重写了组合抽样combine_sample,欠抽样under_sample:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101# -*- coding:utf-8 -*-import pandas as pdimport random as rdimport numpy as npimport math as maclass sample_s(object): def __init__(self): ''''this is my pleasure''' def group_sample(self, data_set, label, percent=0.1): # 分层抽样 # data_set:数据集 # label:分层变量 # percent:抽样占比 # q:每次抽取是否随机,null为随机 # 抽样根据目标列分层，自动将样本数较多的样本分层按percent抽样，得到目标列样本较多的特征欠抽样数据 x = data_set y = label z = percent diff_case = pd.DataFrame(x[y]).drop_duplicates([y]) result = [] result = pd.DataFrame(result) for i in range(len(diff_case)): k = np.array(diff_case)[i] data_set = x[x[y] == k[0]] nrow_nb = data_set.iloc[:, 0].count() data_set.index = range(nrow_nb) index_id = rd.sample(range(nrow_nb), int(nrow_nb * z)) result = pd.concat([result, data_set.iloc[index_id, :]], axis=0) new_data = pd.Series(result['label']).value_counts() new_data = pd.DataFrame(new_data) new_data.columns = ['cnt'] k1 = pd.DataFrame(new_data.index) k2 = new_data['cnt'] new_data = pd.concat([k1, k2], axis=1) new_data.columns = ['id', 'cnt'] max_cnt = max(new_data['cnt']) k3 = new_data[new_data['cnt'] == max_cnt]['id'] result = result[result[y] == k3[0]] return result def under_sample(self, data_set, label, percent=0.1, q=1): # 欠抽样 # data_set:数据集 # label:抽样标签 # percent:抽样占比 # q:每次抽取是否随机 # 抽样根据目标列分层，自动将样本数较多的样本按percent抽样，得到目标列样本较多特征的欠抽样数据 x = data_set y = label z = percent diff_case = pd.DataFrame(pd.Series(x[y]).value_counts()) diff_case.columns = ['cnt'] k1 = pd.DataFrame(diff_case.index) k2 = diff_case['cnt'] diff_case = pd.concat([k1, k2], axis=1) diff_case.columns = ['id', 'cnt'] max_cnt = max(diff_case['cnt']) k3 = diff_case[diff_case['cnt'] == max_cnt]['id'] new_data = x[x[y] == k3[0]].sample(frac=z, random_state=q, axis=0) return new_data def combine_sample(self, data_set, label, number, percent=0.35, q=1): # 组合抽样 # data_set:数据集 # label:目标列 # number:计划抽取多类及少类样本和 # percent：少类样本占比 # q:每次抽取是否随机 # 设定总的期待样本数量，及少类样本占比，采取多类样本欠抽样，少类样本过抽样的组合形式 x = data_set y = label n = number p = percent diff_case = pd.DataFrame(pd.Series(x[y]).value_counts()) diff_case.columns = ['cnt'] k1 = pd.DataFrame(diff_case.index) k2 = diff_case['cnt'] diff_case = pd.concat([k1, k2], axis=1) diff_case.columns = ['id', 'cnt'] max_cnt = max(diff_case['cnt']) k3 = diff_case[diff_case['cnt'] == max_cnt]['id'] k4 = diff_case[diff_case['cnt'] != max_cnt]['id'] n1 = p * n n2 = n - n1 fre1 = n2 / float(x[x[y] == k3[0]]['label'].count()) fre2 = n1 / float(x[x[y] == k4[1]]['label'].count()) fre3 = ma.modf(fre2) new_data1 = x[x[y] == k3[0]].sample(frac=fre1, random_state=q, axis=0) new_data2 = x[x[y] == k4[1]].sample(frac=fre3[0], random_state=q, axis=0) test_data = pd.DataFrame([]) if int(fre3[1]) &gt; 0: i = 0 while i &lt; (int(fre3[1])): data = x[x[y] == k4[1]] test_data = pd.concat([test_data, data], axis=0) i += 1 result = pd.concat([new_data1, new_data2, test_data], axis=0) return result 后续使用，只需要复制上述code，存成.py的文件，后续使用的时候：1234567#加载函数import sample_s as sa#这边可以选择你需要的分层抽样、欠抽样、组合抽样的函数sample = sa.group_sample()#直接调用函数即可new_data3 = sample.combine_sample(data_train, 'label', 60000, 0.4)#将data_train里面的label保持正样本（少类样本）达到0.4的占比下，总数抽取到60000个样本 其实不是很难的一个过程，只是强化自己对python及R语言的书写方式的记忆，谢谢。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>数据平衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[订单需求预估]]></title>
    <url>%2F2017%2F07%2F12%2F%E8%AE%A2%E5%8D%95%E9%9C%80%E6%B1%82%E9%A2%84%E4%BC%B0%2F</url>
    <content type="text"><![CDATA[之前写了一篇以基于elastic的需求预估的文章，只不过用的是R语言开发的，最近在学python，就仿照逻辑写了一篇python的，主要修改点如下： 用决策树替换了elastic算法 用分层抽样替换了组合抽样 需要看详细理论及思考过程参考链接：商品需求预估 python code如下：123456789# -*- coding:utf-8 -*-import pandas as pdimport numpy as npimport random as rdfrom sklearn import tree# 读取数据data_orgin = pd.read_table(&quot;C:/Users/17031877/Desktop/supermarket_second_hair_washing_train.txt&quot;)data_deal_1 = data_orgin.drop([&apos;aimed_date&apos;, &apos;member_id&apos;, &apos;age&apos;, &apos;gender&apos;, &apos;diff_rgst&apos;], axis=1) 这边是常规的数据读取，删除了不必要的列 12345678910111213141516171819202122232425#因变量单列label = data_deal_1[&apos;label&apos;]# 用户分量级value00 = [&apos;max_date_diff&apos;, &apos;aimed_max_date_diff&apos;]data00 = data_deal_1[value00]value01 = [&apos;max_pay&apos;, &apos;per_pay&apos;, &apos;six_month_max_pay&apos;, &apos;six_month_per_pay&apos;, &apos;three_month_max_pay&apos;, &apos;three_month_per_pay&apos;, &apos;one_month_max_pay&apos;, &apos;one_month_per_pay&apos;, &apos;fifteen_day_max_pay&apos;, &apos;fifteen_day_per_pay&apos;, &apos;aimed_max_pay&apos;, &apos;aimed_per_pay&apos;, &apos;aimed_six_month_max_pay&apos;, &apos;aimed_six_month_per_pay&apos;, &apos;aimed_three_month_max_pay&apos;, &apos;aimed_three_month_per_pay&apos;, &apos;aimed_one_month_max_pay&apos;, &apos;aimed_one_month_per_pay&apos;, &apos;aimed_fifteen_day_max_pay&apos;, &apos;aimed_fifteen_day_per_pay&apos;, &apos;qty_drtn_seven&apos;, &apos;qty_drtn_fourteen&apos;]data01 = data_deal_1[value01]value02 = [&apos;cnt_time&apos;, &apos;six_month_cnt_time&apos;, &apos;three_month_cnt_time&apos;, &apos;one_month_cnt_time&apos;, &apos;fifteen_day_cnt_time&apos;, &apos;aimed_cnt_time&apos;, &apos;aimed_six_month_cnt_time&apos;, &apos;aimed_three_month_cnt_time&apos;, &apos;aimed_one_month_cnt_time&apos;, &apos;aimed_fifteen_day_cnt_time&apos;, &apos;pv_times_seven&apos;, &apos;pv_times_fourteen&apos;, &apos;search_times_seven&apos;, &apos;search_times_fourteen&apos;, &apos;clc_times_seven&apos;, &apos;clc_times_fourteen&apos;, &apos;cart2_times_seven&apos;, &apos;cart2_times_fourteen&apos;, &apos;cart1_times_seven&apos;, &apos;cart1_times_fourteen&apos;, &apos;unpay_times_seven&apos;, &apos;unpay_times_fourteen&apos;]data02 = data_deal_1[value02]value03 = [&apos;pv_visit_last_period&apos;, &apos;search_last_period&apos;, &apos;clc_last_period&apos;, &apos;cart2_last_period&apos;, &apos;cart1_last_period&apos;, &apos;unpay_last_period&apos;]data03 = data_deal_1[value03] 因为不同量级的数据之后做异常点处理的时候截断位置不同，所有需要分割数据处理 12345678910111213141516171819202122232425262728293031def test_function_one(x, l): k = x.dropna(how=&apos;any&apos;) y = k.quantile(l) z = k.max() x[x &gt; y] = y x = x.fillna(value=z) return xfor i in range(len(data00.columns)): data00.iloc[:, i] = test_function_one(data00.iloc[:, i], 0.98)def test_function_two(x, l): k = x.dropna(how=&apos;any&apos;) y = k.quantile(l) z = 0 x[x &gt; y] = y x = x.fillna(value=z) return xfor i in range(len(data01.columns)): data01.iloc[:, i] = test_function_two(data01.iloc[:, i], 0.95)for i in range(len(data02.columns)): data02.iloc[:, i] = test_function_two(data02.iloc[:, i], 0.99)def test_function_three(x): z = 14 x[x &gt; z] = z x = x.fillna(value=z) return xfor i in range(len(data03.columns)): data03.iloc[:, i] = test_function_three(data03.iloc[:, i])# 数据合并data_train = pd.concat([label, data00, data01, data02, data03], axis=1) 根据数据量的不同做数据分割，跑上面写完的code函数就可以 123456789#数量级对比zero_case = data_train[data_train[&apos;label&apos;] == 0][&apos;label&apos;].count()print &apos;负样本数：%d&apos; % zero_caseone_case = data_train[data_train[&apos;label&apos;] == 1][&apos;label&apos;].count()print &apos;正样本数: %d&apos; % (one_case)负样本数：292936正样本数: 3973Backend TkAgg is interactive backend. Turning interactive mode on. 实际看下来，正负样本的差异的确还是很大，这个其实做多了就有经验，常规的来看，潜在的浏览、搜索到最后的成单，普遍自然转化不到1%，也正是这么低的转化，才需要一些算法来做信息抓去。 12345678910111213141516171819202122def case_sample(x, y, z): diff_case = pd.DataFrame(x[y]).drop_duplicates([y]) result = [] result = pd.DataFrame(result) for i in range(len(diff_case)): k = np.array(diff_case)[i] data_set = x[x[y] == k[0]] nrow_nb = data_set.iloc[:, 0].count() data_set.index = range(nrow_nb) index_id = rd.sample(range(nrow_nb), int(nrow_nb * z)) result = pd.concat([result, data_set.iloc[index_id, :]], axis=0) return resultzero_case = data_train[data_train[&apos;label&apos;] == 0]one_case = data_train[data_train[&apos;label&apos;] == 1]# 开始分层抽样new_zero_case = case_sample(zero_case, &apos;unpay_last_period&apos;, 0.1)# 新数量级对比new_zero_case_count = new_zero_case[new_zero_case[&apos;label&apos;] == 0][&apos;label&apos;].count()# 数据集合并new_data_train = pd.concat([new_zero_case, one_case], axis=0) case_sample是一个简单的分层抽样的小函数，x是数据集，y是分层变量，z是抽样占比；新的样本new_data_train中正负样本比例在1:10左右，这边的样本比是我自己设置的，不一定是最合理的；且此处也不一定要求一定用分层抽样，只是我用来练练手的；推荐还是遵从奥卡姆原理，在未知的情况下，尽可能简单的解决问题，比如组合抽样就是很不错的方法。 123456789101112131415#函数设置clf = tree.DecisionTreeRegressor(criterion=&apos;mse&apos;, max_features=&apos;log2&apos;, random_state=1)#函数拟合y = new_data_train[&apos;label&apos;]x = new_data_train.drop(&apos;label&apos;, 1)clf.fit(x, y)#数据预测y_predict = clf.predict(x)# 结果对比y.index = range(len(y))combined_date = pd.concat([y, pd.DataFrame(y_predict)], axis=1)combined_date.columns = [&apos;actual&apos;, &apos;predict&apos;] 这边稍微讲解一下，我认为的sklearn中DecisionTreeRegressor中比较终于的参数设置，criterion这边为模型优化的标准，常规的有mse和mae，建议在数据量差异不大的时候多考虑mse；max_features是每次训练用的特征个数，综合特征量级考虑，一般有log2，sqrt，尽可能是抽取比例在70%；max_depth刚开始可以默认，第一类模型出来后，可在结果附近迭代，寻找out of bag最小的error下的值；另外，我没有发现有weight设置，可能是我不熟悉，但是如果sklearn这边不提供weight的化，我们在做数据预处理的时候一定要平衡数据，不然当数据集过偏的时候最后的结果会以“牺牲”少类的判断正确率去完善整体正确率。 123456789101112131415# case 1x = []y = []for i in range(1, 10): test_data = combined_date i = i / float(10) for j in range(combined_date[&apos;actual&apos;].count()): if test_data.iloc[j, 1] &gt; i: test_data.iloc[j, 1] = 1 else: continue z = test_data[test_data[&apos;actual&apos;] == test_data[&apos;predict&apos;]][&apos;actual&apos;].count() / float(test_data[&apos;actual&apos;].count()) x.append(i) y.append(z) 这边写了检查函数，检查了分别0.1~1，以0.1为间隔的情况下的分割点，每个分割点下预测正确的数量/所有统计的样本数，也就是下面的accuracy. 12345678# case 2test_data = combined_dateaimed_data = test_data[test_data[&apos;predict&apos;]&gt;0]k1=aimed_data[aimed_data[&apos;actual&apos;]==1][&apos;predict&apos;].count()k2=float(aimed_data[&apos;predict&apos;].count())print &apos;所有预测可能下单用户中真实下单用户数：%d&apos; %(k1)print &apos;所有预测可能下单用户数：%d&apos; %(k2) 因为这边需要对用户营销，所以更关系topN的转化率，需要看一下实际正样本被覆盖了多数，以上即为code，这边的效果值为98.7%，还是比较高的，但是应该是过拟合了，所有一般不建议单纯使用决策树模型 所有的python code到这里就结束了，后续我做项目的同时会同时更新R及python两种code的思考，和大家讨论分享学习，谢谢。 参考文献： sklearn.tree.DecisionTreeRegressor 维基百科中对ROC的介绍 决策树常见问题及面试关键点介绍]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>预测</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐系统-威尔逊区间法]]></title>
    <url>%2F2017%2F06%2F21%2F%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F-%E5%A8%81%E5%B0%94%E9%80%8A%E5%8C%BA%E9%97%B4%E6%B3%95%2F</url>
    <content type="text"><![CDATA[我推荐一种之前在惠普做过一种排序方法：威尔逊区间法 我们先做如下设定： （1）每个用户的打分都是独立事件。 （2）用户只有两个选择，要么投喜欢’1’，要么投不喜欢’0’。 （3）如果总人数为n，其中喜欢的为k，那么喜欢的比例p就等于k/n。 这是一种统计分布，叫做”二项分布”（binomial distribution） 理论上讲，p越大应该越好，但是n的不同，导致p的可信性有差异。100个人投票，50个人投喜欢；10个人投票，6个人喜欢，我们不能说后者比前者要好。 所以这边同时要考虑（p，n） 刚才说满足二项分布，这里p可以看作”二项分布”中某个事件的发生概率，因此我们可以计算出p的置信区间。 所谓”置信区间”，就是说，以某个概率而言，p会落在的那个区间。 置信区间展现的是这个参数的真实值有一定概率落在测量结果的周围的程度。置信区间给出的是被测量参数的测量值的可信程度，即前面所要求的“一个概率”，也就是结论的可信程度。 二项分布的置信区间有多种计算公式，最常见的是”正态区间”（Normal approximation interval）。但是，它只适用于样本较多的情况（np &gt; 5 且 n(1 − p) &gt; 5），对于小样本，它的准确性很差。 这边，我推荐用t检验来衡量小样本的数据，可以解决数据过少准确率不高的问题。 这样一来，排名算法就比较清晰了： 第一步，计算每个case的p（好评率）。 第二步，计算每个”好评率”的置信区间（参考z Test或者t Test，以95%的概率来处理）。 第三步，根据置信区间的下限值，进行排名。这个值越大，排名就越高。 解释一下，n为评价数，p为好评率，z为对应检验对应概率区间下的统计量 比如t-分布： 可以看到，当n的值足够大时，这个下限值会趋向p，如果n非常小，这个下限值会大大小于p，更加符合实际。 Reddit的评论排名，目前就使用这个算法。国内的化，滴滴也有部分业务涉及，效果也不错。 更新一下，没想到这个话题还是有高达9个人关注，所以这边我再说一些更细化的过程吧 在计算排名的时候，我们通常会考虑三个事情 1.上文讲到的，次数+好评率的分布，次数越多好评率越可靠，好评率越高该项越值得推荐 2.时间因素，如果一个项目是10天前推送的，一个项目是昨天推送的，很明显前者的次数远大于后者 3.影响权重，你这边只考虑了喜欢和不喜欢，其实所有的排序不可能只以1个维度考虑，通常会考虑多个维度，比如浏览次数，搜索次数等，你需要考虑每个的重要性或者说权重大小 1这里就不讲了，其他方法也有很多，比如贝叶斯平均的优化版本、再比如经典的Hacker公式： 2.时间因素： 时间越久，代表之前的投票结果对当前的影响越小，这边有很多不同的影响方式，举几个例子： 比如艾宾浩斯遗忘规律： 这里的c、k决定下降速度，业务运用过程中，c值一般在[1,2],k值一般在[1.5,2.5] 比如时效衰减： 这里就是比较常见的移动窗口式的，永远只看近期某一段时间，而且时间内呈线性下降，不过可以改变变化方式 3.不同种的属性对于结果的影响自然不同 举个例子，用户主动搜索和用户浏览相比，用户主动搜索的情况下，用户的需求更为强烈 通常需要判断这些强烈程度都是通过： 相关性：看因变量与自变量之间的相关系数，如：cor函数 importance：看删除或者修改自变量，对应变量的判断影响大小，如：randomForest的重要性 离散程度：看自变量的数据分布是否足够分散，是否具有判断依据，如：变异系数或者pca 等等]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[协同过滤推荐]]></title>
    <url>%2F2017%2F06%2F21%2F%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[set.seed ( 1234 ) 加载数据包library ( “recommenderlab” ) 构造数据运用recommenderlab包实现协同过滤推荐，其数据类型采用S4类构造，需通过as()函数转为raringMatrix类型。val1&lt;- matrix ( sample ( c ( as.numeric ( 0 : 5 ) ,NA ) ,50 ,replace = TRUE ,prob = c ( rep ( .4 / 6 , 6 ) , .6 ) ) ,ncol = 10 , dimnames = list ( user = paste ( “u” ,1 : 5 ,sep = ‘’ ) ,item = paste ( “i” ,1 : 10 ,sep = ‘’ ) ) ) val2 &lt;- as ( val1, “realRatingMatrix” ) 数据转换 val3&lt;- normalize ( val2 ) 二元分类转换，normalize()函数进行标准化处理，标准化的目的是为了去除用户评分的偏差val4 &lt;- binarize ( val3 , minRating = 4 ) val5 &lt;- as ( val4 , “matrix” ) 数据可视化 接下来，我们采用MovieLense数据集， data ( MovieLense ) key1 &lt;- sample ( MovieLense , 943 , replace = F )image ( MovieLense ) hist ( getRatings ( normalize ( MovieLense ) ) , breaks = 100 ) hist ( rowCounts ( key1 ) , breaks = 50 ) 建立模型 对于realRatingMatrix有六种方法：IBCF(基于物品的推荐)、UBCF（基于用户的推荐）、PCA（主成分分析）、RANDOM（随机推荐）、SVD（矩阵因子化）、POPULAR（基于流行度的推荐） 建立协同过滤推荐算法模型，主要运用recommender(data=ratingMatrix,method,parameter=NULL)函数，getModel()可查看模型参数 key1_recom &lt;- Recommender (key1 , method = “IBCF” ) key1_popul &lt;- Recommender ( key1, method = “POPULAR” ) 查看模型方法names ( getModel ( key1_recom ) ) 模型预测 TOP-N预测 对模型预测可运用predict()函数，在此分别以TOP-N预测及评分预测为例，预测第940-943位观影者的评分情况。n表示最终为TOP-N的列表推荐，参数type = “ratings”表示运用评分预测观影者对电影评分，模型结果均需转为list或矩阵表示 pred &lt;- predict ( key1_popul ,key1 [ 940 : 943,] , n = 5 ) as ( pred , “list” ) top-N为有序列表，抽取最优推荐子集pred3 &lt;- bestN ( pred , n = 3 ) as ( pred3 , “list” ) 评分预测rate &lt;- predict ( key1_popul , key1 [ 940 : 943 ] , type = “ratings” ) as ( rate , “matrix” ) [ , 1 : 5 ] 预测模型评价 评分预测模型评价 eva &lt;- evaluationScheme (key1 [ 1 : 800 ] , method = “split” , train = 0.9,given = 15)method=”split”&amp;train=0.9为按90%划分训练测试集合,given为评价的类目数 r_eva1&lt;- Recommender ( getData ( eva , “train” ) , “UBCF” ) p_eva1&lt;- predict ( r_eva1 , getData ( eva, “known” ) , type = “ratings” ) r_eva2 &lt;- Recommender ( getData ( eva, “train” ) , “IBCF” ) p_eva2 &lt;- predict ( r_eva2 , getData ( eva, “known” ) , type = “ratings” )c_eva1 &lt;- calcPredictionAccuracy ( p_eva1 , getData ( eva , “unknown” ) ) c_eva2 &lt;- calcPredictionAccuracy ( p_eva2 , getData ( eva , “unknown” ) ) error &lt;- rbind ( c_eva1 , c_eva2 ) rownames ( error ) &lt;- c ( “UBCF” , “IBCF” )计算预测模型的准确度 TOP-N预测模型评价 通过4-fold交叉验证方法分割数据集，运用evaluate()进行TOP-N预测模型评价,评价结果可通过ROC曲线及准确率-召回率曲线展示: 4-fold交叉验证tops &lt;- evaluationScheme ( key1 [ 1 : 800 ] , method = “cross” , k = 4 , given = 3 ,goodRating = 5 ) results &lt;- evaluate ( tops , method = “POPULAR” , type = “topNList” ,n = c ( 1 , 3 , 5 , 10 ) ) 获得混淆矩阵getConfusionMatrix ( results ) [ [ 1 ] ] avg ( results ) 推荐算法的比较 除了对预测模型进行评价，还可以对不同推荐算法进行比较。可首先构建一个推荐算法列表，通过ROC曲线、、准确率-召回率曲线或RMSE直方图进行比较 TOP-N算法比较 set.seed ( 2016 ) scheme &lt;- evaluationScheme ( key1 , method = “split” , train = 0.9 , k = 1 , given = 10 , goodRating = 5 ) 构建不同算法模型results &lt;- evaluate ( scheme ,test_data ,n = c ( 1 ,3 ,5 ,10 ,15 ,20 ) ) 模型比较#ROC曲线plot ( results , annotate = c ( 1 , 3 ) , legend = “bottomright” ) 准确率-召回率曲线plot ( results , “prec/rec” , annotate = c ( 2 , 3 , 4 ) , legend = “topleft” ) 预测评分算法比较 results2 &lt;- evaluate ( scheme , algorithms , type = “ratings” ) plot ( results2 , ylim = c ( 0 , 20 ) )]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聚类算法思路总结]]></title>
    <url>%2F2017%2F06%2F20%2F%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1.cost function 1.1 距离 常见的为欧式距离（L1 norm）&amp;&amp;p=2，拓展的可以有闵可夫斯基距离（L2 norm）&amp;&amp;p=1： 当p趋向于无穷的时候，切比雪夫距离（Chebyshev distance）： 红色的时候为切比雪夫距离，蓝色为闵可夫斯基距离，绿色为欧式距离。 1.2相似系数 夹角余弦及相关系数，相关系数不受线性变换的影响，但是计算速度远慢于距离计算。 1.3dynamic time warping动态时间规整 举例子： 序列A：1,1,1,10,2,3，序列B：1,1,1,2,10,3 欧式距离：distance[i][j]=(b[j]-a[i])*(b[j]-a[i])来计算的话，总的距离和应该是128 应该说这个距离是非常大的，而实际上这个序列的图像是十分相似的。因为序列A中的10对应得是B中的2，A中的2对应的B中的10，导致计算膨胀，现在将A中的10对应B中的10，A中的1对应B中的2再计算，膨胀因素会小很多（时间前推一步）。 2.聚类算法 2.1分层聚类： 自上而下：所有点先聚为一类，然后分层次的一步一步筛出与当前类别差异最大的点 自下而上：所有点先各自为一类，组合成n个类的集合，然后寻找出最靠近的两者聚为新的一类，循环往复 数值类分类：（适用于计算量巨大或者数据量巨大的时候） BIRCH算法，层次平衡迭代规约和聚类， 主要参数包含：聚类特征和聚类特征树： 聚类特征： 给定N个d维的数据点{x1,x2,….,xn}，CF定义如下：CF=（N，LS，SS）,其中，N为子类中的节点的个数，LS是子类中的N个节点的线性和，SS是N个节点的平方和 存在计算定义：CF1+CF2=（n1+n2, LS1+LS2, SS1+SS2） 假设簇C1中有三个数据点：（2,3），（4,5），（5,6），则CF1={3，（2+4+5,3+5+6），（2^2+4^2+5^2,3^2+5^2+6^2）}={3，（11,14），（45,70）} 假设一个簇中，存在质心C和半径R，若有xi，i=1…n个点属于该簇，质心为：C=(X1+X2+…+Xn)/n，R=(|X1-C|^2+|X2-C|^2+…+|Xn-C|^2)/n 其中，簇半径表示簇中所有点到簇质心的平均距离。当有一个新点加入的时候，属性会变成CF=（N，LS，SS）的统计值，会压缩数据。 聚类特征树： 内节点的平衡因子B，子节点的平衡因子L，簇半径T。 B=6，深度为3，T为每个子节点中簇的范围最大不能超过的值，T越大簇越少，T越小簇越多。 名义分类： ROCK算法：凝聚型的层次聚类算法 1.如果两个样本点的相似度达到了阈值（θ），这两个样本点就是邻居。阈值（θ）有用户指定，相似度也是通过用户指定的相似度函数计算。常用的分类属性的相似度计算方法有：Jaccard系数，余弦相似度 Jaccard系数：J=|A∩B|/|A∪B|，一般用于分类变量之间的相似度 余弦相似度：【-1，1】之间，越趋近于0的时候，方向越一致，越趋向同一。 2.目标函数（criterion function）：最终簇之间的链接总数最小，而簇内的链接总数最大 3.相似度合并：遵循最终簇之间的链接总数最小，而簇内的链接总数最大的规则计算所有对象的两两相似度，将相似性最高的两个对象合并。通过该相似性度量不断的凝聚对象至k个簇，最终计算上面目标函数值必然是最大的。 load(‘country.RData’) d&lt;-dist(countries[,-1]) x&lt;-as.matrix(d) library(cba) rc &lt;-rockCluster(x, n=4, theta=0.2, debug=TRUE) KNN算法： 先确定K的大小，计算出每个点之外的所有点到这个目标点的距离，选出K个最近的作为一类。一般类别之间的归类的话，投票和加权为常用的，投票及少数服从多数，投票的及越靠近的点赋予越大的权重值。 2.2分隔聚类： 需要先确定分成的类数，在根据类内的点都足够近，类间的点都足够远的目标去做迭代。 常用的有K-means，K-medoids，K-modes等，只能针对数值类的分类，且只能对中等量级数据划分，只能对凸函数进行聚类，凹函数效果很差。 2.3密度聚类： 有效的避免了对分隔聚类下对凹函数聚类效果不好的情况，有效的判别入参主要有1:单点外的半径2：单点外半径内包含的点的个数 DBSCAN为主要常见的算法，可优化的角度是现在密度较高的地方进行聚类，再往密度较低的地方衍生，优化算法：OPTICS。 2.4网格聚类： 将n个点映射到n维上，在不同的网格中，计算点的密度，将点更加密集的网格归为一类。 优点是：超快，超级快，不论多少数据，计算速度只和维度相关。 缺点：n维的n难取，受分布影响较大（部分行业数据分布及其不规则） 2.5模型聚类： 基于概率和神经网络聚类，常见的为GMM，高斯混合模型。缺点为，计算量较大，效率较低。 GMM：每个点出现的概率：将k个高斯模型混合在一起，每个点出现的概率是几个高斯混合的结果 假设有K个高斯分布，每个高斯对data points的影响因子为πk，数据点为x，高斯参数为theta，则： 利用极大似然的方法去求解均值Uk，协方差矩阵（Σk），影响因子πk，但是普通的梯度下降的方法在这里求解会很麻烦，这边就以EM算法代替估计求解。 3.优化数据结构： 1.数据变换： logit处理，对所有数据进行log变换 傅里叶变换 小波变换 2.降维： PCA： 利用降维（线性变换)的思想，整体方差最大的情况下（在损失很少信息的前提下），把多个指标转化为几个不相关的综合指标（主成分),将变量线性组合代替原变量，保持代替后的数据信息量最大（方差最大）。 LLE： (1) 寻找每个样本点的k个近邻点； (2)由每个样本点的近邻点计算出该样本点的局部重建权值矩阵； (3)由该样本点的局部重建权值矩阵和其近邻点计算出该样本点的输出值。 (换句话说，就是由周围N个点构成改点的一个向量矩阵表示）]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>聚类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用R语言包介绍]]></title>
    <url>%2F2017%2F06%2F19%2F%E5%B8%B8%E7%94%A8R%E8%AF%AD%E8%A8%80%E5%8C%85%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[r与python差异比较大的一个地方就是，python的机器学习算法集中程度比较高，比如sklearn，就集成了很多的算法，而R语言更多时候需要一个包一个包去了解，比较费时费力，对于python转过来的朋友非常不友好，抽空整理了工作中常用的R包如下： 常用检验函数： 基本上分布中常见的都罗列了： 常用作图函数包： ggplot2：万能，基本上excel能画的图它都能画 rattle：fancyRpartPlot函数，决策树画图函数 基础包函数：barplot、pie、dotchart、hist、densityplot、boxplot、contour等等 正态检验：qqplot、qqline、qqnorm 连续分类回归模型： stats包 lm函数，实现多元线性回归；glm函数，实现广义线性回归；nls函数，实现非线性最小二乘回归；knn函数，k最近邻算法 rpart包 rpart函数，基于CART算法的分类回归树模型 randomForest包 randomForest函数，基于rpart算法的集成算法 e1071包 svm函数，支持向量机算法 kernlab包 ksvm函数，基于核函数的支持向量机 nnet包 nnet函数，单隐藏层的神经网络算法 neuralnet包 neuralnet函数，多隐藏层多节点的神经网络算法 RSNNS包 mlp函数，多层感知器神经网络；rbf函数，基于径向基函数的神经网络 离散分类回归模型： stats包 glm函数，实现Logistic回归，选择logit连接函数 kknn包 kknn函数，加权的k最近邻算法 rpart包 rpart函数，基于CART算法的分类回归树模型 adabag包bagging函数，基于rpart算法的集成算法；boosting函数，基于rpart算法的集成算法 party包ctree函数，条件分类树算法 RWeka包OneR函数，一维的学习规则算法；JPip函数，多维的学习规则算法；J48函数，基于C4.5算法的决策树 C50包C5.0函数，基于C5.0算法的决策树 e1071包naiveBayes函数，贝叶斯分类器算法 klaR包NaiveBayes函数，贝叶斯分类器算分 MASS包lda函数，线性判别分析；qda函数，二次判别分析 聚类：Nbclust包Nbclust函数可以确定应该聚为几类 stats包kmeans函数，k均值聚类算法；hclust函数，层次聚类算法 cluster包pam函数，k中心点聚类算法 fpc包dbscan函数，密度聚类算法；kmeansruns函数，相比于kmeans函数更加稳定，而且还可以估计聚为几类；pamk函数，相比于pam函数，可以给出参考的聚类个数 mclust包Mclust函数，期望最大（EM）算法 关联规则：arules包apriori函数 Apriori关联规则算法 recommenderlab协调过滤 DRM：重复关联 ECLAT算法： 采用等价类，RST深度搜索和集合的交集： eclat 降维算法： psych包prcomp函数、factanal函数 时序分析： ts时序构建函数 timsac包时序分析 holtwinter包时序分析 decomp、tsr、stl成分分解 zoo 时间序列数据的预处理 统计及预处理： 常用的包 Base R, nlme aov, anova 方差分析 density 密度分析 t.test, prop.test, anova, aov:假设检验 rootSolve非线性求根 reshape2数据预处理 plyr及dplyr数据预处理大杀器 最后剩下常用的就是读入和写出了： RODBC 连接ODBC数据库接口 jsonlite 读写json文件 yaml 读写yaml文件 rmakdown写文档 knitr自动文档生成 一般业务中使用比较多的就是上面这些了，当然R里面有很多冷门的包，也很好用滴~]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>R语言工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[决策树及衍射指标]]></title>
    <url>%2F2017%2F06%2F02%2F%E5%86%B3%E7%AD%96%E6%A0%91%E5%8F%8A%E8%A1%8D%E5%B0%84%E6%8C%87%E6%A0%87%2F</url>
    <content type="text"><![CDATA[一、常用的决策树节点枝剪的衡量指标： 熵： 如果一件事有k种可的结果，每种结果的概率为 pi（i＝1…k） 该事情的信息量： 熵越大，随机变量的不确定性越大。 信息增益： 特征A对训练数据集D的信息增益g(D,A)，定义为集合D的经验熵H(D)与特征A给定条件下的经验条件熵H(D|A)之差 换句话说，就是原信息集下的信息量－在A特征条件下的信息集的信息量 信息增益越大，信息增多，不确定性减小 信息增益率： 信息增益率定义:特征A对训练数据集D的信息增益比定义为其信息增益与训练数据D关于特征A的值的熵HA(D)之比 注：p：每个唯独上，每个变量的个数／总变量个数 二、常用的决策树介绍： ID3算法： ID3算法的核心是在决策树各个子节点上应用信息增益准则选择特征，递归的构建决策树，具体方法是:从根节点开始，对节点计算所有可能的特征的信息增益，选择信息增益最大的特征作为节点的特征，由该特征的不同取值建立子节点；再对子节点递归调用以上方法，构建决策树。 解释：在做每次选择差分枝的时候，以不确定性最小点作为loss fuction，直到无法细分 缺点： 1.ID3算法只有树的生成，所以该算法生成的树容易产生过拟合，分得太细，考虑条件太多。 2.不能处理连续属性 3.选择具有较多分枝的属性，而分枝多的属性不一定是最优的选择。 4.局部最优化，整体熵值最小，贪心算法算子节点的分支 C4.5算法： 基于ID3算法，用信息增益比来选择属性，对非离散数据也能处理，能够对不完整数据进行处理。 采用增益率（GainRate）来选择分裂属性。计算方式如下： CART算法： CART算法选择分裂属性的方式是比较有意思的，首先计算不纯度，然后利用不纯度计算Gini指标。 计算每个子集最小的Gini指标作为分裂指标。 不纯度的计算方式为： pi表示按某个变量划分中，目标变量不同类别的概率。 某个自变量的Gini指标的计算方式如下： 计算出每个每个子集的Gini指标，选取其中最小的Gini指标作为树的分支（Gini（D）越小，则数据集D的纯度越高）。连续型变量的离散方式与信息增益中的离散方式相同。 三、基于决策树的一些集成算法： 随机森林： 随机生成n颗树，树之间不存在关联，取结果的时候，以众数衡量分类结果；除了分类，变量分析，无监督学习，离群点分析也可以。 生成过程： 1.n个样本，随机选择n个样本（有放回），训练一颗树 从原始训练数据集中,应用bootstrap方法有放回地随机抽取 K个新的自助样本集,并由此构建 K棵分类回归树,每次未被抽到的样本组成了 K个袋外数据(Out-of-bag,OOB) 2.每个样本有M个属性，随机选m个，采取校验函数（比如信息增益、熵啊之类的），选择最佳分类点 3.注意，每个树不存在枝剪 4.将生成的多棵树组成随机森林,用随机森林对新的数据进行分类,分类结果按树分类器的投票多少而定 树的个数随机选取，一般500，看三个误差函数是否收敛；变量的个数一般取均方作为mtry GBDT： DT步骤： GBDT里面的树是回归树！ GBDT做每个节点上的分支的时候，都会以最小均方误差作为衡量（真实值－预测值）的平方和／N，换句话说，就是存在真实线l1，预测线l2，两条线之间的间距越小越好。 BT步骤： GBDT的核心就在于，每一棵树学的是之前所有树结论和的残差，这个残差就是一个加预测值后能得真实值的累加量。 换句话说，就是第一次预测的差值记为下一次预测的初始值，一直到某一次计算出的差值为0，把前n次的结果相加，就是一个真实预测。 Adaboost： 步骤： 1.初始化所有训练样例的权重为1 / N,其中N是样本数 2.对其中第1~m个样本: a.训练m个弱分类器，使其最小化bias： b.接下来计算该弱分类器的权重α，降低错判的分类器的权重，： c.更新权重： 3.最后得到组合分类器： 核心的思想如下图： 全量数据集在若干次训练后，降低训练正确的样本的权重，提高训练错误样本的权重，得到若干个Y对应的分类器，在组合投票得到最终的分类器 四、惠普实验室-集成并行化的随机森林：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树划分问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[因子分析原理剖析]]></title>
    <url>%2F2017%2F06%2F02%2F%E5%9B%A0%E5%AD%90%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%2F</url>
    <content type="text"><![CDATA[因子分析概述： 因子分析分为Q型和R型，我们对R型进行如下研究： 一.因子分析步骤： 1.确认是是否适合做因子分析 2.构造因子变量 3.旋转方法解释 4.计算因子变量得分 二.因子分析的计算过程： 1.将原始数据标准化 目的：消除数量级量纲不同 2.求标准化数据的相关矩阵 3.求相关矩阵的特征值和特征向量 4.计算方差贡献率和累计方差贡献率 5.确定因子 F1,F2,F3…为前m个因子包含数据总量（累计贡献率）不低于80%。可取前m各因子来反映原评价 6.因子旋转 当所得因子不足以明显确定或不易理解时选择此方法 7.原指标的线性组合求各因子的得分 两种方法：回归估计和barlett估计法 8.综合得分：以各因子的方差贡献率为权，各因子的线性组合得到各综合评价指标函数 F=（λ1F1+…λmFm）/(λ1+…λm) =W1F1+…WmFm 9.得分排序 因子分析详解： 因子分析模型，又名正交因子模型 X=AF+ɛ 其中： X=[X1,X2,X3…XP]‘ A= F=[F1,F2…Fm]’ ɛ=[ɛ1,ɛ2…ɛp]’ 以上满足： （1）m小于等于p （2）cov(F,ɛ)=0 (3)Var(F)=Im D(ɛ)=Var(ɛ)= ɛ1,ɛ2…ɛp不相关，且方差不同 我们把F成为X公共因子，A为荷载矩阵，ɛ为X特殊因子 A=(aij) 数学上证明：aij就是i个变量与第j个因子的相关系数，参见层次分析法aij定义。 荷载矩阵 就荷载矩阵的估计和解释方法有主因子和极大似然估计，我们就主因子分析而言：（是主因子不是主成份） 设随机向量X的协方差阵为Ʃ λ1,λ2,λ3..&gt;0为Ʃ的特征根 μ1，μ2，μ3…为对应的标准正交向量 我们大一学过线代或者高代，里面有个东西叫谱分析： Ʃ=λ1μ1μ1’+……+λpμpμp’ = 当因子个数和变量个数一样多，特殊因子方差为0. 此时，模型为X=AF,其中Var(F)=Ip 于是，Var(X)=Var(AF)=AVar(F)A’=AA’ 对照Ʃ分解式,A第j列应该是 也就是说，除了uj前面部分，第j列因子签好为第j个主成份的系数，所以为主成份法。 如果非要作死考虑ɛ 原来的协方差阵可以分解为： Ʃ=AA’+D= 以上分析的目的； 1.因子分析模型是描述原变量X的协方差阵Ʃ的一种模型 2.主成份分析中每个主成份相应系数是唯一确定的，然而因子分析中的每个因子的相应系数不是唯一的，因而我们的因子荷载矩阵不是唯一的 (主成分分析是因子分析的特例，非常类似，有兴趣的可以去看看，这两者非常容易混淆) 共同度和方差贡献 无论是在spss或者R的因子分析中都围绕着贡献度，我们来看下，它到底是什么意思。 由因子分析模型，当仅有一个公因子F时， Var(Xi)=Var(aiF)+Var(ɛi) 由于数据标准化，左端为1，右端分别为共性方差和个性方差 共性方差越大，说明共性因子作用越大。 因子载荷矩阵A中的第i行元素之平方和记为hi2 成为变量(Xi)共同度 它是公共因子对(Xi)的方差锁做出的贡献，反映了全部公共因子对变量(Xi)的影响。 hi2大表明第i个分量对F的每一个分量F1,F2,…Fm的共同依赖程度大 将因子载荷矩阵A的第j列的各元素的平方和记为gj2 成为公共因子Fj对x的方差贡献。 gj2表示第j个公共因子Fj对x的每一个分量Xi所提供的方差的总和，他就是衡量公共因子的相对重要行的指标。gj2越大，表明公共因子Fj对x的贡献越大，或者说对x的影响和作用就越大。 如果将载荷矩阵A的所有gj2都计算出来，按大小排列，就可以提炼最有影响力的公共因子。 因子旋转 这方面涉及较为简单，我就简单提一下 目的：建立因子分析模型不是只要找主因子，更加重要的是意义，以便对实际进行分析，因子旋转就是使所得结论更加清晰的表示。 方法：正交旋转，斜交旋转两大类，常用正交。 便于理解，我解释下旋转的意义，以平面直角坐标系为例，我们想得到的数据正好为：y=x和y=-x上的点，我们能解释的却在x=0和y=0上，这时候我们就可以旋转坐标系，却不影响结果。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>因子分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则化-Lasso规约]]></title>
    <url>%2F2017%2F06%2F02%2F%E6%AD%A3%E5%88%99%E5%8C%96-Lasso%E8%A7%84%E7%BA%A6%2F</url>
    <content type="text"><![CDATA[摘要：lasso的目的主要是避免数据拟合过渡，导致训练数据效果优秀，测试数据效果较差 先看一波过拟合： 图中，红色的线存在明显的过拟合，绿色的线才是合理的拟合曲线，为了避免过拟合，我们可以引入正则化。 下面可以利用正则化来解决曲线拟合过程中的过拟合发生，存在均方根误差也叫标准误差，即为√[∑di^2/n]=Re，n为测量次数；di为一组测量值与真值的偏差。 实际考虑回归的过程中，我们需要考虑到误差项， 这个和简单的线性回归的公式相似，而在正则化下来优化过拟合这件事情的时候，会加入一个约束条件，也就是惩罚函数： 这边这个惩罚函数有多种形式，比较常用的有l1,l2，大概有如下几种： 讲一下比较常用的两种情况，q＝1和q＝2的情况：q＝1，也就是今天想讲的lasso回归，为什么lasso可以控制过拟合呢，因为在数据训练的过程中，可能有几百个，或者几千个变量，再过多的变量衡量目标函数的因变量的时候，可能造成结果的过度解释，而通过q＝1下的惩罚函数来限制变量个数的情况，可以优先筛选掉一些不是特别重要的变量，见下图： 作图只要不是特殊情况下与正方形的边相切，一定是与某个顶点优先相交，那必然存在横纵坐标轴中的一个系数为0，起到对变量的筛选的作用。q＝2的时候，其实就可以看作是上面这个蓝色的圆，在这个圆的限制下，点可以是圆上的任意一点，所以q＝2的时候也叫做岭回归，岭回归是起不到压缩变量的作用的，在这个图里也是可以看出来的。 lasso回归：lasso回归的特色就是在建立广义线型模型的时候，这里广义线型模型包含一维连续因变量、多维连续因变量、非负次数因变量、二元离散因变量、多元离散因变，除此之外，无论因变量是连续的还是离散的，lasso都能处理，总的来说，lasso对于数据的要求是极其低的，所以应用程度较广；除此之外，lasso还能够对变量进行筛选和对模型的复杂程度进行降低。这里的变量筛选是指不把所有的变量都放入模型中进行拟合，而是有选择的把变量放入模型从而得到更好的性能参数。 复杂度调整是指通过一系列参数控制模型的复杂度，从而避免过度拟合(Overfitting)。 对于线性模型来说，复杂度与模型的变量数有直接关系，变量数越多，模型复杂度就越高。 更多的变量在拟合时往往可以给出一个看似更好的模型，但是同时也面临过度拟合的危险。lasso的复杂程度由λ来控制，λ越大对变量较多的线性模型的惩罚力度就越大，从而最终获得一个变量较少的模型。除此之外，另一个参数α来控制应对高相关性(highly correlated)数据时模型的性状。 lasso回归α=1，Ridge回归α=0，这就对应了惩罚函数的形式和目的。我们可以通过尝试若干次不同值下的λ，来选取最优λ下的参数，还可以结合CV选择最优秀的模型。 ######读取数据123456789101112setwd(&quot;~/Desktop&quot;)library(glmnet)train_origin&lt;-read.table(&apos;trian.txt&apos;,header = T,fill = T)test_origin&lt;-read.table(&apos;test.txt&apos;,header = T,fill = T)train_test1&lt;-train_origintrain_test1&lt;-train_test1[,-9]train_test1$tag&lt;-as.factor(train_test1$tag)train_test1$risk_level&lt;-as.factor(train_test1$risk_level)x&lt;-train_test1[,3:11]y&lt;-train_test1[,2]## one hot encodingx1&lt;-model.matrix(~., x) 通常数据中会存在离散点，而lasso在R里面是通过数值矩阵来做输入的，所以需要对原数据做一步预处理，不然这边会抛错误；除此之外，如果数据之间差别的数量级较大，还需要进行标准化，R里面也是可以进行处理的，这边就不赘述了，glmnet()函数中添加参数standardize = TRUE来实现，scale()函数也可以实现，自行选择即可。 ######模型训练1model = glmnet(x1, y, family=&quot;binomial&quot;, nlambda=50, alpha=1) family里面是指选择函数的类型：family explation,gaussian univariate,mgaussian multivariate,poisson count,binomial binary,multinomial categorylambda是指随机选择λ，做lambda个模型；alpha是上述讲到的α，选择惩罚函数，正常情况下，1是lasso，0是岭回归这边模型拓展可以交叉检验一下，有内置的函数：cvmodel = cv.glmnet(x1, y, family = “binomial”, type.measure = “class”,nfolds=10)这边会多出来一个type.measure，这个type.measure是指期望最小化的目标参量是什么，换句话说，就是衡量这个模型的指标函数是啥：type.measure detailsdeviance: -2倍的Log-likelihoodmse:mean squred errormae:mean absolute errorclass:missclassification errorauc:area under the ROC curve比较常用的是auc，这个就是现在比较主流的衡量一个模型好坏的roc所衍生出来的一个值；我们这边用的是class，也就是模型错误分配的概率，结合我这次业务开发的实际业务场景，这个更合适一点；nfolds是指folds数目，也可以通过foldid数来控制每个fold里面的数据数量。对于glmnet，可以通过plot(model)来观察每个自变量的变化轨迹，cv.glmnet可以通过plot(cvmodel)举个plot(cvmodel)的例子： 可以通过c(cvfit$lambda.min, cvfit$lambda.1se)来看在所有的λ值中，得到最小目标函数type.measure均值的cvfit$lambda.min，以及其所对应的λ值可接受的一个标准误差之内对应的cvfit$lambda.1se。我们可以print(model)，在实际的选择模型中λ值的过程里，存在三个指标：df：自由度， %Dev：残差被解释的占比，也就是模型的好坏程度，类似于线性模型中的R平方，Lambda也就是λ值所对应的值，然后我们可以通过coef(fit, s=c(fit$lambda[35],0.002))得出当时模型所对应的系数。 最后，讲一下elastic netelastic net融合了l1范数和l2范数两种正则化的方法，上面的岭回归和lasso回归都可以看做它的特例： elastic net对于p远大于n,或者严重的多重共线性情况有明显的效果，很好理解，当alpha接近1时，elastic net表现很接近lasso，一般来说，elastic net是岭回归和lasso的很好的折中，当alpha从0变化到1，目标函数的稀疏解（部分变量的系数为0）也从0单调增加到lasso的稀疏解。 特征规约初步总结如下：1）子集选择 这是传统的方法，包括逐步回归和最优子集法等，对可能的部分子集拟合线性模型，利用判别准则 （如AIC,BIC,Cp,调整R2 等）决定最优的模型2）收缩方法（shrinkage method） 收缩方法又称为正则化（regularization）。主要是岭回归（ridge regression）和lasso回归。通过对最小二乘估计加入罚约束，使某些系数的估计为0。（岭回归：消除共线性；模的平方处理；Lasso回归：压缩变量，起降维作用；模处理）(3)维数缩减 主成分回归（PCR）和偏最小二乘回归（PLS）的方法。把p个预测变量投影到m维空间 部分图片转载于：http://bbs.pinggu.org/thread-3848519-1-1.html]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>正则化问题</tag>
      </tags>
  </entry>
</search>
