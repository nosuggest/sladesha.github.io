<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[博客导读公告(置顶)]]></title>
    <url>%2F2029%2F01%2F20%2F%E5%8D%9A%E5%AE%A2%E5%AF%BC%E8%AF%BB%E5%85%AC%E5%91%8A%2F</url>
    <content type="text"><![CDATA[首先，我很荣幸您出现在我的个人博客，下面请允许我花费您3分钟左右的时间，简单的为您介绍一下博客中的相关功能，这将极大的提高您在后续阅读中的体验： 打个广告，欢迎各位老爷关注我的微信公众号：ml_trip，期待与大家交流！ $\frac{1}{1}$我的个人介绍大家可以在首页的标题下面找到me这个图标，点击即可，里面有我的个人介绍： 我的个人简历下载地址在me跳转页面中的位置如下： $\frac{1}{2}$ 快速阅读您可在任何一篇文章的右侧看到红色方框： 如果您对其中部分内容感兴趣，可直接点击绿色方框内的文章，会自动跳转到您关心的模块； 如果您想要看到我的更多联系方式，可以点击蓝色模块中的站点概览； 如果您不想红色方框影响您的阅读，在黑色条块的最下方的小叉点击即可。 $\frac{1}{3}$ 赞助激励如果您觉得我写的东西对您有一些帮助，在您宽裕的情况下可以在文章下面的打赏中给我发一个小红包，或者直接扫描下面的二维码，感谢您对我的认可： 如果您还是一个学生或者您正处于人生的低谷，感谢您对我的认可，打赏就不需要了，我会一如既往的给大家整理工作中的一些想法和心得 $\frac{1}{4}$ 自定义搜索为了方便大家找到自己关心的内容，建议直接点击搜索图标： 比如搜索svm，有模糊匹配结果如下： $\frac{1}{5}$ 标签检索大家可以在首页的标题下面找到标签这个图标，点击即可： 该类别下生成了标签云，为较为仔细的文章内容概括： $\frac{1}{6}$ 其他 因为本博客部署在GitHub，如果您有时候遇到打不开网页的问题，建议您重复刷新或者收藏slade_sal简书地址，两者内容是一致的 如果您有任何疑惑或者疑问都可以通过站点概览的邮箱联系我，非常愿意解答您的问题 如果您遇到算法学习过程的困难，需要内推或者就业方向建议，也可以通过站点概览的邮箱联系我，非常愿意和您进行交流 绝大多数代码都可以在我的Github上找到，所有的数据都经过脱敏处理，您可以放心使用，希望对您有所帮助 最后，感谢大家一路以来对我的认可。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>公告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集成学习需要理解的一些内容]]></title>
    <url>%2F2019%2F12%2F06%2F%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0%E9%9C%80%E8%A6%81%E7%90%86%E8%A7%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[LR需要理解的一些内容]]></title>
    <url>%2F2019%2F12%2F06%2FLR%E9%9C%80%E8%A6%81%E7%90%86%E8%A7%A3%E7%9A%84%E4%B8%80%E4%BA%9B%E5%86%85%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[logistic分布函数和密度函数，手绘大概的图像 分布函数： 密度函数： 其中，μ表示位置参数，γ为形状参数。logistic分布比正太分布有更长的尾部且波峰更尖锐 LR推导，基础5连问 基础公式 f(x) = wx + b y = sigmoid(f(x)) 可以看作是一次线性拟合+一次sigmoid的非线性变化 伯努利过程 对于lr来说事情只有发生和不发生两种可能，对于已知样本来说，满足伯努利的概率假设： p(y=1/x,θ) = h(θ,x) p(y=0/x,θ) = 1-h(θ,x) p(y/x,θ) = h(θ,x)^y · (1-h(θ,x))^(1-y) 第i个样本正确预测的概率如上可得 几率odds 数据特征下属于正例及反例的比值 ln(y/(1-y)) 极大似然 第i个样本正确预测的概率如上可得每条样本的情况下 综合全部样本发生的概率都要最大的话，采取极大似然连乘可得： ∏(h(θ,x)^y · (1-h(θ,x))^(1-y)) 损失函数 通常会对极大似然取对数，得到损失函数，方便计算 ∑ylogh(θ,x)+(1-y)log(1-h(θ,x))最大 及-1/m · ∑ylogh(θ,x)+(1-y)log(1-h(θ,x))最小 梯度下降 损失函数求偏导，更新θ θj+1 = θj - ∆·∂Loss/∂θ =θj - ∆·1/m·∑x·(h-y) ∆为学习率 梯度下降如何并行化？ 首先需要理解梯度下降的更新公式： ∑处的并行，不同样本在不同机器上进行计算，计算完再进行合并 同一条样本不同特征维度进行拆分，处并行，把内的xi和Wi拆分成块分别计算后合并，再把外层同样拆分成若干块进行计算 LR明明是分类模型为什么叫回归？观测样本中该特征在正负类中出现概率的比值满足线性条件，用的是线性拟合比率值，所以叫回归 为什么LR可以用来做CTR预估？ 点击行为为正向，未点击行为为负向，ctr需要得到点击行为的概率，lr可以产出正向行为的概率，完美match 实现简单，方便并行，计算迭代速度很快 可解释性强，可结合正则化等优化方法 满足什么样条件的数据用LR最好？ 特征之间尽可能独立 不独立所以我们把不独立的特征交叉了 还记得FM的思路？ 离散特征 连续特征通常没有特别含义，31岁和32岁差在哪？ 离散特征方便交叉考虑 在异常值处理上也更加方便 使的lr满足分布假设 什么分布假设？ 在某种确定分类上的特征分布满足高斯分布 C1和C2为正负类，观测样本中该特征在正负类中出现概率的比值满足线性条件的前提就是P服从正太分布 实际中不满足的很多，不满足我们通常就离散化，oneHotEncode 此处就用到了全概率公式推导，有可能会回到写出全概率公式&amp;贝叶斯公式的问题中 LR为什么使用sigmoid函数作为激活函数？其他函数不行吗？ 思路一：lr的前提假设就是几率odds满足线性回归，odds又为正负样本的log比，参见满足什么样条件的数据用LR最好？中第三点公式的展开 思路二：Exponential model 的形式是这样的：假设第i个特征对第k类的贡献是，则数据点属于第k类的概率正比于。 二分类上： 化简即为sigmoid 以上思路源自：PRML（Pattern Recognition and Machine Learning） 思路三：glm有满足指数族的性质，而作为lr作为y满足伯努利分布的的线性条件，伯努利分布的指数族形式就是sigmoid，或者也叫连接函数 利用几率odds的意义在哪？ 直接对分类模型进行建模，前提假设为非常弱的指定类别上自变量的条件分布满足高斯 由预测0/1的类别扩展到了预测0-1的概率值 任意阶可导的优秀性质 Sigmoid函数到底起了什么作用？ 数据规约：[0,1] 线性回归在全量数据上的敏感度一致，sigmoid在分界点0.5处更加敏感 sigmoid在逻辑回归的参数更新中也不起影响，避免了更新速度不稳定的问题 LR为什么要使用极大似然函数，交互熵作为损失函数？那为什么不选平方损失函数的呢 更新速度只与真实的x和y相关，与激活函数无关，更新平稳 比如mse就会导致更新速度与激活函数sigmoid挂钩，而sigmoid函数在定义域内的梯度大小都比较小(0.25&gt;x)，不利于快速更新 mse下的lr损失函数非凸，难以得到解析解 LR中若标签为+1和-1，损失函数如何推导？ way1:把0-1的sigmoid的lr结果Y映射为2y-1，推导不变 way2:把激活函数换成tanh，因为tanh的值域范围为[-1,1],满足结果，推导不变 way3:依旧以sigmoid函数的话，似然函数(likelihood)模型是：，重复极大似然计算即可 如果有很多的特征高度相关或者说有一个特征重复了100遍，会造成怎样的影响？为什么要避免共线性？ 如果在损失函数最终收敛的情况下，其实就算有很多特征高度相关也不会影响分类器的效果 每一个特征都是原来特征权重值的百分之一，线性可能解释性优点也消失了 增加训练收敛的难度及耗时，有限次数下可能共线性变量无法收敛，系数估计变得不可靠 泛化能力变差，训练是两列特征可能会共线性，当线上数据加入噪声后共线性消失，效果可能变差 LR可以用核么？可以怎么用？结论：可以，加l2正则项后可用 原因： 核逻辑回归，需要把拟合参数w表示成z的线性组合及representer theorem理论。这边比较复杂，待更新，需要了解： w拆解的z的线性组合中的系数α来源 representer theorem 的证明 凡是进行L2正则化的线性问题我们都能使用核函数的技巧的证明 如何将将W*表示成β的形式带到我们最佳化的问题 LR中的L1/L2正则项是啥？ L1正则项：为模型加了一个先验知识，未知参数w满足拉普拉斯分布， ,u为0。在lr模型损失函数中新增了项 L2正则项：为模型加了一个先验知识，未知参数w满足0均值正太分布，,u为0。在lr模型损失函数中新增了项 lr加l1还是l2好？这个问题还可以换一个说法，l1和l2的各自作用。刚才我们说到l1对未知参数w有个前提假设满足拉普拉斯分布，l2对未知参数的假设则是正太分布，且都是零均值，单纯从图像上我们就可以发现，拉普拉斯对w的规约到0的可能性更高，所以对于特征约束强的需求下l1合适，否则l2 正则化是依据什么理论实现模型优化？结构风险最小化：在经验风险最小化的基础上（也就是训练误差最小化），尽可能采用简单的模型，以此提高泛化预测精度。 LR可以用来处理非线性问题么？ 特征交叉，类似fm 核逻辑回归，类似svm 线性变换+非线性激活，类似neural network 为什么LR需要归一化或者取对数?模型中对数据对处理一般都有一个标答是提升数据表达能力，也就是使数据含有的可分信息量更大 工程角度： 加速收敛 提高计算效率 理论角度: 梯度下降过程稳定 使得数据在某类上更服从高斯分布，满足前提假设，这个是必须要答出来的 归一化和标准化之间的关系 为什么LR把特征离散化后效果更好？离散化的好处有哪些？ 原来的单变量可扩展到n个离散变量，每个变量有单独的权重，相当于为模型引入了非线性，能够提升模型表达能力，加大拟合 离散后结合正则化可以进行特征筛选，更好防止过拟合 数据的鲁棒性更好，不会因为无意义的连续值变动导致异常因素的影响，（31岁和32岁的差异在哪呢？） 离散变量的计算相对于连续变量更快 逻辑回归估计参数时的目标函数逻辑回归的值表示概率吗？lr的output是彼此之间相对谁的可能性更高，而不是概率，概率是事情发生的可能，lr的output不代表可能 LR对比万物？ lr和线性回归 lr解用的极大似然，线性回归用的最小二乘 lr用于分类，线性回归用于回归 但两者都是广义线性回归GLM问题 两者对非线性问题的处理能力都是欠佳的 lr和最大熵 在解决二分类问题是等同的 lr和svm 都可分类，都是判别式模型思路 通常都是用正则化进行规约 模型上 lr是交叉熵，svm是HingeLoss lr是全量数据拟合，svm是支持向量拟合 lr是参数估计有参数的前提假设，svm没有 lr依赖的是极大似然，svm依赖的是距离 lr和朴素贝叶斯 如果朴素贝叶斯也有在某一类上的数据x满足高斯分布的假设前提，lr和朴素贝叶斯一致 lr是判别模型，朴素贝叶斯是生成模型 lr没有明确feature条件独立(但是不能共线性，理由之前讲了)，朴素贝叶斯要求feature条件独立 lr和最大熵模型 本质没有区别 最大熵模型在解决二分类问题就是逻辑回归 最大熵模型在解决多分类问题的时候就是多项逻辑回归回归 LR梯度下降方法？ 随机梯度下降 局部最优解，可跳出鞍点 计算快 批梯度下降 全局最优解 计算量大 mini批梯度下降 综合以上两种方法 除此之外，比如ada和冲量梯度下降法会对下降的速率速度进行控制，也会对不同更新速度的参数进行控制，等等，多用于深度学习中 LR的优缺点？ 优点 简单，易部署，训练速度快 模型下限较高 可解释性强 缺点 只能线性可分 数据不平衡需要人为处理，weight_class/有哪些常见的采样方法 模型上限较低 除了做分类，你还会用LR做什么？特征筛选，特征的系数决定该特征的重要性 你有用过sklearn中的lr么？你用的是哪个包？sklearn.linear_model.LogisticRegression 看过源码么？为什么去看？ 看部分参数的解释 比如dual、weight_class中的1:0还是0:1比 比如输出值的形式，输出的格式 谈一下sklearn.linear_model.LogisticRegression中的penalty和solver的选择？ penalty是正则化，solver是函数优化方法 penalty包含l1和l2两种，solver包含坐标轴下降、牛顿、随机梯度下降等 牛顿法，拟牛顿法和随机梯度下降都不能使用l1，因为他们都需要损失函数的一阶二阶导数，而坐标轴下降法不限制这些，l1和l2都可行。 l1和l2选择参考上面讲的正则化部分 随机梯度下降在数据较少的时候最好别用，但是速度比较快。默认的是坐标轴下降法 谈一下sklearn.linear_model.LogisticRegression中对多分类是怎么处理的？ 首先，决定是否为多分类的参数是multi_class 在二分类的时候，multi和ovr和auto都是一样的 在真正执行multi的时候，会通过LabelEncoder把目标值y离散化，不停的选择两类去做ovr的计算直到取完所有情况 我的总结 逻辑回归假设观测样本中该特征在正负类中出现结果服从伯努利分布，通过极大化似然函数的方法，运用梯度下降来求解参数，来达到将数据二分类的目的 逻辑回归本质是线性模型，只能解决线性相关的问题，非线性相关用核或者svm等 逻辑回归不需要特征的条件独立，但是不能共线性，需要核线性回归一样，做共线性检验 逻辑回归对样本噪声是鲁棒对，SVM对噪声比较敏感，而logistic回归对噪声不是很敏感，是因为如果噪声点落在了支持向量上，将会直接影响判别面的方程。而logistic回归通过最大似然求解模型参数，将会弱化噪声的影响]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>复习手册</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[introductionToPython]]></title>
    <url>%2F2019%2F11%2F05%2FintroductionToPython%2F</url>
    <content type="text"><![CDATA[列出 5 个常用 Python 标准库？数据处理：math功能增强：functools系统配置：os，sys深度浅度复制：copy Python 内建数据类型有哪些？Python：bytes，int，bool，tuple，list，dictJava：byte，short，int，long，float，double，boolean，char 简述 with 方法打开处理文件帮我我们做了什么？123456789101112131415try: f = open("xxx","r") ...except: f.close()``` # 列出 Python 中可变数据类型和不可变数据类型，为什么？可变：list，dict，set不可变：bytes，int，bool，tuple取决于内存地址是否可变，比如list在append后的内存地址是变换的，但是tuple确立后除非覆盖否则唯一不变。# Python 获取当前日期？```pythondatetime.datetime.now() 统计字符串每个单词出现的次数12from collections import CounterCounter("hello") 用 python 删除文件和用 linux 命令删除文件方法123os.remove#split linerm 写一段自定义异常代码12345678910111213141516171819class myException(Exception): """docstring for myException""" def __init__(self, *args): self.args = argsclass myException(Exception): """docstring for myException""" def __init__(self): self.args = ("异常",) self.message = "异常" self.code = 200try: raise ValueErrorexcept myException as e: print(e.message)finally: print("end") 举例说明异常模块中 try except else finally 的相关意义防止中断程序，比如解析json异常，打开文件异常等 谈谈对 Python 和其他语言的区别优点： 语法简单，不需要各种函数申明，关键词，类型说明等 解释型语言，一行一行执行，调试高效 pypi开源贡献量大 缺点： 执行速度慢 代码pythonic难以维护 Python的GIL(Global Interpreter Lock)全局解释器锁 保证同一个时刻只有一个线程在运行 multiprocessing(多进程)替代Thread(多线程) 简述解释型和编译型编程语言解释型:就是边解释边执行编译性:编译后再执行 Python 的解释器种类以及相关特点？ Cpython：官方解释器 Jpython：可以直接把Python代码编译成Java字节码执行 Ipython：Cpython的交互版本 PyPy：基于JIT技术的动态编译下的代码执行 说说你知道的Python3 和 Python2 之间的区别？ print函数 input函数 是否地板除 编码差异ascii和utf-8 nonlocal Python3 和 Python2 中 int 和 long 区别？Python2：sys.maxint以下的用int，以上用的是long存储Python3：全都是int xrange 和 range 的区别？编码规范python2中xrange = python3中的range，是一个生成器而python2中range则为一个list，后者比前者更浪费空间 什么是 PEP8?编码规范 了解 Python 之禅么？import this 了解 docstring 么？类注释,help可查看 了解类型注解么？3.5后的参数注解，类似Java 例举你知道 Python 对象的命名规范，例如方法或者类等方法名参考c++下划线命名类首字母大写 Python 中的注释有几种？#‘’’ ‘’’ 如何优雅的给一个函数加注释？‘’’ ‘’’ 如何给变量加注释？# Python 代码缩进中是否支持 Tab 键和空格混用。否 是否可以在一句 import 中导入多个库?可以 在给 Py 文件命名的时候需要注意什么?避免和官方包一致，比如math，string，request等等 例举几个规范 Python 代码风格的工具数据类型字符串pylint 列举 Python 中的基本数据类型字符串（String）、数字（Digit）、列表（List）、元组（Tuple）、集合（Sets）、字典（Dictionary） 如何区别可变数据类型和不可变数据类型从对象内存地址方向来说 可变数据类型：在内存地址不变的情况下，值可改变（列表和字典是可变类型，但是字典中的 key 值必须是不可变类型）不可变数据类型：内存改变，值也跟着改变。（数字，字符串，布尔类型，都是不可变类型）可以通过 id() 方法进行内存地址的检测 将”hello world”转换为首字母大写”Hello World”string.title() 如何检测字符串中只含有数字?string.isdigit() 将字符串”ilovechina”进行反转[::-1] Python 中的字符串格式化方式你知道哪些？%sformat 有一个字符串开头和末尾都有空格，比如“ adabdw ”,要求写一个函数把这个字符串的前后空格都去掉。string.strip() 获取字符串”123456“最后的两个字符。string[-2:] 一个编码为 GBK 的字符串 S，要将其转成 UTF-8 编码的字符串，应如何操作？a= “S”.encode(“gbk”).decode(“utf-8”,’ignore’) 怎样将字符串转换为小写lower() 单引号、双引号、三引号的区别？列表单独使用单引号和双引号没什么区别，但是如果引号里面还需要使用引号的时候，就需要这两个配合使用了，然后说三引号，同样的三引号也分为三单引号和三双引号，两个都可以声名长的字符串时候使用，如果使用 docstring 就需要使用三双引号 已知 AList = [1,2,3,1,2],对 AList 列表元素去重，写出具体过程。map(list,map(set,l)) 如何实现 “1,2,3” 变成 [“1”,”2”,”3”]s.split(“,”) 给定两个 list，A 和 B，找出相同元素和不同元素set(A)&amp;set(B)set(A)^set(B) [[1,2],[3,4],[5,6]]一行代码展开该列表，得出[1,2,3,4,5,6]sum(list,[]) 合并列表[1,5,7,9]和[2,2,6,8][1,5,7,9]+[2,2,6,8] 35.如何打乱一个列表的元素？import random a = [1, 2, 3, 4, 5]random.shuffle(a) 字典操作中 del 和 pop 有什么区别del 可以根据索引（元素所在位置）来删除的，没有返回值。 pop 可以根据索引弹出一个值，然后可以接收它的返回值。 按照字典的内的年龄排序sorted(d1, key=lambda x：x[“age”]) 请合并下面两个字典 a = {“A”:1,”B”:2},b = {“C”:3,”D”:4}dict((a.items(),b.items())) 如何使用生成式的方式生成一个字典，写一段功能代码。d = {‘a’：’1’, ‘b’：’2’}{v：k for k,v in d.items()} 如何把元组(“a”,”b”)和元组(1,2)，变为字典{“a”:1,”b”:2}dict(zip(a,b)) 如何交换字典 {“A”：1,”B”：2}的键和值？dict(zip(s.values()，s.keys())) Python 里面如何实现 tuple 和 list 的转换？list/tuple 我们知道对于列表可以使用切片操作进行部分元素的选择，那么如何对生成器类型的对象实现相同的功能呢？from itertools import isliceislice(gen,0,4) 请将[i for i in range(3)]改成生成器(i for i in range(3)) a=”hello”和 b=”你好”编码成 bytes 类型a = b”hello”b = bytes(“你好”, “utf-8”)c = “你好”.encode(“utf-8”) Python 交换两个变量的值a,b=b,a 在读文件操作的时候会使用 read、readline 或者 readlines，简述它们各自的作用.read：每次读取整个文件，它通常用于将文件内容放到一个字符串变量中。.readline：一行一行读，一次性读完，加载到内存.readlines：将文件的句柄生成一个生产器，然后一行一行读 json 序列化时，可以处理的数据类型有哪些？如何定制支持 datetime 类型？ str、int、list、tuple、dict、bool、None重写json中的default()函数 json 序列化时，默认遇到中文会转换成 unicode，如果想要保留中文怎么办？ json.dumps 有两个磁盘文件 A 和 B，各存放一行字母，要求把这两个文件中的信息合并(按字母顺序排列)，输出到一个新文件 C 中。sort字典序后f.write 如果当前的日期为 20190530，要求写一个函数输出 N 天后的日期，(比如 N 为 2，则输出 20190601)。datetime.datetime.now()+datetime.timedelta(days=n) 写一个函数，接收整数参数 n，返回一个函数，函数的功能是把函数的参数和 n 相乘并把结果返回。闭包函数def test1(n): def test2(n1): return n1*n return test2 一行代码输出 1-100 之间的所有偶数。[i for i in range(101) if i%2==0] python 字典和 json 字符串相互转化方法json.loads：json—dictjson.dumps：dict—json 请写一个 Python 逻辑，计算一个文件中的大写字母数量s.isupper() 函数装饰器有什么作用？请列举说明？ 鉴权 统计耗时 打日志 Python 垃圾回收机制？ 标记计数回收 隔代回收 魔法函数 call怎么使用?类调用的时候执行 如何判断一个对象是函数还是方法？types包 @classmethod 和@staticmethod 用法和区别@staticmethod：cls，类内运行@staticmethod：不需要对象，类名直接访问 Python 中的接口如何实现？import abc@abc.abstractmethod Python 中的反射了解么?getattr、hasattr、setattr、delattr metaclass 作用？以及应用场景？创建类 hasattr() getattr() setattr()的用法hasattr 可以判断一个对象是否含有某个属性getattr 可以充当 get 获取对象属性的作用setattr 可以充当 为对象属性赋值的作用 请列举你知道的 Python 的魔法方法及用途。init：初始化，类似Java里面的构造函数new：对象创建过程中的控制 如何知道一个 Python 对象的类型？type Python 的传参是传值还是传址？对象的引用 简述 any()和 all()方法any : 任意all ：所有通常用作条件判断 filter 方法求出列表所有奇数并构造新列表，a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]list(filter(lambda x： x % 2 == 1, a)) 什么是猴子补丁？运行时动态修改模块、类或函数，通常是添加功能或修正缺陷 在 Python 中是如何管理内存的？引用计数隔代回收 当退出 Python 时是否释放所有内存分配？不是的，循环引用其他对象或引用自全局命名空间的对象的模块，在 Python 退出时并非完全释放 解释一下 python 中 pass 语句的作用？占位符无作用 简述你对 input()函数的理解键盘读入 python 中的 is 和==is：地址判断==：值判断 Python 中的作用域本地作用域(Local)—-当前作用域被嵌入的本地作用域(Enclosing locals)—-全局/模块作用域(Global)—-内置作用域(Built-in) 三元运算写法和应用场景？1 if True else 0 了解 enumerate 么？加index，(index,value) 如何在函数中设置一个全局变量global pathlib 的用法举例路径拼接符”/“ Python 中递归的最大次数，那如何突破呢？sys.setrecursionlimit 什么是面向对象的 mro类继承的先后顺序 isinstance 作用以及应用场景？isinstance 是判断一个对象是否为另一个对象的子类的 什么是断言？应用场景？是否和我们预期一致 lambda 表达式格式以及应用场景？匿名函数 新式类和旧式类的区别是否继承object，py3默认继承 dir()是干什么用的？对象属性方法查询 一个包里有三个模块，demo1.py, demo2.py, demo3.py，但使用 from tools import *导入模块时，如何保证只有 demo1、demo3 被导入了。all 列举 5 个 Python 中的异常类型以及其含义AttributeError 对象没有这个属性NotImplementedError 尚未实现的方法StopIteration 迭代器没有更多的值TypeError 对类型无效的操作ValueError 缩进错误 copy 和 deepcopy 的区别是什么？深拷贝/浅拷贝 代码中经常遇到的args, *kwargs 含义及用法。变长参数，一个是tuple一个是kv的dict Python 中会有函数或成员变量包含单下划线前缀和结尾，和双下划线前缀结尾，区别是什么?“单下划线” 开始的成员变量叫做保护变量，意思是只有类对象和子类对象自己能访问到这些变量； “双下划线” 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据 w、a+、wb 文件写入模式的区别w：写入，如有覆盖a+：追加wb：二进制写入 举例 sort 和 sorted 的区别相同之处 sort 和 sorted 都可以对列表元素排序，sort() 与 sorted() 的不同在于，sort 是在原位重新排列列表，而 sorted() 是产生一个新的列表。 sort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作 什么是负索引？倒数 pprint 模块是干什么的？print 解释一下 Python 中的赋值运算符常规优先级大于&amp;^|~ 解释一下 Python 中的逻辑运算符and、or、not 讲讲 Python 中的位运算符&amp;^|~:且、异或、或、反 在 Python 中如何使用多进制数字？int/bin/hex 怎样声明多个变量并赋值？算法和数据结构a,b,c=1,2,3 python 单例模式的实现方法Python 的模块就是一个天然的单例模式 简要介绍三次握手和四次挥手三次握手 第一次握手：主机 A 发送同步报文段（SYN）请求建立连接。 第二次握手：主机 B 听到连接请求，就将该连接放入内核等待队列当中，并向主机 A 发送针对 SYN 的确认 ACK，同时主机 B 也发送自己的请求建立连接（SYN）。 第三次握手：主机 A 针对主机 BSYN 的确认应答 ACK。 四次挥手 第一次挥手：当主机 A 发送数据完毕后，发送 FIN 结束报文段。 第二次挥手：主机 B 收到 FIN 报文段后，向主机 A 发送一个确认序号 ACK（为了防止在这段时间内，对方重传 FIN 报文段）。 第三次挥手：主机 B 准备关闭连接，向主机 A 发送一个 FIN 结束报文段。 第四次挥手：主机 A 收到 FIN 结束报文段后，进入 TIME_WAIT 状态。并向主机 B 发送一个 ACK 表示连接彻底释放。 说一说多线程，多进程和协程的区别。进程： 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。每个进程都有自己的独立内存空间，不同进程通过进程间通信来通信。由于进程比较重量，占据独立的内存，所以上下文进程间的切换开销（栈、寄存器、虚拟内存、文件句柄等）比较大，但相对比较稳定安全。线程： 线程是进程的一个实体,是 CPU 调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程间通信主要通过共享内存，上下文切换很快，资源开销较少，但相比进程不够稳定容易丢失数据。协程： 协程是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。区别： 进程与线程比较： 线程是指进程内的一个执行单元,也是进程内的可调度实体。线程与进程的区别： 1) 地址空间：线程是进程内的一个执行单元，进程内至少有一个线程，它们共享进程的地址空间，而进程有自己独立的地址空间2) 资源拥有：进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源3) 线程是处理器调度的基本单位,但进程不是4) 二者均可并发执行5) 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制协程与线程进行比较： 1) 一个线程可以多个协程，一个进程也可以单独拥有多个协程，这样 Python 中则能使用多核 CPU。2) 线程进程都是同步机制，而协程则是异步3) 协程能保留上一次调用时的状态，每次过程重入时，就相当于进入上一次调用的状态 简述 GIL答： GIL：全局解释器锁。每个线程在执行的过程都需要先获取 GIL，保证同一时刻只有一个线程可以执行代码。 线程释放 GIL 锁的情况：在 IO 操作等可能会引起阻塞的 systemcall 之前,可以暂时释放 GIL，但在执行完毕后, 必须重新获取 GIL，Python3.x 使用计时器（执行时间达到阈值后，当前线程释放 GIL）或 Python2.x，tickets 计数达到 100 。 Python 使用多进程是可以利用多核的 CPU 资源的。 多线程爬取比单线程性能有提升，因为遇到 IO 阻塞会自动释放 GIL 锁。 进程之间如何通信可以通过队列的形式 什么是并发和并行？并行是指同一时刻同时做多件事情，而并发是指同一时间间隔内做多件事情 python解释器及工作原理解释器由一个编译器和一个虚拟机构成，编译器负责将源代码转换成字节码文件，而虚拟机负责执行字节码。所以，解释型语言其实也有编译过程，只不过这个编译过程并不是直接生成目标代码，而是中间代码（字节码），然后再通过虚拟机来逐行解释执行字节码 执行 python XX.py 后，将会启动 Python 的解释器，python解释器的编译器会将.py源文件编译（解释）成字节码生成PyCodeObject字节码对象存放在内存中。python解释器的虚拟机将执行内存中的字节码对象转化为机器语言，虚拟机与操作系统交互，使机器语言在机器硬件上运行。运行结束后python解释器则将PyCodeObject写回到pyc文件中。当python程序第二次运行时，首先程序会在硬盘中寻找pyc文件，如果找到，则直接载入，否则就重复上面的过程。所以我们应该这样来定位PyCodeObject和pyc文件，我们说pyc文件其实是PyCodeObject的一种持久化保存方式。]]></content>
      <categories>
        <category>代码集合</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python自用工具包PyTls]]></title>
    <url>%2F2019%2F10%2F22%2FPython%E8%87%AA%E7%94%A8%E5%B7%A5%E5%85%B7%E5%8C%85PyTls%2F</url>
    <content type="text"><![CDATA[10.22更新内容： 修复了python2和python3对lru_cache不兼容的问题 strt模块新增了judge_anagrams功能，判断目标文本中是否有近似的待查找文本 matht模块新增了isOdds功能，判断奇偶 新增了文本处理模块textt 11.3更新内容： 修复字典树的match函数下的一个bug 新增了装饰器模块wrappert，提供了装饰器函数@timespend耗时判断功能 dictt模块新增了json_loads()功能，解决json不标准的情况 我们搞了个python的工具包PyTls。 做这件事的初衷是发生了一个星期要用python同时开发3个项目的情况，我发现了两个现象：1.有很多定制化的需求是极度高频反复重写的；2.有很多功能之前写过，可能因为稍许复杂又忘了，再用的时候又要去Google。所以，拉着同组的一个实习生，一起维护了PyTls的这个项目，为的就是那句”life is short, we need python”。 所有的详细的测试demo都可以在我的git找到，PyTls的测试demos 希望可以帮助到你一些，以下简单的介绍解释一下每个功能。 dicttget_map_value由于工程设计问题，我们的数据流中存在多层的字典数据格式： 123In [7]: msg = &#123;&apos;time&apos;:&#123;&apos;20190714&apos;:234,&apos;20190715&apos;:311&#125;&#125;In [8]: dictt.get_map_value(msg,None,True,&apos;time&apos;,&apos;20190714&apos;)Out[8]: 234 这边None是查找不到的时候的默认值，True可以不用管，是我这边设计的是否一定要底层查找，比较业务化通用性不好，True之后就是依次需要按逻辑查找的dict字段。 update_map_valueis_strict：True不允许新增kv，这边不会报错，只会增加不成功，需要注意一下。 sort_map_key按key排序字典，desc：是否降序 123In [24]: msg = &#123;11: 2, 2: 3, 9: 2&#125; ...: print(dictt.sort_map_key(msg, desc=False))[(2, 3), (9, 2), (11, 2)] sort_map_value按value排序，其他同上 get_tree构建一个以字典为基础的树结构，字典套字典 swapkey,value交换 merge合并两个dict,顺便说一句，reduce(merge,*dicts)，合并N个，这个比较少用就没整理 func_dict这个功能比较拗口，比如我们现在有个function，input 2，output 4，且想存储所有的kv结果，所以可以用这个功能进行记录。注意，这边的入参应该是一个**函数**。 123F = dictt.func_dict(lambda x: x * 2)print((F[2], F))# (4, defaultdict(&lt;function &lt;lambda&gt; at 0x103d812f0&gt;, &#123;2: 4&#125;)) WordCount字典树，快速查询和高效存储，支持string和list/tuple；支持计数、查找、位置校验三个核心功能 目前只output了是否存在查询词的功能，稍微改一下output就可以得到计数结果和位置结果，看有需要后期扩展一下这个功能，要说的是里面用了dfs，有点慢所以加了cache，这个点大家可以自行优化。 json_loads1dictt.json_loads(&apos;&#123;\&apos;a\&apos;: 1, &quot;b&quot;: &quot;i\&apos;m tom.&quot;&#125;&apos;) StrBuffer参考java中的StringButter而写的字符类，增加一些功能，重命名了我比较熟悉喜欢用的函数名，加了一些str内置没有的功能 append增加一个字符 index_at查找某个元素的index sort排序元素，字典序 reverse倒排所有字符 char_at查找某个index的元素 to_str/storgeto_str:以string的方式打印当前字符串 storge:以list的方式打印当前字符串 strtstr_reverse字符串反转 str_repeat字符串快速复制，n为复制的次数 str_splits字符串批切割，split_chars为分隔符，支持多个，以|连接，warning_info可以设置为False进行关闭，取消提示信息 judge_anagrams判断目标文本中是否有近似的待查找文本，待查找文本在目标文本中字母相同，但排列不同的字符串。judge_anagrams(cbaebabacd&quot;,&quot;abc&quot;)，在0和6的位置上后三位都是异位近似的。 typet基础的格式判断类，复用程度不高，主要是用来支持这个项目中的其他功能 is_none是否为None，支持None和np.nan判断 is_type判断是否为对应类型，类似于isinstance is_empty判断是否为空 is_has_attr判断是否含有某个属性，类中是否有某个属性变量 loaddatatpickle 的数据持久化，这个我用的最多，特别好用，可以支持在保持模型，整理数据，保存日志，存储报错信息等各个方向，我基本上每次必加载 readbunchobj读数据 writebunchobj存数据 randomt随机数 get_random迭代器办，每次随机取一个;min_value, max_value限制范围，limit限制可取的迭代次数 Chinese2num数字相关，提取数字更加强大的功能建议参考YMMNlpUtils Chinese_2_num中文转成数字，支持繁体中文简体中文的转换，如果是提取手机号的或者更复杂的数据建议参考YMMNlpUtils项目 isdigit判断是否为数字，同样也支持小数，也可以识别str后的数字，会自动解析掉str，&quot;0.234&quot;--&gt;True matht数学相关的类，包括信息熵，ln，互信息，条件概率等;部分熵计算的函数中有个expiation的参数，设置为False就不提醒是否越大越稳定还是不稳定的提示信息了，主要是我老忘，自己提醒自己的 ln以e为底的对数 entropy熵值，这边分两种情况，type=&quot;list&quot;的时候input为每种情况发生的结果，比如[1,1,2,3,4,2];type=&quot;prob&quot;的时候input为每种情况发生的概率，比如[1/3,1/3,1/6,1/6] condition_entropy条件熵，求和 H（X|Y）= Σ p(Y=yi)*H（X|Y=yi) MI来自于条件概率计算法：H(x)-H(x/y)，这边input默认的是每种情况发生的结果而非概率，比如：[1,0,1,0],[2,3,2,3] NMI来自于公式的互信息熵计算：2*∑pxylog(pxy/(px*py))/(H(x)+H(y))，这边input默认的是每种情况发生的结果而非概率，比如：[1,0,1,0],[2,3,2,3] word_edit_distince文本编辑距离，衡量两个字符串之间的相似度 BM25在文档包含查询词的情况下，或者说查询词精确命中文档的前提下，计算相似度，对内容进行排序 relative_entropy相对熵，也叫KL散度，H(p||q) = ∑pxlog(px/py),如果px与py分布一致，则return 0，差异越大return的值越大;H(p||q) = H(p,q) - H(p) cross_entropy交叉熵，H(p,q) = -∑pi*log(qi) , H(p||q) = H(p,q) - H(p) JSD衡量两个多项分布的距离，衡量两个多项分布的相似度 Hellinger_Distince海林格距离，用来衡量概率分布之间的相似性 isOdds奇偶判断 listtlist相关的处理，list是我最常用的一个type，所以我写了比较多而且以后也会最常去更新的一个地方，确实很多东西固化下来很好用;该部分代码尽可能考虑了时间复杂度，可能会牺牲一些空间复杂度，各位自行取舍 index_hash_maplist元素出现位置，等同于numpy array中的`np.where` Pilist元素出现的个数分布 single_one当数据是**成对出现**时候，找出其中落单的element；[2,2,1]--&gt;[1] subset找出对应list的子集;[1,2]--&gt;[[],[1],[2],[1,2]] permute找出对应list的全排列;[1,2]--&gt;[1,2],[2,1] flatten高维列表展开;[[1,2,3],[3,[4]]]--&gt; [1, 2, 3, 3, 4] duplicates原序去重；[3,3,1,2] -- &gt;[3,1,2] topn高频统计，返回list中高频出现的topn的对象，n为需要返回的个数；list:[3,3,1,2],n=1--&gt;[(3,2)] getindex返回list中最大/最小元素的位置:[3,1,2],flag=&quot;max&quot;--&gt;0/[3,1,2],flag=&quot;min&quot;--&gt;1;这边参数flag记得要小写min/max，大写暂不识别 splitlist按照指定个数切分，比如split([1,2,3,4],3)--&gt;[(1,2,3)]；如果list%需要切分的长度!=0，则末端部分会被舍弃，需要注意一下；如果确实需要的话可以进行尾部以0填充，保证不丢失数据； unzip把zip后的数据还原 trickt日常使用的一些trick，可能不好归纳为当前的分类中的某一类，所以暂时先放在trickt包中，待认领 choose_method根据condition不同的情况下，判断使用哪个函数 12345678def add(a, b): return a + bdef subtract(a, b): return a - bparam1 = 2param2 = 1choose_method(add, subtract, param1 &gt; param2, param1, param2)choose_method(add, subtract, param1 &lt; param2, param1, param2) Timer1234In [42]: with Timer(): ...: time.sleep(2) ...:total time is 2.0000739097595215 second. textt自然语言处理过程中，需要对原始文本进行一波整理，高复用的代码都固化在这里了。 is_chinese判断一个unicode是否是汉字，需要注意，这边只能判断一个汉字，多个需要自己map一下 is_chinese_string判断是否全为汉字 is_number判断一个unicode是否是数字，需要注意，这边只能判断一个数字，多个需要自己map一下 is_alphabet判断一个unicode是否是英文字母，需要注意，这边只能判断一个字母，多个需要自己map一下 is_alphabet_string判断是否全为字母 stringB2Q半角转全角 12In [8]: textt.stringB2Q("你干么!d7&amp;888学英 语ABC?nz")Out[8]: '你干么！ｄ７＆８８８学英\u3000语ＡＢＣ？ｎｚ' stringQ2B 把字符串全角转半角 12In [9]: textt.stringQ2B("你干么！ｄ７＆８８８学英 语ＡＢＣ？ｎｚ")Out[9]: '你干么!d7&amp;888学英 语ABC?nz' remove_punctuation去除标点符号 uniform格式化字符串，完成全角转半角，大写转小写的工作 12In [11]: textt.uniform("你来自&lt;美丽的世界&gt;。")Out[11]: '你来自美丽的世界' get_homophones_by_char根据汉字取同音字，需要注意，这边只能判断一个汉字，多个需要自己map一下 1textt.get_homophones_by_char("我") get_homophones_by_pinyin根据拼音取同音字，有两种方式：types=1不需要带声调，0需要带声调，如下： 12textt.get_homophones_by_pinyin("zho1ng", 0)textt.get_homophones_by_pinyin("zhong", 1) LocationTire地址相似度检索 12345678910# 首先需要生成对象并插入数据t = textt.LocationTire()t.insert(["江苏", "南京", "雨花", "铁心桥", "A座"])t.insert(["江苏", "南京", "雨花", "软件大道", "B座"])t.insert(["江苏", "南京", "雨花", "雨花客厅", "C座"])# 提供两种检索方式# 精准检索，返回对应的子集（准确结果，如果有必定正确）print(t.search(["江苏", "南京", "雨花"]))# 模糊检索，返回可能的结果（有一定概率会错误，近似匹配）print(t.match(["江苏", "南京", "雨花", ".", "C座"])) wrappert以装饰器实现的功能汇总，包括计时、日志、鉴权等等 timespend123@timespenddef add(a,b): return a+b 欢迎大家关注我的个人bolg，知乎，更多代码内容欢迎follow我的个人Github，如果有任何算法、代码、转&gt;行疑问都欢迎通过邮箱发消息给我。]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[约瑟夫环问题整理]]></title>
    <url>%2F2019%2F10%2F20%2F%E7%BA%A6%E7%91%9F%E5%A4%AB%E7%8E%AF%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[问题是这样的： 约瑟夫环问题：一圈共有N个人，开始报数，报到M的人自杀，然后重新开始报数，问最后自杀的人是谁？ 最简单的解法就是，遍历去查找： 1234567891011121314151617181920212223def test(nlist, m): ''' 从0开始的序号，此处为[0,1,2,3,4,5,6]7个人 nlist:[0,1,2,3,4,5,6] 从1开始报数，到m，比如此处的1，2，3，1，2，3 m:3 [0,1,2,3,4,5,6]--&gt;[0,1,3,4,6]--&gt;[0,3,4]--&gt;[0,3]--&gt;[3] ''' count = 1 idx = 0 while len(nlist) != 1: if idx == len(nlist): idx = 0 if count % m == 0: nlist.pop(idx) idx -= 1 idx += 1 count += 1 return nlist[0] 这样的解法，时间复杂度是o(N*M),有没有更加合理快速的解决方式呢？ 刚才的问题重新表述一下，即为如下： N个人（编号0~(N-1))，从0开始报数，报到(M-1)的自杀，剩下的人继续从0开始报数。求最后自杀者的编号。 假设N = 10，M=4，则现在的人数编号为0-9，报数为0-3。以下是旧环每个人编号：旧环 0 1 2 [3] 4 5 6 7 8 9。旧环中的3被剔除后，2-4就不连续了，接下来如果再循环到3的位置上的时候缺失了一个值，所以我们需要建立一个新环编号，且新环和旧环之间需要一个映射关系。 方法：将它与 N-1 个人组成的（0 ~ N-1）环进行一一映射。比如之前的之前，将剩余的 9 人与 9 人环（0~8）一一映射：新环 6 7 8 x 0 1 2 3 4 5，数据映射关系就是如下： 有两个问题需要被解决：1、如何由新环中的 3 得到旧环中的 7 呢？2、如何由旧环中的 7 得到新环中的 3 呢？新环= (旧环中编号-最大报数值)%旧总人数取得，即 new_number = (old_number + value ) % old_sum旧环= ( 新环中的数字 + 最大报数值 )% 旧总人数取得，即 old_number = ( new_number + value ) % old_sum 以上变化之后，问题由10个变为9个人，报到为3的人自杀，问题规模减小了。这样一直进行下去，最后剩下编号为0的人。用函数表示：F(1)=0。倒数第二个自杀的人，必然倒数第三轮自杀的人后的那个，所以：F(2) = F(1) + M，所以递归公式为：F(i) = F(i-1) + M，因为可能会超出总人数范围，所以要求模F(i) = (F(i-1) + M)%i。 123456def getNumber(N, M): result = 0 for i in range(2, N + 1): print(result) result = (result + M) % i return result 为了仔细看下这个出环和入环反查的流程，我们来看下： 注意看最后留下的序号为4的列，最后出环的序号比如为0，这就是上面F(1)=0的原因。这个序号为4的列，1人环中：0，2人环中：0，3人环中：1，4人环中：1，5人环中：0，6人环中：4，7人环中：1，8人环中：5，9人环中：0，10人环中：4。这样就得到了10个人报数4，最后留下的那个人在最初的10人环中的序号。 下面这个例子：一共有三十个人，从1-30依次编号。每次隔9个人就踢出去一个人。求踢出的前十五个人的号码： 12345a = [x for x in range(30)]del_number = 8 #该删除的编号for i in range(15): del a[del_number] del_number = (del_number+8)%len(a) 其中，旧环= ( 新环中的数字 + 最大报数值 )% 旧总人数取得，即 old_number = ( new_number + value ) % old_sum 下面这个例子：按递增间隔删数，直到最后只剩下一个数 题目：有数组A，每个元素存放相应的下标,即A[i]=i，要求按照1,2,3,…的规律删除数组中的元素,第一次间隔1个数，第二次间隔2个数,依次类推，到末尾时循环至开头继续进行,求最后一个被删掉的数的原始下标位置 123456789101112def remove_element(input_list): idx , num = 0,0 while len(input_list)!=1: # 控制间隔 num+=1 idx+=num # 如果范围溢出了，直接对idx取余 if idx&gt;=len(input_list): idx = idx%len(input_list) input_list.pop(idx) return input_list 约瑟夫环问题整理就给大家整理到这，如果大家想看更多的数据结构问题，可以关注一下我的Github，希望有所帮助。 欢迎大家关注我的个人bolg，知乎，更多代码内容欢迎follow我的个人Github，如果有任何算法、代码、转行疑问都欢迎通过邮箱发消息给我。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BinaryTree二叉树整理]]></title>
    <url>%2F2019%2F10%2F13%2FBinaryTree%E4%BA%8C%E5%8F%89%E6%A0%91%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[前言上一篇博客中，我们和大家简单的了解了一下BST二叉搜索树，但是实际上，这个可能工程实际中用的多，在实际面试的时候，可能更加关注的是二叉树这种更一般的情况。本着不懂就问，不会就学的态度，周末在家稍微整理了一些碎片化的知识，希望在这篇博客中能够把它们串联起来。 作为一个nlp算法工程师，我觉得tree+图是必不可少的技能，甚至你可以不了解word embedded，但是这两个技能真的是需要去好好学习一下的。实际项目中，我遇到了一个问题，快速查找6级地址，并进行联想，如果用传统的kv的hashmap查找，这个真的是一个redis灾难性的问题，但是基于树的Tire树就可以很好的解决这个问题。这也是促使我去学习更新自己技能的原因，话不多说，让我们开始： 思考二叉树的思考策略： 递归 万能，基本上树的问题都可以用递归去执行，天生的结构形式决定 迭代 队列：层次遍历 栈：三种迭代递归 dp：需要结合动态规划的 实际去用的过程中，建议优先考虑递归，相对来说更加简单，而迭代的边界考虑更为复杂。 基本递归 先序遍历preOrderTraverse 中序遍历inOrderTraverse 后序遍历posOrderTraverse三种遍历问题和BST三种遍历方式一致，代码在这边。最简单，也是最基础的，后面很多题型回基于这个问题去做，务必掌握。 层序遍历levelOrderTraverse两种方式去实现层序遍历 把二叉搜索树转换为累加树改写遍历方式的问题： 123451、先遍历到右树的根树，然后把根树的value赋值给add2、更新此树对应的父结点，并更新父结点对应的value = value+add3、同时再更新add，把父结点的值也更新到add上4、再更新父结点的左子树的value结点5、这样一次更新便完成了 验证二叉搜索树搜索二叉树的左支&lt;结点&lt;右支，正好可以用中序遍历比较 BST两个特点1、左支&lt;结点&lt;右支2、无重复 判断两个树是否一致（待完成，leetcode100） 对称二叉树以上两题利用了层次遍历的技巧 简单升级递归以上的递归围绕着简单遍历，实际上有更多剑走偏锋的问题： 二叉树最大深度 二叉树最小深度（待完成，leetcode111） 合并二叉树 翻转二叉树这四题都是直接利用递归结果之间的各种条件下的判断结果进行传递，没有额外的变量参与。典型的形式就是：12def func(): return new_func(func(root.left),func(root.right)) 技巧递归 二叉树所有路径和（待完成，leetcode257） 二叉树中的最大路径和 借助了当前结点是否可以作为根结点通过，利用全局变量保存每一个结点的路径最大值 借助了当前结点作为下一次迭代结点的时候，进行选左支还是右支考虑 二叉树的直径遍历所有结点，保存所有结点作为根结点的情况下，左右子树的最大深度和即可 动态规划 不同的二叉搜索树状态转移方程为:dp[i] += dp[j - 1] * dp[i - j],总树数=左右子树的分别数量的笛卡尔积 公共祖先问题 二叉树结点个数（待完成，leetcode222） 二叉树的最近公共祖先 二叉搜索树的最近公共祖先left if right == None else right if left == None else root这句话是核心，p,q有一个在一个分支上非空则返回对应的p,q,都非空则返回根节点 恢复原树 从前序与中序遍历序列构造二叉树 从中序与后序遍历序列构造二叉树 从前序与后序遍历序列构造二叉树都是先找根节点，再把左右树范围找出来，分别在对左右树范围分别找出根节点，进行循环递归 其他问题 序列化与反序列化二叉树--&gt;list//list--&gt;二叉树先通过某种遍历方法去把二叉树—&gt;list，再通过data.pop不断的拿结点去赋值，if判断条件用来当数据到最底层时候，跳出此次递归分支，切换到另一个子树上（此处为右子树） dfs+两数之和+双递归1234这题leetcode认为是简单，但是我觉得贼难： 1、python闭包的理解，count虽然是局部遍历，但是在递归的时候，每个count都是独立的 2、dfs(root.？？？？？, sum - root.val)用的是两数之和的逻辑进行递归 3、dfs(root,sum) + self.pathSum(root.left, sum) + self.pathSum(root.right, sum) 这个用的是遍历所有结点的方法 以上就是常见问题的整理了，当然必然有一些新的问题，比如二叉树中的第k小的元素（待完成，leetcode230）,二叉树的锯齿形层次遍历（待完成，leetcode103），二叉树展开为链表（待完成，leetcode114）等等。但是只要把以上的这么多类别的问题都能搞定，这些问题也只是上述问题的一些翻版而已。 BinaryTree整理就给大家整理到这，如果大家想看更多的数据结构问题，可以关注一下我的Github，希望有所帮助。 欢迎大家关注我的个人bolg，知乎，更多代码内容欢迎follow我的个人Github，如果有任何算法、代码、转行疑问都欢迎通过邮箱发消息给我。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[binarySearchTree二叉搜索树整理]]></title>
    <url>%2F2019%2F10%2F07%2FbinarySearchTree%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[所有数据结构中，我之前最不熟悉的是二叉树题型，因为个人问题从来没有静心去研究过，十一正好有时间，在家里整理了二叉搜索树(下面简称二叉树)基本的概念，希望自己不熟悉的常见题型会越来越少，也希望自己所学能为自己所用。 二叉树满二叉树所有分支结点都存在左右子树，并且所有叶子结点都在同一层上，这样即满二叉树。 叶子结点都在最底层 同样深度，结点个数最多，叶子树最多 完全二叉树一个n个结点的二叉树按层序排列，所有结点与同样深度的满二叉树中的位置相同，这就是完全二叉树。 叶子结点只能在最下一层（这不是最后一层，是最下层） 最下层叶子结点一定集中在左侧连续位置（来自于层序遍历的属性） 次下层叶子结点(如有，但不一定有)一定集中在右侧连续位置（来自于层序遍历的属性） 同样的结点个数，完全二叉树深度最小（满二叉树也是满足的，满二叉树一定是完全二叉树，反之不成立） 基本性质一般二叉树性质（通性） 非空二叉树，第i层最多有pow(2,i-1)个节点个数 深度为k的二叉树上，最多有pow(2,k)-1个节点个数 在一棵二叉树中，除了叶子结点(度为0，也就是没有叶子结点的结点)，只有可能度为2（n2）和1（n1）的结点了。12假设T为结点的总个数，T=n2+n1+n0;连边数很好理解为T-1，T-1=2*n2+n1;所以，n0=n2+1。换句话说，0度结点个数=2度结点个数+1。 完全二叉树（特性） n个结点的完全二叉树的深度为log(2,n)+11k层满二叉树的节点个数pow(2,k)-1，所以完全二叉树中的结点个数N必定满足N&lt;=pow(2,k)-1，因为完全二叉树有满二叉树的排列性质，N必定也大于pow(2,k-1)-1。pow(2,k-1)-1&lt;N&lt;=pow(2,k)-1，易得pow(2,k-1)&lt;N&lt;=pow(2,k)，k-1&lt;log(2,N)&lt;=k，k为整数，所以k=[log(2,N)]+1 二叉树遍历最核心的概念 左树上所有结点的值均小于或者等于它的根结点的值 右树上所有结点的值均大于或者等于它的根结点的值 左右树也分别为二叉树 最大/最小值点查找最大值必然在右子树上，最小值点必定在左子树上 删除结点 找到当前结点哪个子树非空，所有的剩下的值都在非空的这个子树上 判断当前结点是父结点哪个子树，左子树还是右子树 父结点对应的（左/右）子树用当前结点的非空子树覆盖 注意，如果左右子树都非空的话，把递归查找，找到右子树中的子树中第一次出现左子树为None的时候，把此子树的值赋值给要删除的结点，再把此子树的父结点的左子树用此子树的右子树进行覆盖。12n.element = next.elementpre.lchild = next.rchild 先序遍历 &#39;&#39;&#39; 1、访问根结点 2、先序遍历左子树 3、先序遍历右子树 &#39;&#39;&#39; 中序遍历 &#39;&#39;&#39; 1、中序遍历左子树 2、访问根结点 3、中序遍历右子树 &#39;&#39;&#39; 后序遍历 &#39;&#39;&#39; 1、后序遍历左子树 2、后序遍历右子树 3、访问根结点 &#39;&#39;&#39; 三种遍历方式最核心的是什么时候打印根节点，这决定了遍历逻辑。 层次遍历利用了队列先进先出的性质。 以上代码都依旧完善在我的GitHub中:搜索二叉树，大家可以参考一下。 欢迎大家关注我的个人bolg，知乎，更多代码内容欢迎follow我的个人Github，如果有任何算法、代码、转行疑问都欢迎通过邮箱发消息给我。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ReservoirSampling蓄水池抽样]]></title>
    <url>%2F2019%2F10%2F05%2FReservoirSampling%E8%93%84%E6%B0%B4%E6%B1%A0%E6%8A%BD%E6%A0%B7%2F</url>
    <content type="text"><![CDATA[如果说动态规划在日常使用中出现的次数可能不是特别多，可能更加是一个面试需要加的技能点的话，我今天整理的ReservoirSampling却是真真切切的业务需求中必备的技能，之前已经拥有了一定的实践尝试，这边和大家分享一下。 场景我司是一个车货匹配的信息平台，可以理解为货车版本的滴滴出行，货物天生比客运出行要有更加丰富的定制化场景，比如我从南京运一车梨子到上海，可能这个梨子是需要雨布去遮盖、可能需要棉被防摔等等，司机货主会在平台上利用文本进行定制化需求的描述，问题来了，有些不法分子可能会通过这个信息匹配平台进行不正当言论的交流、包括黄色反动暴力等内容。 我们team在后台设计了套召回率在95%以上的文本正常程度鉴别系统，能够保证至少95%的有问题的文本会被直接拦截，5%的文本会在拦截阈值x-0.3的以内，但是由于每日撮合信息量高达千万级别，在x-0.3以内的文本条数日高达十万级别的文本条数，问，如何保证尽可能多且实时的在阈值x-0.3以内寻找到尽可能多的有问题的文本信息。 问题剖析尽可能多很明显，不可能全量复审，那我们我们只能通过随机采样，而稍加分析数据或者有一定的风控经验的同学都知道，这些黑名单用户的活动都是批量进行的。其实，我们更多的均衡采点的效果不如分层采点：均衡采点：比如把数据流看成1，以等时长、等数据流的方式进行采样，去筛选有问题的文本。分层采点：比如把数据流看成N段1/N单独对象，1/N单独对象内以等概率的方式去采样，如果采样存在问题，则1/N单独对象内进行全覆盖复查。 实时很明显，就日聚合度的分布可以看出，分层采样捕获的问题样本会更多，但是会有一个问题。实际情况下，如果我们需要实时去捕获问题文本信息，如果我们是拿不到1/N中的N的，换句话说，我们不知道下一秒会有多少信息文本会被发出来，我们就做不到该段时间内的等概率抽样。 ReservoirSampling说了这么久，终于出现了我们的主角ReservoirSampling，蓄水池抽样。最初，我们的审核同学的人力是已知的，比如一共20个同学，每小时内可以人均审核300条，则一小时的池水量为6000条。我们实际做的时候，把一小时切分成6段，每段10分钟，在10分钟的分段内首先先保留阈值在x-0.3以内前600条，然后后面来的每一条以N/i的概率保留，并在原来600条中随机剔除一条。其中i为数据序号，此处N为600。当i&lt;=N的时候，每条数据进入池子的概率都是1。当i&gt;N的时候，当出行第N+1个满足条件的元素时，被保留的概率是N/(1+N)；被保留后，就需要计算剔除概率为N/(1+N)/N，1-N/(1+N)/N=N/(1+N)即为被保留的概率，所以池子内外被保留的概率相等。在这种方法下，我们只需要知道，我们在单位时间内需要保留多少个目标信息本文条数即可，无需在意单位时间内可能会出现多少条总量信息样本。然后复审同学只需要在t2时间，去审核t1时间内的产出的文本信息即可，不需要等待落表，存库，读库，采样等各种额外操作。一旦审核到任意一条文本有问题，则转交稽核同学全量审核。 LeetCode在leetcode中也是有相关的题目的： 398题随机数索引题目中的核心在于把N缩小成1，做了一个not randint(0,n)被采纳执行的逻辑，对于任意一次中间次数k+1，被保留的概率为1/(k+1)，未被保留，依旧保留上次的结果的概率为1/k*(k/(k+1))，为1/(k+1)，所以为等概率的。 382题链表随机节点题目中的跟上面一摸一样，先保存第一个也就是not randint(0,0)必为True，对于生下来的每次以not randint(0,n)进行保留，最后进行节点输出即可。我在GitHub中实际去实现的时候采用了普通方式，建议以我398题的方式去完善即可 总结蓄水池抽样的方式确确实实能够解决大家工作中的实际问题，实际使用中在原始的95%的召回的情况下，给力的提升了2.3pp的召回率。 ReservoirSampling蓄水池抽样就给大家整理到这，如果大家想看更多的数据结构问题，可以关注一下我的Github，希望有所帮助。 欢迎大家关注我的个人bolg，知乎，更多代码内容欢迎follow我的个人Github，如果有任何算法、代码、转行疑问都欢迎通过邮箱发消息给我。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[19年阶段性总结]]></title>
    <url>%2F2019%2F09%2F15%2F19%E5%B9%B4%E9%98%B6%E6%AE%B5%E6%80%A7%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[这篇文章无关技术，写的目的有两个： 19年已经过去了2/3，回顾一下19年到目前为止的得失，总结复盘，使得自己更好的完成19年初定的目标 反省一下最近几个月自己焦虑的心态，引以为戒，调整心态，避免以后再次发生这样的事情 半年度回顾年初既定目标完成情况 leetcode：从0开始，进入10000名，持续整理的刷题笔记，产出10篇相关的心得体会 目前13000名，距离目标还差3000名 持续进行笔记整理中LeetCode+校招真题分析 只有一篇心得体会： DynamicProgramming动态规划整理 学习两门新语言 java学习笔记:java笔记 c++学习笔记:c++笔记 整理python常用工具，真正做到高复用，高可用 PyTls，该包已经用作公司项目python包库，并整理出对应的使用手册 贡献了PyTricks，理解了python的部分自建函数的实际价值，并真实运用在项目中 整理了若干python技巧： Python踩坑指南（第三季） Python踩坑指南（第二季） Python踩坑指南（第一季） 3篇深度学习全新技术的理解： transform的理解 RCNN 待完成 10种熟悉的机器学习算法的深刻理解+源码分析： 进展0 得失leetcode部分是从5月份开始启动的，进展的一般，现在也逐步进入了每周3题-5题的水平，整体上来看，完成年初的目标没有多大问题。得：收获还是比较大的：熟悉了基础的数据结构：比如栈堆、hash表、树、列表、队列，也学会了很多小技巧，比如dp、贪心、双指针、链表、回溯等，确实在工作中对代码质量有一定的提升；失：能力还远远不够，还不能快速写出状态转移方程，遇到题目还是只会第一反应回溯，树还很生疏，各种排序还是不能拿过来1分钟之内写出来，还是需要多看多练，不够熟练。 语言方向上也是一直稳步提升，整体上来看，完成年初的目标没有多大问题。得：Java真有意思，C++写小游戏真好玩失：学习效率有点低，目前占据了大量的时间，希望后期能够优化 python部分，感觉有点小超额完成，还是很开心的，尤其是加入了PyTricks这个项目。得：学的很nice，该做的都做了给自己点个赞失：对协程还是理解不够，需要进一步加强，可以设置为2020年的既定目标 深度学习和机器学习，这个做的很差，Q4要着重去看下：得：几乎没有失：思维过于狭隘，只是抱着能用就行，先上线后优化的思想，每次遇到新的任务都采取了非常保守的策略及方法，速度效果都是可以达到baseline，但是没有任何深度上的提升，这个很危险 谈谈焦虑其实，这一年以来，我已经花费了绝大多数私人时间在自己的能力提升上，为此我甚至放弃了WOW怀旧服的工会邀请，但是在日常工作中还是被各种负能量影响着，每天都过的特别焦虑。 各种公众号上Ai工程师三个月40万入门培训； 各路Hr，猎头的疯狂邀约，最高的达到了13万刀的Facebook的offer，最差的也有月薪5000的助理算法工程师的邀约； 身边的同事整天被各种大厂拒绝的死去活来，甚至连简历都过不了； 身边的各种朋友发着阿里的周年庆，拼多多的年度盛典； 认识的大佬一年换了三个公司最后入职阿里负责整个算法后台，也有另外的大佬因为部门裁撤连房贷都没有钱去还； 工作项目的各种变动，带着一个自己都不清楚明天会怎么样的团队步履蹒跚的前进着 生活上各种意想不到的事情的发生 《摩拜创始人套现15亿：你的同龄人，正在抛弃你》、《北京，有2000万人假装在生活》、《第一批Ai工程师已经财富自由》这种垃圾文章在朋友圈，微信群，钉钉群，各种地方无孔不入，肆意蔓延，有时候我尽可能不去看不去点，但是真的是到处都是，到处都有。 我之前一直在想到底是什么导致我每天过的非常紧凑努力的生活中，依然认为自己很垃圾，认为自己不够尽力，认为自己很差劲；看到认识的朋友抱怨自己明明有很好的学校，很不错的背景，很强的代码能力，很不错的算法知识，但是还是一个offer都拿不到。我一直在想为什么？为什么会这样。 这个中秋节，我没有写什么代码，也没有看什么算法，不去关心谁跳槽去了哪拿了多高的工资，不在意哪个项目是否抛出了bug，我想我有点想通了一个道理：可能不是所有事情的增益都是线性的，因为一开始就给自己背上了沉重的包袱，当你真正开始着手的时候，你会倍感压力，你想快点去做，快点达到自己想要的，完成了就有收获。其实，不然。 警醒一下自己，我们都是普通人，把普通的事情做好，已经很不普通了，不可以再被周边的环境所影响。 你背单词时，阿拉斯加的鳕鱼正跃出水面;你算数学时，太平洋彼岸的海鸥振翅掠过城市上空;你晚自习时，极圈中的夜空散漫了五彩斑斓。但是少年你别着急, 在你为自己未来踏踏实实地努力时，那些你感觉从来不会看到的景色,那些你觉得终生不会遇到的人， 正一步一步向你走来。 这次，没有链接。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>公告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DynamicProgramming动态规划整理]]></title>
    <url>%2F2019%2F09%2F05%2FDynamicProgramming%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[整理一下刷题过程中的一些想法，方便以后高效复习，动态规划部分整理如下： 主要的思路有如下几种： 基础类型 只需要写出i和i-1之间的状态转移方程即可，没有任何额外操作的行为，比如： 一维度： 53. 最大子序和,状态方程是:dp[i] = max(dp[i-1]+nums[i],nums[i]) 70. 爬楼梯,状态方程是:result[i]=result[i-1]+result[i-2] 198. 打家劫舍,状态方程是:dp[i] = max(dp[i-3],dp[i-2])+nums[i] 高维度： 120. 三角形最小路径和,状态方程是:dp[k][z] = min((dp[k-1][z]+triangle[k][z]),(dp[k-1][z-1]+triangle[k][z])) 63. 不同路径 II,状态方程是:obstacleGrid[i][j] = obstacleGrid[i][j - 1] + obstacleGrid[i - 1][j] 64. 最小路径和,状态方程是:mat[i][j] = min(mat[i - 1][j], mat[i][j - 1]) + grid[i][j] 221. 最大正方形,状态方程是:dp[i][j] = min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]) + 1 中间变量类型 需要额外借助第三方变量进行中间值判断的： 121. 买卖股票的最佳时机,状态方程是:Math.max(profit, prices[i] - Math.min(minprofit, prices[i])); 139. 单词拆分,状态方程是:dp[j] = True if dp[i] and s[i:j] in wordDict 264. 丑数 II,状态方程是:int minval = Math.min(last_2,Math.min(last_3,last_5)); 定制判断类型 带有定制化的判断条件的： 72. 编辑距离,状态方程条件是：word1[j-1]==word2[i-1] 85. 最大矩形,状态方程条件是：matrix[i][j] != &#39;0&#39; 91. 解码方法,状态方程条件是：s[i] != &quot;0&quot;和s[i - 1] != &quot;0&quot; and int(s[i - 1:i + 1]) &lt;= 26 152. 乘积最大子序列,状态方程条件是：MAX, MIN = MIN, MAX if nums[i] &lt; 0 300. 最长上升子序列,状态方程条件是：if (nums[i] &gt; nums[j]) {dp[i] = Math.max(dp[i], dp[j] + 1);} 338. 比特位计数,状态方程条件是：if (i%2==1){ans[i] = ans[i-1]+1;} else {ans[i] = ans[i/2];} 倒叙逆向类型 174. 地下城游戏,状态转移方程是:dp[i][j] = max(1, min(dp[i + 1][j], dp[i][j + 1]) - dungeon[i][j])反方向的的递归，比较打破常规思维 循环判断类型 在dp的基础上需要再遍历已经扫过的数组。此类方法的复杂度一般较高: 279. 完全平方数,状态转移方程是：123while i - j ** 2 &gt;= 0: dp[i] = min(dp[i], dp[i - j ** 2] + 1) j += 1 预处理类型 740. 删除与获得点数这题麻烦在预处理每一个值，因为值有可能重复：123target = [0] * (max(nums) + 1)for num in nums: target[num] += num 之后的转移方程反而非常简单:d[i] = max(d[i - 1], d[i - 2] + target[i]) 技巧类型 940. 不同的子序列 II 这题在于要想到把字符转化对应的ASCII码，转移方程:array[ord(c)-ord(&quot;a&quot;)]=sum(array)+1，除此之外还需要想到新增一个字母等于当前所有字母后面可加+单独自身，这个方程确实非常非常有技巧 以上为LeetCode中比较有代表性的一些题目，把这些搞懂之后可以解决绝大多数dp的类似题型，以2020校招为例： 携程 - Deep learning Engineer 给定一个时刻表，根据目的地进行分组，同一个目的地必须尽可能的多分，不能打乱顺序，比如aabbcddc，需要分成aa|bb|cddc,而不能分成aabb|cddc，因为这种情况下不是最多，也不能分成aa|bb|c|dd|c,因为相同的c没有被分在一起；求分组个数； 这题就是典型的循环判断类型+中间变量类型，需要储存历史遍历结果并多次查询，代码解答 Tencent - Deep learning Engineer花匠摆花问题，两个坑：1.用traceback的就直接gg，比如我2.dp[i]为当前的长度为i的可摆放个数，dp[i] = dp[i-1]+dp[i-k]为状态转移矩阵，更多解释看代码注释 这题就是简单的基础类型，唯一难的地方是要想到i-k这个dp结果 Dynamic Programming 动态规划就给大家整理到这，如果大家想看更多的数据结构问题，可以关注一下我的Github，希望有所帮助。 欢迎大家关注我的个人bolg，知乎，更多代码内容欢迎follow我的个人Github，如果有任何算法、代码、转行疑问都欢迎通过邮箱发消息给我。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python踩坑指南（第三季）]]></title>
    <url>%2F2019%2F07%2F15%2FPython%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%88%E7%AC%AC%E4%B8%89%E5%AD%A3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[在代码维护的过程中，发现需要对某个变量进行保护，不允许调用修改，之前我一直使用的是_x或者__x的形式，这样做只是避免展示，但是如果想要强行修改，还是可以变更的，为了保证高安全性，这边可以参考@property的形式： 123456789101112class test(object): &quot;&quot;&quot;docstring for test&quot;&quot;&quot; def __init__(self, arg): self._arg = arg @property def arg(self): return self._arg @arg.setter def set_arg(self,val): self._arg=val 当想修改arg的值的时候，必须通过set_arg去修改，虽然仍然可以通过改_arg的方式，但是相对直接暴露多了一层保护；除此之外，它还可以实现一定的逻辑转化： 1234567891011121314151617181920212223242526272829303132333435In [10]: class test(object): ...: &quot;&quot;&quot;docstring for test&quot;&quot;&quot; ...: def __init__(self, arg): ...: self._arg = arg ...: self._half_arg = arg/2 ...: ...: @property ...: def arg(self): ...: return self._arg ...: ...: @property ...: def half_arg(self): ...: return self._half_arg ...: ...: @arg.setter ...: def set_arg(self,val): ...: self._arg=val ...: self._half_arg = val/2 ...:In [11]: t=test(10)In [12]: t.argOut[12]: 10In [13]: t.half_argOut[13]: 5.0In [14]: t.set_arg=20In [15]: t.argOut[15]: 20In [16]: t.half_argOut[16]: 10.0 利用None!=None的性质可以进行快速去None，比如： 1a = df[df.label_y==df.label_y] 可以快速的把label_y=None的列进行剔除，比dropna要快一些。 traceback可以很好的把错误信息进行暴露，1234try: 1/0except Exception,e: print e 如果这样包起来错误的花,输出结果是integer division or modulo by zero，只知道是报了这个错，但是却不知道在哪个文件哪个函数哪一行报的错 如果使用traceback: 1234try: 1/0except Exception as e: traceback.print_exc() 输出结果是：1234567Traceback (most recent call last): File “test_traceback.py”, line 3, in 1/0 ZeroDivisionError: integer division or modulo by zero 这个还不是精髓的，如果说在一个服务中，或者大型项目中，我们不会时时刻刻去盯着进程，还可以进行落日志，方便后续查看：123456traceback.print_exc(file=open(&apos;tb.txt&apos;,&apos;w+&apos;)) import timetry: 1/0except Exception as e: traceback.print_exc(file=open(str(time.time())+&apos;.txt&apos;,&apos;w+&apos;)) 欢迎大家关注我的个人bolg，知乎，更多代码内容欢迎follow我的个人Github，如果有任何算法、代码、转行疑问都欢迎通过邮箱发消息给我。]]></content>
      <categories>
        <category>代码集合</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transformer工程实现笔记]]></title>
    <url>%2F2019%2F07%2F01%2Ftransformer%E5%B7%A5%E7%A8%8B%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[上线形式：tensorflow直接加载上线基于openblas重新实现基于cublas库重新实现优点：tensorflow：有谷歌开源代码，不需要另外实现cublas/openblas：可以定制化优化，耗时更短，可微调缺点：tensorflow：耗时长，内部黑盒无法微调cublas/openblas：部分核心功能要重写，只支持基础包 以下为工程实现细节： input/output为序列： 基础架构： 每个Encoders中分别由6个Encoder组成（论文中是这样配置的）。而每个Decoders中同样也是由6个Decoder组成： 假设现在存在一个输出vocabulary为32768，输入vocabulary53000流程： 切词/embedding 0位置不可用，1位置为EOS，作为空格等其他非文本符号的替换 输入词embedding 将词转化为下标 通过映射来查找 输入词embedding维度：1024float 输入词embedding初始化结果来源：w2v 输入词位置信息embedding：左半部分的值是一由一个正弦函数生成的，而右半部分是由另一个函数（余弦）生成。其中，get_timing_signal_1d()源码地址 input Embedding = word Embedding + position Embedding Encode（假设每个batch有15个input词） multi-headed attention self-attention 创建一个Query/Key/Value的矩阵，单个矩阵size：1024(16(头数量)x64(q,k,v向量的长度))x1024(词向量的长度) Query/Key/Value的矩阵合并后为15x3x1024x1024 将query向量和key向量点击来对相应的单词打分 再将得到的输出通过softmax函数标准化，使得最后的列表和为1 将每个Value向量乘以softmax后的得分。这里实际上的意义在于保存对当前词的关注度不变的情况下，降低对不相关词的关注。 QK的点击为15x64x64x15，结果15x15，这样的矩阵有16个，再对此进行sotfmax压缩 如果batch小于15，则填充负无穷 KQ的15x15x16再点积V=XxWv15x64x16，16个15x64的矩阵 KQxV得16x(15x15x15x64)=16x15x64 后接一个dense，1024x1024，得到15x1024 add一个bias，再normalization resudual feed forward neural network multi-headed attention前的矩阵设为in multi-headed attention后的矩阵设为out 残差处理：Z = sqrt(∑(out-in)xx2) 第一层的激活函数是ReLU，第二层是一个线性变换，W1和W2分别为1024x4096，4096x1024 encode out = resudual feed forward neural network in + resudual feed forward neural network out Encoder结束 Decode过程与Encode过程保持一致，不同点如下： Decode出来靠近的词更重要，则把对应的input的矩阵的上三角矩阵进行mask，保证尽量减少对已经decode出来的词的影响 self-attention – &gt; resudual —&gt; in/out attention —&gt; resudual —&gt; FFN —&gt; resudual，一次解码完成 每次计算Decode完成后把decode出来的词进行储存，下一次的input直接拼接之前m次的带入下一次decode即可 参数矩阵：KV来自encode部分计算好的（1024x2048），Q来自decode部分新建的（1024x1024） Decode:Q:nx16x64,K/V:15x16x64,QK:16x(nx64)x(15x64)= 16xnx15QKxV=16x(nx15x15x64)=nx1024，n即为decode得词数 Q的行数是Decode的词的数量，第一轮是1，第二轮是2…，解多少个词就有多少轮 Decode出来的结果矩阵点乘vocabulary_sizex1024，得出vocabulary_size的向量后softmax（所有vocabulary_size和为1），得到top8 beam search，beam=4，一直算到eosid；如果下一个就是eosid的话，用top8其他的其他4个 trick： Embedding采取半float，绝大多数都是0，所以不会对最后的结果有很大影响 出现eosid及finished的时候，记一次综合score，当后续继续往下解beam search的时候score不如之前的话就以综合score出现的地方为截止点 train的过程中，input_size+50为最长decode长度，降低学习耗时 欢迎大家关注我的个人bolg，知乎，更多代码内容欢迎follow我的个人Github，如果有任何算法、代码、转行疑问都欢迎通过邮箱发消息给我。]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语音转译文本后的意图识别(YMMNlpUtils)]]></title>
    <url>%2F2019%2F06%2F25%2F%E8%AF%AD%E9%9F%B3%E8%BD%AC%E8%AF%91%E6%96%87%E6%9C%AC%E5%90%8E%E7%9A%84%E6%84%8F%E5%9B%BE%E8%AF%86%E5%88%AB-YMMNlpUtils%2F</url>
    <content type="text"><![CDATA[上个月由于业务需要，定制化了一个中文语境下的手机号码识别的功能，并开源为YMMNlpUtils DEMO解析 Github地址 现在由于业务需求，又新增了一个语音对话过程中是否存在手机号交换行为意图的识别，所以更新了一个版本YMMNlpUtils==0.1.1 实际拿来用的数据比想象中的要更加混乱，主要是由于我们的用户方言很重且经过了一轮科大讯飞语音转文本的信息转译，所以不少信息丢失，比如： 1你等会让我jj#等会儿。是名额的香车翻起来！好，你说6.2。有三，有牛有。U0150508。6050508。50568号。 我们设计的算法流程如下： 内容解释如下： 12345678910我们认为语音文本中存在手机号为正样本，text training data：基础本文信息text features：本wiki中整理出来的featuresP-Learn（全量）：正样本N-Learn（采样）：黄色背景为纳入计算的采样负样本，蓝色背景为未纳入计算的采样负样本outliers：去异常点，采取了概率分布越界原则OneHotEncoder：离散化standardize：标准化1-3_grams：朴素贝叶斯+2-grams+3-gramsPredict1_4：为concat形式[predict1,predict2,predict3,predict4] 实际线上效果如下： 使用Demo如下：123456789from YMMNlpUtils import YMMPhoneDistinguishobj = YMMPhoneDistinguish(show_reason=False, user_dict=None, stop_words=None)#:param show_reason:是否需要展示被识别出来的原因#:param user_dict:用户自定义词典，默认调用自带词典#:param stop_words:自定义停顿词In [8]: obj.predict(&quot;你等会让我jj#等会儿。是名额的香车翻起来！好，你说6.2。有 ...: 三，有牛有。U0150508。6050508。50568号。&quot;,0.92)Out[8]: (0.9527009149362651, 1)# 0.92为默认阈值，可以自行修改 Reason解析如下：-1:&quot;无原因&quot;, 0: &quot;逻辑拼接&quot;, 1: &quot;命中敏感词&quot;, 2: &quot;疑似电话数字&quot;, 3: &quot;数字过长&quot;, 4: &quot;涉及微信号码敏感&quot; 阈值调整建议如下： 阈值 精确率 召回率 0.5 99.40% 95.20% 0.6 99.50% 94.50% 0.7 99.60% 93.30% 0.8 99.60% 90.80% 0.9 99.70% 83.60% 0.91 99.70% 82.40% 0.92 99.70% 80.60% 0.93 99.80% 78.00% 0.94 99.80% 75.70% 0.95 99.80% 72.80% 开源代码详见Github 欢迎大家关注我的个人bolg，知乎，更多代码内容欢迎follow我的个人Github，如果有任何算法、代码、转行疑问都欢迎通过邮箱发消息给我。]]></content>
      <categories>
        <category>代码集合</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python踩坑指南（第二季）]]></title>
    <url>%2F2019%2F05%2F28%2FPython%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%88%E7%AC%AC%E4%BA%8C%E5%AD%A3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[本期围绕jieba讲一个我遇到的实际问题，在同一个服务里，存在两个不同接口A和B，都用到了jieba分词，区别在于两者需要调用不同的词库，巧合中，存在以下情况： 12词库A：&quot;干拌面&quot;词库B：&quot;干拌&quot;,&quot;面&quot; 在服务启动的时候，由于词库A优先被加载了，再去加载词库B的时候发现，并没有加载成功： 接口A中：1jieba.load_userdict(&quot;A.txt&quot;) 接口B中：1jieba.load_userdict(&quot;B.txt&quot;) 结果发现，在切干拌面这个词的时候，接口B中还是没有切成功。其实每次在我们加载jieba的时候，可以注意一下会出现以下info：1234Building prefix dict from the default dictionary ...Dumping model to file cache /var/folders/hv/kfb7n4lj06590hqxjv6f3dd00000gn/T/jieba.cacheLoading model cost 0.824 seconds.Prefix dict has been built succesfully. 显而易见，先进行了Building prefix dict，再Dumping model to file cache，后续Loading model都会来自这，所以这个地方导致以上问题。 我是这么处理的：接口A中：1jieba1 = jieba.Tokenizer(dictionary=&quot;A.txt&quot;) 接口B中：1jieba2 = jieba.Tokenizer(dictionary=&quot;B.txt&quot;) 案例如下：12345678910111213141516171819In [1]: import jiebaIn [2]: jieba1=jieba.Tokenizer(dictionary=&quot;A.txt&quot;)In [3]: jieba2=jieba.Tokenizer(dictionary=&quot;B.txt&quot;)In [4]: jieba1.lcut(&quot;干拌面&quot;)Building prefix dict from /Users/slade/Desktop/A.txt ...Dumping model to file cache /var/folders/hv/kfb7n4lj06590hqxjv6f3dd00000gn/T/jieba.u5221c1b70f06b36e44bc519f39715c96.cacheLoading model cost 0.006 seconds.Prefix dict has been built succesfully.Out[4]: [&apos;干拌面&apos;]In [5]: jieba2.lcut(&quot;干拌面&quot;)Building prefix dict from /Users/slade/Desktop/B.txt ...Dumping model to file cache /var/folders/hv/kfb7n4lj06590hqxjv6f3dd00000gn/T/jieba.uc4f38d90bf7ce748744ff94fb2863fe4.cacheLoading model cost 0.003 seconds.Prefix dict has been built succesfully.Out[5]: [&apos;干拌&apos;, &apos;面&apos;] 需要注意的是，去看Tokenizer源码，里面有这么一段读取调用：1234567891011121314151617181920def gen_pfdict(self, f): lfreq = &#123;&#125; ltotal = 0 f_name = resolve_filename(f) for lineno, line in enumerate(f, 1): try: line = line.strip().decode(&apos;utf-8&apos;) word, freq = line.split(&apos; &apos;)[:2] freq = int(freq) lfreq[word] = freq ltotal += freq for ch in xrange(len(word)): wfrag = word[:ch + 1] if wfrag not in lfreq: lfreq[wfrag] = 0 except ValueError: raise ValueError( &apos;invalid dictionary entry in %s at Line %s: %s&apos; % (f_name, lineno, line)) f.close() return lfreq, ltotal 在load_userdict的时候词库的词频可以省略不写，word, freq = line.split(&#39; &#39;)[:2]决定了这边需要加上，这个依赖于版本，我并没有实验不同版本。 A.txt:1干拌面 1 B.txt:12干拌 1面 1 欢迎大家关注我的个人bolg，知乎，更多代码内容欢迎follow我的个人Github，如果有任何算法、代码、转行疑问都欢迎通过邮箱发消息给我。]]></content>
      <categories>
        <category>代码集合</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F2019%2F05%2F28%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[我一直觉得算法工程师，两把刷子，过硬的算法基础知识，可靠的代码工程能力即可； 最近和一些老朋友交流了一下，发现理想很丰满，现实很残酷，在自己觉得自己会了点机器学习知识的时候，结果连和别人沟通讲自己会的东西的机会都没有，还没开始就被卡死在了数据结构这一关上；能想到的，只有时间或者空间复杂度最差的那种解法。一言不合就是遍历，不行就o(n**2)，真的是弱鸡的不行 所以我觉得，是时候把大学做的leetcode捡起来再做一做了，其实在很早的时候，我就在GitHub分享过一些我遇到过的数据结构的问题，但是当时可能觉得不重要，更新了一段时间之后就停止了，现在仔细想想真的是有所失误，好在一切还不晚。 关于刷leetcode这事，你可以往三个方向上走。一是按照从easy到medium到hard的方向。二是按照分类走，比如先刷树相关的，再刷数组相关的，依次类推。最后一种是我用的就是完全随机的取刷；我觉得自己疯狂刷完dp问题，过了两周又忘完了这样就是非常蠢的，做着做着来一题强化一下记忆，这样才会记得更清楚。 在语言选择上，Python的小trick还是有点多的，就比如字符串表达式的值，我们用eval函数就可以得到，但是请不要这么去用，这样非常的投机取巧，在真的需要去讲去面试的时候，绝对不可能让你这么去用的；如果忍不住，就用java或者C。 除了在Leetcode上面刷题外，有两本书可以给大家参考，一是《剑指offer》，二是《算法导论》，大家可以自行选择。 最后贴上我现在做题及做题心得的GitHub地址，如果有比较困难理解的地方，我都在代码里面注释了，希望能帮到大家，就这样了。补充一点，在README里面我在有些题目下面注释了一些心得，建议可以优先把这些题目看下，我觉得还是很有意思的。 欢迎大家关注我的个人bolg，知乎，更多代码内容欢迎follow我的个人Github，如果有任何算法、代码、转行疑问都欢迎通过邮箱发消息给我。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python踩坑指南（第一季）]]></title>
    <url>%2F2019%2F05%2F14%2FPython%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%88%E7%AC%AC%E4%B8%80%E5%AD%A3%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近在python开发的过程中，发现了一些比较有意思的问题，确实让自己在开发过程中被恶心了一把，所以开了这个连续的更新博文，之后会持续的按第一第二第三这种版本下去，更新一些比较有意思的python代码问题。 12with open(&apos;/path/to/file&apos;, &apos;r&apos;) as f: print(f.read()) IO读取采用with形式，避免忘记close，否则会产生很神奇的结果 1embereding_data.drop_duplicates(keep=&apos;first&apos;,inplace=True) python 中删除重复项 如果在原来数据上删除重复项，就要加入inplace=True否则 只是保存一个副本！！！ 1pd.read_csv(filename,error_bad_lines=False) pandas.errors.ParserError: Error tokenizing data. C error: Expected 1 fields in line 3, saw 2解决办法在使用pandas读取csv文件时报以上错误，解决办法如左加上error_bad_lines=False就可以完美解决了 1str = &quot; &quot;.join(list(map(str, l))) myList = [‘a’,’b’,’c’,’d’] myString = “,”.join(myList ) 当myList含有数字的时候这种方法就会报错 因此需要转为str 1json.loads(&apos;key&apos;:value) value不可以为set、tuple 1234d3=&apos;&#123;&quot;Message&quot;:&quot;已注销帐户。\r\n\r\n使用者:\r\n\t安全&quot;&#125;&apos;j=json.loads(d3,strict=False,encoding=&apos;utf-8&apos;)print(type(j)) #返回值：&lt;type &apos;dict&apos;&gt;print(j[&apos;Opcode&apos;].encode(&apos;u8&apos;)) #返回值：信息 使用json.loads时，如果原字符串中包含有 \r\n\t等字符，则会提示报错,修改参数strict=False即可 说明：”If strict is False (True is the default), then control characters will be allowed inside strings. Control characters in this context are those with character codes in the 0-31 range, including ‘\t’ (tab), ‘\n’, ‘\r’ and ‘\0’.” 12data[&apos;county_route_index&apos;] = data.apply(lambda x: str(x.start_county_cd) + &apos;_&apos; + str(x.end_county_cd),axis=1) 生成county_route_index字段示例310112.0_320583.0，而start_county_cd、end_county_cd为整型（int64）解决办法：1.str(x.start_county_cd)改为str(int(x.start_county_cd))2.df[‘col3’] = df[‘col1’].map(str) + ‘_’ + df[‘col2’].map(str) 12345678arr = (12,[1,3,3,4],&apos;b&apos;)arr[1]+=[6]---------------------------------------------------------------------------TypeError Traceback (most recent call last)&lt;ipython-input-15-6bc7f041d391&gt; in &lt;module&gt;()----&gt; 1 arr[1]+=[6]TypeError: &apos;tuple&apos; object does not support item assignment 但是实际上却操作成功：12In [16]: arrOut[16]: (12, [1, 3, 3, 4, 6], &apos;b&apos;) 不要混合使用list和tuple的时候使用concat操作 1234567def func(a,b):if a ==1: return belse: return 1-bbbs_data[&quot;real_label&quot;] = bbs_data.apply(lambda row:func(row[2],row[3]),axis = 1) dataframe 某列的值根据其他列的值计算得来 12345678910pRec = &#123;&#125;import functoolsdef check_is_key_param(f): global pRec @functools.wraps(f) def wrapper(*args, **kwargs): pRec.update(f(*args, **kwargs)) return f(*args, **kwargs) return wrapper 收集计算过程中的中间数据 我觉得python确实是比较容易入门的语言，代价是它带来的不稳定性确实也是比较高，需要积累踩坑 欢迎大家关注我的个人bolg，知乎，更多代码内容欢迎follow我的个人Github，如果有任何算法、代码、转行疑问都欢迎通过公众号发消息给我。]]></content>
      <categories>
        <category>代码集合</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中文语境下的手机号识别]]></title>
    <url>%2F2019%2F05%2F13%2F%E4%B8%AD%E6%96%87%E8%AF%AD%E5%A2%83%E4%B8%8B%E7%9A%84%E6%89%8B%E6%9C%BA%E5%8F%B7%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[最近在做一个关于中文大段文本中的手机号码识别，由于属于对抗性的一个文本，发现传统的手机号码识别方法，比如正则匹配并不是很适用。 理论情况下文本中的手机号码出现方式应该如下：19*6箱车转让，连线路一起打包，带线路转让，固定货源联系13802131234,手机号，非诚勿扰2+1合同 对于这种情况，只要需要进行一下正则就行了：123text = &apos;9*6箱车转让，连线路一起打包，带线路转让，固定货源联系13802131234,手机号，非诚勿扰2+1合同&apos;mobilephone_pattern = &quot;1\d&#123;10&#125;&quot;phoneNumbers = re.findall(mobilephone_pattern, text, flags=0) 得到了如下结果：12In [36]: phoneNumbersOut[36]: [&apos;13802131234&apos;] 但是实际情况下，第三方会进行逃避规则的操作，出现了比如：19*6箱车转让，连线路一起打包，带线路转让，固定货源联系138-02##131234,手机号，非诚勿扰2+1合同 19*6箱车转让，连线路一起打包，带线路转让，固定货源联系138-洞2##幺3幺234,手机号，非诚勿扰2+1合同 甚至还会有：19*6箱车转让，连线路一起打包，带线路转让，固定货源联系1衫8-洞2##幺散幺2删4,手机号，非诚勿扰2+1合同 这样的情况下，继续通过规则就难以实现了：12In [38]: re.findall(mobilephone_pattern, text, flags=0)Out[38]: [] 所以，我们做了一个拼音转译+循环判断的逻辑进行了优化，会先把文本处理一边：1234567891011121314In [37]: text = &apos;9*6箱车转让，连线路一起打包，带线路转让，固定货源联系1衫8-洞2##幺散幺2删4,手机号，非诚勿扰2+1合同&apos;In [38]: re.findall(mobilephone_pattern, text, flags=0)Out[38]: []In [39]: from YMMNlpUtils import YMMNlpUtilsIn [40]: obj = YMMNlpUtils(strict=True)In [41]: obj.get_all_phone_number(text)Out[41]: &apos;96箱车转让连线路17打包带线路转让固定货源联系13802131234手机号非诚5扰21合同&apos;In [42]: re.findall(mobilephone_pattern,obj.get_all_phone_number(text), flags=0)Out[42]: [&apos;13802131234&apos;] 这样处理完就可以得到手机号码了。 由于是定制化的功能，后期可能还会维护出微信号，身份证号这些，更多的可以去git看一下，放上地址链接手机号码小工具，安装方法在README里面有解释。 欢迎大家关注我的个人bolg，知乎，更多代码内容欢迎follow我的个人Github，如果有任何算法、代码、转行疑问都欢迎通过邮箱发消息给我。]]></content>
      <categories>
        <category>代码集合</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PKUseg在货运领域的评测]]></title>
    <url>%2F2019%2F01%2F14%2FPKUseg%E5%9C%A8%E8%B4%A7%E8%BF%90%E9%A2%86%E5%9F%9F%E7%9A%84%E8%AF%84%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[先说结论，再和大家闲聊，对比jieba与PKUseg在公路货运切词能力上： 默认模型下，jieba效果优于PKUseg PKUseg提供场景精细化的预训练（还没有提供入口），长远来讲适合专业领域使用 PKUseg在特定的场景下有令人惊喜的效果（地址切分） 给大家的建议就是，如果大家赶时间求稳定适应范围需要非常广的时候，目前来说jieba是非常好的选择，如果说在面临一些精细化领域的特殊需求的时候，可以用PKUseg进行一波尝试，有意外惊喜。 那是一个风和日丽的早上，突然群里老大发出一条消息：我感觉我的心脏有一丝隐隐作痛的感觉，人在办公室坐，活从天上来，虽然身后站着一堆催上线的产品，我还是屈服于老大的正义（淫威，开玩笑的，别认真），简单测评了新出来的PKUseg与Jieba在公路货运/运输行业上的效果对比。 在我们的热词数据库中已经有人工切词完成的2万多条货运的词条：1234567891011121314151617181920description standard高博集团装货卸宝华 高博 集团 装货 卸 宝华北安到吉林农安饲料90吨每吨105 北安 到 吉林 农安 饲料 90吨 每吨 105需要4个车 需要 4个 车叶张公路装香闵路曲吴路两卸 叶张公路 装 香闵路 曲吴路 两卸从福通物流到吴滩镇 从 福通 物流 到 吴滩镇霞浦宏霞路到中通物流 霞浦宏霞路 到 中通物流石大路3场到德兴西门山 石大路 3场 到 德兴 西门山公园西路装 公园 西路 装不押车每吨150 不 押车 每吨 150速订价钱好商量 速订 价钱 好商量慈溪胜山装 慈溪 胜山装好装好卸高价急走 好装好卸 高价急走九顶山路与东方大道位置装货可以配货 九顶 山路 与 东方 大道 位置 装货 可以 配货要二部 要 二部青浦工业园区久远路提货到奉贤新杨公路进仓 青浦 工业园区 久远路 提货 到 奉贤 新杨公路 进仓园光路装博学南路卸 园光路 装 博学南路 卸公兴装卸荣昌广顺 公兴 装卸 荣昌 广顺打备注电话18458331112 打 备注 电话 18458331112... 首先看，不加任何词库，预训练下的，最后的效果对比：可以看到，在默认的分词模型下，jieBa分词还是拥有绝对优势的，但是在pkuSeg的git里面 所以我想看看能不能进行一下预训练下后再对比一下，可惜的是我在git（git地址传送门）上找了半天也没有找到预训练的入口，只有已经被官方预训练好的词库等有时间了，可以邮件沟通一下再补充这个部分的效果对比，我觉得，应该还是有提升的。 但是，在我们实际去测的过程中，我们发现了一些差异话的东西比较有意思。我们其实现在在做一个语音发货的产品，涉及到把一串地址切分开的需求： 其中涉及到地址切分的时候，jieba的能力会比如PKUseg要弱不少，比如“山西大同”，“上海浦东”，我们需要把一级二级地址切开的时候，PKUseg可以做到，而jieba并不能按照需求切块。所以，我们已经打算在地址模块切换PKUseg的模型来适应了。 最后吐槽一下，虽然我知道PKUseg需要加载模型，但是一加载就是一二十秒也是有点夸张了。酒浆，各位下回见。 欢迎大家关注我的个人bolg，知乎，更多代码内容欢迎follow我的个人Github，如果有任何算法、代码、转行疑问都欢迎通过公众号发消息给我。]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pandas中的问题记录]]></title>
    <url>%2F2018%2F10%2F23%2Fpandas%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[最近发现pandas的一个问题，记录一下：有一组数据（test.txt）如下：12345620181016 1483068029890327320181016 1483960347395306920181016 1483960347395307920181016 1483960347395308920181016 1483960347395309920181016 14839603473953019 剖析出来看，数据是按照\t进行分隔的：&#39;20181016\t14830680298903273\n&#39;123with open('test.txt','r') as f:line = f.readline()print(line) 我平时一直在用pandas去读数据，所以我很熟练的写下来如下的代码：pd.read_table(&#39;test.txt&#39;,header=None)然后发现，第一列变成了科学记数法的方式进行存储了： 很明显，科学记数法是可以转换的：12345678def as_number(value):try:return &apos;&#123;:.0f&#125;&apos;.format(value)except:return value# 应用到目标列去即可data.uid.apply(as_number) 诡异的事情发生了，对于14830680298903273在as_number函数转换下变成了14830680298903272，理论上讲14830680298903273没有小数部分不存在四舍五入的原因，网上搜了也没有很明确的解释，初步讨论后猜测应该是pandas在用float64去存这种长度过长的数字的时候有精度丢失的问题。 要解决也是很简单的： 用open的形式打开，在切割逐步去用list进行append，在合并 用read_table的函数的时候，默认是用float64去存在的，改成object去存(dtype=object) 在生产数据的时候，对于这种过长的数据采取str的形式去存 也是给自己提个醒，要规范一下自己的数据存储操作，并养成数据核对的习惯。 欢迎大家关注我的个人bolg，知乎，更多代码内容欢迎follow我的个人Github，如果有任何算法、代码、转行疑问都欢迎通过公众号发消息给我。]]></content>
      <categories>
        <category>代码集合</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[YoutubeNet的数据答疑]]></title>
    <url>%2F2018%2F10%2F16%2FYoutubeNet%E7%9A%84%E6%95%B0%E6%8D%AE%E7%AD%94%E7%96%91%2F</url>
    <content type="text"><![CDATA[实在是太忙了，抽空给大家解析一下之前写的YoutubeNet的数据是怎么构造的，协助大家可以自行构造一下。 这边和大家说一下，我没有上传数据的原因有两个： 涉及公司的数据财产，不方便上传 懒得做脱敏处理 数据一共有1300多万条，传输实在不方便 主要数据处理的部分在map_id_idx.py脚本下，其中包含all_item_20180624.txt和click_thirty_day_data_20180609.txt两个数据集合。 其中，all_item_20180624.txt是当日所有的商品集合：包含’Prd_Id’, ‘ItemId’, ‘BrandId’, ‘MsortId’和‘GenderId’五列，分别代表着商品id，skuid，低级品牌id，中级品牌id，产品性别，最后形如： 1234567891011125675 50000055 175 1500 32577 50000056 187 66 32002 50000057 63 11 22007 50000058 137 58 32075 50000060 80 50 32348 50000061 138 16 2423 50000062 162 237 3469 50000063 10 1500 31102 50000064 176 11 11896 50000066 37 27 12489 50000067 27 44 1... click_thirty_day_data_20180609.txt为近三十天的用户点击流，包含’UId’, ‘ItemId’, ‘clickTime’三列，分别代表着uid、点击的skuid，点击时间，最后形如： 12345678910111234 51668064 152860240634 51890512 152878838934 51884724 152878839334 51884720 152878839934 51884718 152878841434 51580974 152878844234 51854970 152878848734 51514910 152878849934 51855000 152878853534 51854990 152878856934 51854998 1528788572... 通过map_id_idx.py对所有的商品进行标序号，然后带入用户的点击流中，方便后期做embedding操作，就酱。 欢迎大家关注我的个人bolg，知乎，更多代码内容欢迎follow我的个人Github，如果有任何算法、代码、转行疑问都欢迎通过公众号发消息给我。]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GloVe向量化做文本分类]]></title>
    <url>%2F2018%2F09%2F25%2FGloVe%E5%90%91%E9%87%8F%E5%8C%96%E5%81%9A%E6%96%87%E6%9C%AC%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[向量化在之前，我对向量化的方法一直局限在两个点， 第一种是常规方法的one-hot-encoding的方法，常见的比如tf-idf生成的0-1的稀疏矩阵来代表原文本： 这种方法简单暴力，直接根据文本中的单词进行one-hot-encoding，但是数据量一但大了，这个单句话的one-hot-encoding结果会异常的长，而且没办法得到词与词之间的关系。 第二种是基于神经网络的方法，常见的比如word2vec，YouTubeNet： 这种方法（这边以CBOW为例子）都是初始一个固定长度的随机向量作为每个单词的向量，制定一个目标词的向量，以上下文词向量的sum结果作为input进行前向传递，使得传递的结果和目标词向量尽可能一致，以修正初始的随机向量。换句话说，就是刚开始，我随意定义生成一个vector代表一个词，然后通过上下文的联系去修正这个随机的vector。好处就是我们可以得到词与词之间的联系，而且单个词的表示不复杂，坏处就是需要大量的训练样本，毕竟涉及到了神经网络。 最近，我们突然发现了第三种方法，GloVe向量化。它也是开始的时候随机一个vector作为单词的表示，但是它不利用神经网络去修正，而是利用了一个自己构造的损失函数： 通过我们已有的文章内容，去是的这个损失函数最小，这就变成了一个机器学习的方法了，相比较暴力的前馈传递，这也高快速和高效的多。同时，它还兼具了word2vec最后结果里面vector方法的优点，得到词与词之间的联系，而且单个词的表示不复杂。 这边就不展开GloVe算法的细节了，后面有空和大家补充，这个算法的构造非常巧妙，值得大家借鉴一下。 文本分类刚才开门见山的聊了蛮久向量化，看起来和文本分类没什么关系，确实在通常意义上来讲，我们的最简单最常用的方法并不是向量化的方法，比如通过朴素贝叶斯，N-Grams这些方法来做分类识别。 tfidf+N-grams1.其实很简单，首先对语料库进行切词，维护自己的词典，做高频词的人工复审，将无意词进行stop_words归总 可以看到，高频词其实是非常非常少的，而且如果你真的去做了，你就会发现，”了”、“的”、“啊”这种语气词，和一些你公司相关的领域词汇会非常靠前，这些词作为stop_words会有效的降低训练成本、提高模型效果。 2.进行tf-idf，将词进行重赋权，字词的重要性随着它在文件中出现的次数成正比增加，但同时会随着它在语料库中出现的频率成反比下降，有效的将向量化中的one hot encoding结果进行了修正。但是依然存在问题：在TFIDF算法中并没有体现出单词的位置信息。 123456# sublinear_tf：replace tf with 1 + log(tf)# max_df：用来剔出高于词频0.5的词# token_pattern：(?u)\b\w+\b是为了匹配出长度为1及以上的词，默认的至少需要词长度为2# ngram_range：这边我做了3-grams处理，如果只想朴素计算的话(1,1)即可# max_features：随着我做了各种宽松的条件，最后生成的词维度会异常大，这边限制了前3万vectorizer = TfidfVectorizer(stop_words=stpwrdlst, sublinear_tf=True, max_df=0.5, token_pattern=r"(?u)\b\w+\b",ngram_range=(1, 3), max_features=30000) 不得不说，python处理机器学习，深度学习的便捷程度是异常的高。 3.在经过TfidfVectorizer处理之后的结果是以稀疏矩阵的形式来存的，如果想看内容的话，可以用todense()转化为matrix来看。接下来，用贝叶斯来训练刚才得到的矩阵结果就可以了。 12mnb_tri = MultinomialNB(alpha=0.001)mnb_tri.fit(tri_train_set.tdm, tri_train_set.label) tf-idf + n-grams + naive-bayes + lr这种方法是上面方法的升级版本，我们先看下架构： 其实主要差异在于右侧的算法模型详细部分，我们做了一个由3-grams到3-grams+naive-bayes+lr的扩充，提升精度。 在模型的过程中，上面的第一步，都是一样的，在第二、三步有所差异：2.在第二步中，我们除了要构造出一个3-grams的sparse matrix也需要构造出一个朴素的sparse matrix 12# 朴素结果vectorizerby = TfidfVectorizer(stop_words=stpwrdlst, token_pattern=r"(?u)\b\w+\b", max_df=0.5, sublinear_tf=True,ngram_range=(1, 1), max_features=100000) 3.不仅仅用bayes进行一次分类，而是根据3-grams和朴素情况下的sparse matrix进行预测，再用logistics regression来合并两个的结果做个stack进行0-1压缩。 12345# 构造出一个3-grams的sparse matrix也需要构造出一个朴素的sparse matrixmnb_tri = MultinomialNB(alpha=0.001)mnb_tri.fit(tri_train_set.tdm, tri_train_set.label)mnb_by = MultinomialNB(alpha=0.001)mnb_by.fit(by_train_set.tdm, by_train_set.label) 123# 加bias，cv选择最优正则结果，lbfgs配合l2正则lr = LogisticRegressionCV(multi_class="ovr", fit_intercept=True, Cs=np.logspace(-2, 2, 20), cv=2, penalty="l2",solver="lbfgs", tol=0.01)re = lr.fit(adv_data[['f1', 'f2']], adv_data['rep_label']) 总结一下上面两种方法，我觉得是入门快，效果也不错的小练手，也是完全可以作为我们开始一个项目的时候，用来做baseline的方法，主要是快啊～/斜眼笑 GloVe+lr因为我目前的带标签数据比较少，所以之前一直没有敢用word2vec去向量化作死，但是GloVe不存在这个问题啊，我就美滋滋的进行了一波。首先，先讲下GloVe的使用： https://github.com/stanfordnlp/GloVe 在最大的代码抄袭网站下载(git clone)坦福大佬的代码，友情提醒，不要作死自己看了理论就觉得自己会写，自己搞个GloVe。(别问我是怎么知道的) cd到对应目录下，vim demo.sh这个文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#!/bin/bashset -e# Makes programs, downloads sample data, trains a GloVe model, and then evaluates it.# One optional argument can specify the language used for eval script: matlab, octave or [default] python# 请把make这边注释掉，这个是让你去下个demo，我们直接改成自己的数据# make# if [ ! -e text8 ]; then# if hash wget 2&gt;/dev/null; then# wget http://mattmahoney.net/dc/text8.zip# else# curl -O http://mattmahoney.net/dc/text8.zip# fi# unzip text8.zip# rm text8.zip# fi# CORPUS需要对应自己的欲训练的文档CORPUS=content.txtVOCAB_FILE=vocab.txtCOOCCURRENCE_FILE=cooccurrence.binCOOCCURRENCE_SHUF_FILE=cooccurrence.shuf.binBUILDDIR=buildSAVE_FILE=vectorsVERBOSE=2MEMORY=4.0# 单词至少出现几次VOCAB_MIN_COUNT=3# 向量长度VECTOR_SIZE=128# 迭代次数MAX_ITER=30# 窗口长度WINDOW_SIZE=15BINARY=2NUM_THREADS=8X_MAX=10echoecho "$ $BUILDDIR/vocab_count -min-count $VOCAB_MIN_COUNT -verbose $VERBOSE &lt; $CORPUS &gt; $VOCAB_FILE"$BUILDDIR/vocab_count -min-count $VOCAB_MIN_COUNT -verbose $VERBOSE &lt; $CORPUS &gt; $VOCAB_FILEecho "$ $BUILDDIR/cooccur -memory $MEMORY -vocab-file $VOCAB_FILE -verbose $VERBOSE -window-size $WINDOW_SIZE &lt; $CORPUS &gt; $COOCCURRENCE_FILE"$BUILDDIR/cooccur -memory $MEMORY -vocab-file $VOCAB_FILE -verbose $VERBOSE -window-size $WINDOW_SIZE &lt; $CORPUS &gt; $COOCCURRENCE_FILEecho "$ $BUILDDIR/shuffle -memory $MEMORY -verbose $VERBOSE &lt; $COOCCURRENCE_FILE &gt; $COOCCURRENCE_SHUF_FILE"$BUILDDIR/shuffle -memory $MEMORY -verbose $VERBOSE &lt; $COOCCURRENCE_FILE &gt; $COOCCURRENCE_SHUF_FILEecho "$ $BUILDDIR/glove -save-file $SAVE_FILE -threads $NUM_THREADS -input-file $COOCCURRENCE_SHUF_FILE -x-max $X_MAX -iter $MAX_ITER -vector-size $VECTOR_SIZE -binary $BINARY -vocab-file $VOCAB_FILE -verbose $VERBOSE"$BUILDDIR/glove -save-file $SAVE_FILE -threads $NUM_THREADS -input-file $COOCCURRENCE_SHUF_FILE -x-max $X_MAX -iter $MAX_ITER -vector-size $VECTOR_SIZE -binary $BINARY -vocab-file $VOCAB_FILE -verbose $VERBOSEif [ "$CORPUS" = 'text8' ]; thenif [ "$1" = 'matlab' ]; thenmatlab -nodisplay -nodesktop -nojvm -nosplash &lt; ./eval/matlab/read_and_evaluate.m 1&gt;&amp;2 elif [ "$1" = 'octave' ]; thenoctave &lt; ./eval/octave/read_and_evaluate_octave.m 1&gt;&amp;2elseecho "$ python eval/python/evaluate.py"python eval/python/evaluate.pyfifi 这边多说一下，CORPUS=content.txt这边content.txt里面的格式需要按照空格为分隔符进行存储，我之前一直以为是\t。 直接sh demo.sh，你会得到vectors.txt，这个里面就对应每个词的向量表示 1234天气 -0.754142 0.386905 -1.200074 -0.587121 0.758316 0.373824 0.342211 -1.275982 -0.300846 0.374902 -0.548544 0.595310 0.906426 0.029255 0.549932 -0.650563 -0.425185 1.689703 -1.063556 -0.790254 -1.191287 0.841529 1.080641 -0.082830 1.062107 -0.667727 0.573955 -0.604460 -0.601102 0.615299 -0.470923 0.039398 1.110345 1.071094 0.195431 -0.155259 -0.781432 0.457884 1.093532 -0.188207 -0.161646 0.246220 -0.346529 0.525458 0.617904 -0.328059 1.374414 1.020984 -0.959817 0.670894 1.091743 0.941185 0.902730 0.609815 0.752452 1.037880 -1.522382 0.085098 0.152759 -0.562690 -0.405502 0.299390 -1.143145 -0.183861 0.383053 -0.013507 0.421024 0.025664 -0.290757 -1.258696 0.913482 -0.967165 -0.131502 -0.324543 -0.385994 0.711393 1.870067 1.349140 -0.541325 -1.060084 0.078870 0.773146 0.358453 0.610744 0.407547 -0.552853 1.663435 0.120006 0.534927 0.219279 0.682160 -0.631311 1.071941 -0.340337 -0.503272 0.150010 1.347857 -1.024009 -0.181186 0.610240 -0.218312 -1.120266 -0.486539 0.264507 0.266192 0.347005 0.172728 0.613503 -0.131925 -0.727304 -0.504488 1.773406 -0.700505 -0.159963 -0.888025 -1.358476 0.540589 -0.243272 -0.236959 0.391855 -0.133703 -0.071120 1.050547 -1.087613 -0.467604 1.779341 -0.449409 0.949411好了 1.413075 -0.226177 -2.024229 -0.192003 0.628270 -1.227394 -1.054946 -0.900683 -1.958882 -0.133343 -1.014088 -0.434961 0.026207 -0.066139 0.608682 -0.362021 0.314323 0.261955 -0.571414 1.738899 -1.013223 0.503853 -0.536511 -0.212048 0.611990 -0.627851 0.297657 -0.187690 -0.565871 -0.234922 -0.845875 -0.767733 0.032470 1.508012 -0.204894 -0.495031 -0.159262 0.181380 0.050582 -0.333469 0.454832 -2.091174 0.448453 0.940212 0.882077 -0.617093 0.616782 -0.993445 -0.385087 0.251711 0.259918 -0.222614 -0.595131 0.661472 0.194740 0.619222 -1.253610 -0.838179 0.781428 -0.396697 -0.530109 0.022801 -0.558296 -0.656034 0.842634 -0.105293 0.586823 -0.603681 -0.605727 -0.556468 0.924275 -0.299228 -1.121538 0.237787 0.498935 -0.045423 0.171536 -1.026385 -0.262225 0.390662 1.263240 0.352172 0.261121 0.915840 1.522183 -0.498536 2.046169 0.012683 -0.073264 -0.361662 0.759529 -0.713268 0.281747 -0.811104 -0.002061 -0.802508 0.520559 0.092275 -0.623098 0.199694 -0.134896 -1.390617 0.911266 -0.114067 1.274048 1.108440 -0.266002 1.066987 0.514556 0.144796 -0.606461 0.197114 0.340205 -0.400785 -0.957690 -0.327456 1.529557 -1.182615 0.431229 -0.084865 0.513266 -0.022768 -0.092925 -0.553804 -2.269741 -0.078390 1.376199 -1.163337随意 0.410436 0.776917 -0.381131 0.969900 -0.804778 -0.785379 -0.887346 -1.463543 -1.574851 0.313285 0.685253 -0.918359 0.199073 -0.305374 -0.642721 0.098114 -0.723331 0.353159 0.042807 0.369208 -1.534930 -0.084871 0.020417 -0.384782 0.276833 -0.160028 1.107051 0.884343 -0.204381 -0.459738 -0.387128 0.125867 0.093569 1.192471 -0.473752 -0.314541 -1.029249 0.481447 1.358753 -1.688778 -0.113080 -0.401443 -0.958206 0.605638 1.083126 0.131617 0.092507 0.476506 0.801755 1.096883 -0.102036 0.461804 0.820297 -0.104053 -0.126638 0.957708 -0.722038 0.223686 0.583582 0.201246 -1.254708 0.770717 -1.271523 -0.584094 -1.142426 1.066567 0.071951 -0.182649 0.014365 -0.577141 0.037340 -0.166832 -0.247827 0.165994 1.143665 -0.258421 -0.335195 0.170218 -0.212838 0.013709 0.088847 0.663238 -0.597439 0.632847 0.370871 0.652707 0.306935 0.195127 -0.252443 0.588479 0.191633 -1.587564 0.564600 -0.306158 -0.648177 -0.488595 1.532795 -0.462473 -0.643878 1.292369 -0.051494 -1.032738 0.453587 0.411327 -0.469373 0.428398 -0.020839 0.307422 0.518331 -0.860913 -2.170098 -0.277532 -0.966210 0.615336 -0.924783 0.042679 1.289640 1.272992 1.367773 0.426600 -0.187254 -0.781009 1.331301 -0.088357 -1.113550 -0.262879 0.300137 0.437905.. 有了每个词的向量，我们这边采取了借鉴YoutubeNet网络的想法： 举个例子：存在一句话”我爱中国”，“我”的向量是[0.3,0.2,0.3]，”爱”的向量是[0.1,0.2,0.3]，“中国”的向量是[0.6,0.6,0.4]，那么average后就是[0.33,0.33,0.33]，然后这就类似一个特征为三的input。 这种方法的好处就是快捷，预处理的工作代价要小，随着数据量的增多，模型的效果要更加的好。 效果对比最后这边粗略的给出一下业务数据对比： experiment date intercepted_recall 3-grams 20180915 79.3% 3-grams 20180917 78.7% 3-grams+bayes+lr 20180915 83.4% 3-grams+bayes+lr 20180917 88.6% gloVe+lr 20180915 93.1% gloVe+lr 20180917 93.9% 欢迎大家关注我的个人bolg，知乎，相关代码已经上传到我的Github，如果有任何算法、代码、转行疑问都欢迎通过公众号发消息给我。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Google团队在DNN的实际应用方式的整理]]></title>
    <url>%2F2018%2F08%2F29%2FGoogle%E5%9B%A2%E9%98%9F%E5%9C%A8DNN%E7%9A%84%E5%AE%9E%E9%99%85%E5%BA%94%E7%94%A8%E6%96%B9%E5%BC%8F%E7%9A%84%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[很荣幸有机会和论文作者Emre Sargin关于之前发的Deep Neural Networks for YouTube Recommendations进行交流，梳理如下： 提问对话汇总： 如何进行负采样的？ 构造了千万量级热门视频集合，每个用户的负采样结果来源于这个集合，会有一些筛选的tricks，比如剔除浏览过的商品，负采样的数量Google在200万条。（也就是说，在计算loss的时候，google的label是一个200万长度的向量，瑟瑟发抖.jpg。） 推荐算法应用上，有什么评估方式和评估指标？ 主要基于线上进行小批量的abtest进行对比，在考虑ctr指标的同时也会综合全站的信息加以分析，同时对新颖程度和用户兴趣变换也是我们考察的对象。 冷启动的解决方式？从来没有被点击过的video如何处理？新上的video如何处理？ google的推荐基于多种推荐算法的组合，YouTubeNet主要解决的是热门商品的一个推荐问题，冷启动或者没有被点击的video会有其他算法进行计算。换句话说，解决不了。 example age如何定义？ user+vedio的组合形式，train过程中，是用户点击该vedio的时间距离当前时间的间隔；predict过程中，为0。该部分对模型的鲁棒性非常重要。 是否遇到神经元死亡的问题？ 有，解决方案很常规，都是大家了解的，降低learning_rate，使用batchnormalization。 是否预到过拟合？ 没，youtube的用户上亿，可以构造出上千亿的数据，过拟合的情况不明显。但是会存在未登录用户，我们会通过一些其他CRM类的算法补充构造出他们的基本信息，比如gender、age… vedio vector在哪边进行构造和修正？ history click部分进行vedio embedding，并进行修正。另外，50是我们尝试的历史点击长度，20-30也有不错的效果。 会有工程计算压力么？ 不存在，建议在GPU上计算，后面由于VPN网络信号抖动没听清，大概就说Google在训练模型的时候会有大量GPU支持，每天大概更新2-3模型，没有遇到什么计算瓶颈。 (以上为我个人针对提问结果的理解及总结) 个人感想如下：有钱任性 最后，我觉得算法还是要适应实际情况，大公司的方法可以借鉴但是可能很多时候抄不来，也没条件抄。 原问题如下（实际有删改）：How to do video embedding?Is there any pre-training?How to use example age in the model?How to deal dead ReLU neurons？How to sample negative classes？How does the video embedding generated？How to recommend the video never been clicked and new uploaded videos？How to do ab testing? What’s the metrics?Have you facing overfitting？How to solve it?There is any difficulty in calculating the embedding for millions of videos and users.During input embedding generation, are they simply averaged? 欢迎大家关注我的个人bolg，知乎，更多代码内容欢迎follow我的个人Github，如果有任何算法、代码、转行疑问都欢迎通过公众号发消息给我。]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>论文解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Stanford Word Segmenter问题整理]]></title>
    <url>%2F2018%2F08%2F27%2FSegmenter%E9%97%AE%E9%A2%98%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[最近在做一些nlp相关的项目，在涉及到Stanford CoreNLP工具包处理中文分词的时候，发现耗时问题很严重： Item time(s) jieba 0.4 snownlp 7.4 pynlpir 0.8 StanfordCoreNLP 21.5 pyltp 5.3 因为Stanford CoreNLP调用的是这个pipeline，而我们实际用的是切词功能，所以尝试只用它的切词部分功能，但是在做的过程中发现一些问题，整理如下： 官网给出的方法nltk.tokenize.stanford_segmenter module是这么写的： 123from nltk.tokenize.stanford_segmenter import StanfordSegmenterseg = StanfordSegmenter()seg.default_config('zh') 但是这个缺少各种数据路径的，是完全不通的。 然后度娘的top1的答案给出的解决方案是：`1segmenter = StanfordSegmenter(path_to_jar="stanford-segmenter-3.4.1.jar", path_to_sihan_corpora_dict="./data", path_to_model="./data/pku.gz", path_to_dict="./data/dict-chris6.ser.gz") 如果你的nltk的版本比较新，恭喜你，你会遇到下面这个问题：TypeError: expected str, bytes or os.PathLike object, not NoneType 我在stackoverflow上找了半天，发现有如下的解决方案：1234from nltk.parse.corenlp import CoreNLPParser corenlp_parser = CoreNLPParser('http://localhost:9001', encoding='utf8')result = corenlp_parser.api_call(text, &#123;'annotators': 'tokenize,ssplit'&#125;)tokens = [token['originalText'] or token['word'] for sentence in result['sentences'] 可以完美解决，原因之前作者也说了，据称升级版本后不兼容，各位看看就好“TypeError: expected str, bytes or os.PathLike object, not NoneType” about Stanford NLP 。 这个坑花了我两个多小时（主要在下载各种gz包），希望大家能够避免。 欢迎大家关注我的个人bolg，知乎，更多代码内容欢迎follow我的个人Github，如果有任何算法、代码、转行疑问都欢迎通过公众号发消息给我。]]></content>
      <categories>
        <category>代码集合</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[logistic regression一点理解]]></title>
    <url>%2F2018%2F08%2F14%2Fregression%E4%B8%80%E7%82%B9%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Hexo没有办法用Latex，所以采取了截图的方式，更舒适的阅读体验可以参见logistic regression一点理解。 欢迎大家关注我的个人bolg，更多代码内容欢迎follow我的个人Github，如果有任何算法、代码疑问都欢迎通过公众号发消息给我。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>理论解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Tensorflow实现FFM]]></title>
    <url>%2F2018%2F08%2F06%2F%E5%9F%BA%E4%BA%8ETensorflow%E5%AE%9E%E7%8E%B0FFM%2F</url>
    <content type="text"><![CDATA[没错，这次登场的是FFM。各大比赛中的“种子”算法，中国台湾大学Yu-Chin Juan荣誉出品，美团技术团队背书，Michael Jahrer的论文的field概念灵魂升华，土豪公司鉴别神器。通过引入field的概念，FFM把相同性质的特征归于同一个field，相当于把FM中已经细分的feature再次拆分，可不可怕，厉不厉害？好，让我们来看看怎么一个厉害法。 FFM理论特征交互网上已经说烂了的美团技术团队给出的那张图：针对Country这个变量，FM的做法是one-hot-encoding，生成country_USA，country_China两个稀疏的变量，再进行embedding向量化。FFM的做法是cross-one-hot-encoding，生成country_USA_Day_26/11/15，country_USA_Ad_type_Movie…M个变量，再进行embedding向量化。就和上图一样，fm做出来的latent factor是二维的，就是给每个特征一个embedding结果；而暴力的ffm做出的latent factor是三维的，出来给特征embedding还考虑不同维度特征给不同的embedding结果，也是FFM中“field-aware”的由来。同时从公式中看，对于xi这个特征为什么embedding的latent factor向量的V是Vifj，其实就是因为xi乘以的是xj，所以latent factor向量的信息提取才是field j，也就是fj。多说一句，网上很多给出的现成的代码，这边都是写错了的，都写着写着变成了vifi，可能是写的顺手。 都说到这里了，我再多说一句，为什么说ffm是土豪公司鉴别神器呢？我们看下仅仅是二次项，ffm需要计算的参数有 nfk 个，远多于FM模型的 nk个，而且由于每次计算都依赖于乘以的xj的field，所以，无法用fm的那个计算技巧(ab = 1/2(a+b)^2-a^2-b^2)，所以计算复杂度是 O(kn^2)。这种情况下，没有GPU就不要想了，有GPU的特征多于50个，而且又很离散的，没有个三位数的GPU也算了。之前我看美团说他们在用，我想再去看看他们的实际用的过程的时候，发现文章被删了，真的是可惜，我其实一直也想知道如何减轻这个变态的计算量的方法。 给个实例给大家看下以上的这些的应用：依旧来自美团技术研发团队中给出的案例，有用户数据如下：这条记录可以编码成5个特征，其中“Genre=Comedy”和“Genre=Drama”属于同一个field，“Price”是数值型，不用One-Hot编码转换。为了方便说明FFM的样本格式，我们将所有的特征和对应的field映射成整数编号。红色部分对应的是field，来自于原始特征的个数；蓝色部分对应的是feature，来自于原始特征onehot之后的个数。对于特征Feature:User=YuChin而言，有Movie=3Idiots、Genre=Comedy、Genre=Drama、Price四项要交互：User=YuChin与Movie=3Idiots交互是·1·1，也就是第一项，为什么是V1,2呢？因为User=YuChin是Featureindex=1，而交互的Movie=3Idiots是Fieldindex=2，同理V2,1也是这样的，以此类推，那么，FFM的组合特征有10项，如下图所示：这就是一个案例的实际操作过程。 特征处理为什么要把这个单拎出来说呢？我看了网上不少的对于特征的处理过程，版本实在是太多了，而且差异化也蛮大，这边就和大家一起梳理一下：1.feature index * feature value这个就是上面我这个实际案例的方式，对于分类变量采取onehot，对于连续变量之间进行值的点积，不做处理。优点是快速简单，不需要预处理，但是缺点也很明显，离群点影响，值的波动大等。 2.连续值离散化这个方法借鉴了Cart里面对连续值的处理方式，就是把所有的连续值都当成一个分类变量处理。举例，现在有一个年龄age的连续变量[10,19,20,22,22,34]，这种方法就生成了age_10,age_19,age_20,age_22,age_34这些变量，如果连续值一多，这个方法带来的计算量就直线上升。 3.分箱下的连续值离散化这种方法优化了第二种方法，举例解释，现在有一个年龄age的连续变量[10,19,20,22,22,34]，我们先建立一个map，[0,10):0,[10,20):1,[20,30):2,[30,100):3。原始的数据就变成了[1,1,2,2,2,3]，再进行2的连续值离散化方法，生成了age_1,age_2,age_3这几个变量，优化了计算量，而且使得结果更具有解释性。 损失函数logisitc loss这个是官方指定的方法，是-1/1做二分类的时候常用的loss计算方法：这边需要注意的是，在做的时候，需要把label拆分成-1/1而不是0/1，当我们预测正确的时候，predlabel&gt;0且越大正确的程度越高，相应的log项是越小的，整体loss越小；相反，如果我们预测的越离谱，predlabel&lt;0且越小离谱的程度越高，相应的log项是越大的，整体loss越大。 交互熵我看到很多人的实现依旧用了tf.nn.softmax_cross_entropy_with_logits，其实就是多分类中的损失函数，和大家平时的图像分类、商品推荐召回一模一样：这边需要注意的是，在做的时候，需要把label拆分成[1,0]和[0,1]进行计算。不得不说，大家真的是为了省事很机智(丧心病狂)啊！ 代码实现我这边只给一些关键地方的代码，更多的去GitHub里面看吧。 embedding part1self.v = tf.get_variable('v', shape=[self.p, self.f, self.k], dtype='float32',initializer=tf.truncated_normal_initializer(mean=0, stddev=0.01)) 看到了，这边生成的v就是上面Vffm的形式。 inference part12345678910111213for i in range(self.p): # 寻找没有match过的特征，也就是论文中的j = i+1开始 for j in range(i + 1, self.p): print('i:%s,j:%s' % (i, j)) # vifj vifj = self.v[i, self.feature2field[j]] # vjfi vjfi = self.v[j, self.feature2field[I]] # vi · vj vivj = tf.reduce_sum(tf.multiply(vifj, vjfi)) # xi · xj xixj = tf.multiply(self.X[:, i], self.X[:, j]) self.field_cross_interaction += tf.multiply(vivj, xixj) 我这边强行拆开了写，这样看起来更清晰一点，注意这边的vifj和vjfi的生成，这边也可以看到找对于的field的方法是用了filed这个字典，这就是为什么不能用fm的点击技巧。 loss part12# -1/1情况下的logistic lossself.loss = tf.reduce_mean(tf.log(1 + tf.exp(-self.y * self.y_out))) 这边记得论文中的负号，如果有batch的情况下记得求个平均再进行bp过程。 论文结论原始的ffm论文中给出了一些结论，我们在实际使用中值得参考： k值不用太大，没啥提升 正则项lambda和学习率alpha需要着重调参 epoch别太大，既会拖慢速度，而且造成过拟合；在原论文中甚至要考虑用early-stopping避免过拟合，所以epoch=1，常规的来讲就可以了，论文中提到的early-stopping操作：12345671. Split the data set into a training set and a validation set.2. At the end of each epoch, use the validation set to calcu-late the loss.3. If the loss goes up, record the number of epochs. Stop orgo to step 4.4. If needed, use the full data set to re-train a model withthe number of epochs obtained in step 3. 总结FFM是一个细化隐向量非常好的方法，虽然很简单，但还是有很多细节之处值得考虑，比如如何线上应用，如何可解释，如何求稀疏解等等。在部署实现FFM之前，我还是建议大家先上线FM，当效果真的走投无路的时候再考虑FFM，FFM在工业界的影响着实不如学术界那么强大，偷偷说一句，太慢了，真的是太慢了，慢死了，我宁可去用deepfm。 最后，给出代码实现的Github地址FFM，这边是我自己写的，理解理解算法可以，但是实际用的时候建议参考FFM的实现比较好的项目比如libffm，最近比较火的xlearn。 欢迎大家关注我的个人bolg，更多代码内容欢迎follow我的个人Github，如果有任何算法、代码疑问都欢迎通过公众号发消息给我。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>特征交叉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Tensorflow实现DeepFM]]></title>
    <url>%2F2018%2F07%2F30%2F%E5%9F%BA%E4%BA%8ETensorflow%E5%AE%9E%E7%8E%B0DeepFM%2F</url>
    <content type="text"><![CDATA[前言DeepFM，Ctr预估中的大杀器，哈工大与华为诺亚方舟实验室荣耀出品，算法工程师面试高频考题，有效的结合了神经网络与因子分解机在特征学习中的优点：同时提取到低阶组合特征与高阶组合特征，这样的称号我可以写几十条出来，这也说明了DeepFM确实是一个非常值得手动撸一边的算法。 当然，早就有一票人写了一车封装好的deepFM的模型，大家随便搜搜肯定也能搜到，既然这样，我就不再搞这些东西了，今天主要和大家过一遍，deepFM的代码是咋写的，手把手入门一下，说一些我觉得比较重要的地方，方便大家按需修改。（只列举了一部分，更多的解释参见GitHub代码中的注释） 本文的数据和部分代码构造参考了nzc大神的deepfm的Pytorch版本的写法，改成tensorflow的形式，需要看原版的自取。 网络结构 DeepFM包含两部分：神经网络部分与因子分解机部分，分别负责低阶特征的提取和高阶特征的提取，两部分权重共享。DeepFM的预测结果可以写为：y = sigmoid(y(fm)+y(DNN)) FM部分 FM公式为： 我很久之前一篇文章细节讲过，这边就不多扯了，更多详见FM理论解析及应用。 DNN部分 这边其实和我上篇文章说的MLPS差距不大，也就是简单的全链接，差就差在input的构造，这边采取了embedding的思想，将每个feature转化成了embedded vector作为input，同时此处的input也是上面计算FM中的V，更多的大家看代码就完全了解了。 代码部分我一共写了两个script，build_data.py和deepfm.py，也很好理解。build_data.py用来预处理数据，deepfm.py用来跑模型。 build_data.py1234567891011121314151617181920212223242526for i in range(1, data.shape[1]): target = data.iloc[:, I] col = target.name l = len(set(target)) if l &gt; 10: target = (target - target.mean()) / target.std() co_feature = pd.concat([co_feature, target], axis=1) feat_dict[col] = cnt cnt += 1 co_col.append(col) else: us = target.unique() print(us) feat_dict[col] = dict(zip(us, range(cnt, len(us) + cnt))) ca_feature = pd.concat([ca_feature, target], axis=1) cnt += len(us) ca_col.append(col)feat_dim = cntfeature_value = pd.concat([co_feature, ca_feature], axis=1)feature_index = feature_value.copy()for i in feature_index.columns: if i in co_col: feature_index[i] = feat_dict[I] else: feature_index[i] = feature_index[i].map(feat_dict[I]) feature_value[i] = 1. 核心部分如上，重要的是做了两件事情，生成了feature_index和feature_value。 feature_index是把所有特征进行了标序，feature1，feature2……featurem，分别对应0，1，2，3，…m，但是，请注意分类变量需要拆分！就是说如果有性别：男|女|未知，三个选项。需要构造feature男，feature女，feature未知三个变量，而连续变量就不需要这样。 feature_value就是特征的值，连续变量按真实值填写，分类变量全部填写1。 更加形象的如下： deepfm.py特征向量化123456789# 特征向量化，类似原论文中的vself.weight['feature_weight'] = tf.Variable( tf.random_normal([self.feature_sizes, self.embedding_size], 0.0, 0.01), name='feature_weight')# 一次项中的w系数，类似原论文中的wself.weight['feature_first'] = tf.Variable( tf.random_normal([self.feature_sizes, 1], 0.0, 1.0), name='feature_first') 可以对照下面的公式看，更有感觉。 deep网络部分的weight123456789101112131415161718192021222324252627# deep网络初始input：把向量化后的特征进行拼接后带入模型，n个特征*embedding的长度input_size = self.field_size * self.embedding_sizeinit_method = np.sqrt(2.0 / (input_size + self.deep_layers[0]))self.weight['layer_0'] = tf.Variable( np.random.normal(loc=0, scale=init_method, size=(input_size, self.deep_layers[0])), dtype=np.float32)self.weight['bias_0'] = tf.Variable( np.random.normal(loc=0, scale=init_method, size=(1, self.deep_layers[0])), dtype=np.float32)# 生成deep network里面每层的weight 和 biasif num_layer != 1: for i in range(1, num_layer): init_method = np.sqrt(2.0 / (self.deep_layers[i - 1] + self.deep_layers[I])) self.weight['layer_' + str(i)] = tf.Variable( np.random.normal(loc=0, scale=init_method, size=(self.deep_layers[i - 1], self.deep_layers[i])), dtype=np.float32) self.weight['bias_' + str(i)] = tf.Variable( np.random.normal(loc=0, scale=init_method, size=(1, self.deep_layers[i])), dtype=np.float32)# deep部分output_size + 一次项output_size + 二次项output_sizelast_layer_size = self.deep_layers[-1] + self.field_size + self.embedding_sizeinit_method = np.sqrt(np.sqrt(2.0 / (last_layer_size + 1)))# 生成最后一层的结果self.weight['last_layer'] = tf.Variable( np.random.normal(loc=0, scale=init_method, size=(last_layer_size, 1)), dtype=np.float32)self.weight['last_bias'] = tf.Variable(tf.constant(0.01), dtype=np.float32) input的地方需要注意一下，这边用了个技巧，直接把把向量化后的特征进行拉伸拼接后带入模型，原来的v是batch*n个特征*embedding的长度，直接改成了batch*（n个特征*embedding的长度），这样的好处就是全值共享，又快又有效。 网络传递部分都是一些正常的操作，稍微要注意一下的是交互项的计算：12345678910111213141516# second_orderself.sum_second_order = tf.reduce_sum(self.embedding_part, 1)self.sum_second_order_square = tf.square(self.sum_second_order)print('sum_square_second_order:', self.sum_second_order_square)# sum_square_second_order: Tensor("Square:0", shape=(?, 256), dtype=float32)self.square_second_order = tf.square(self.embedding_part)self.square_second_order_sum = tf.reduce_sum(self.square_second_order, 1)print('square_sum_second_order:', self.square_second_order_sum)# square_sum_second_order: Tensor("Sum_2:0", shape=(?, 256), dtype=float32)# 1/2*((a+b)^2 - a^2 - b^2)=abself.second_order = 0.5 * tf.subtract(self.sum_second_order_square, self.square_second_order_sum)self.fm_part = tf.concat([self.first_order, self.second_order], axis=1)print('fm_part:', self.fm_part) 直接实现了下面的计算逻辑： loss部分我个人重写了一下我认为需要正则的地方，和一些loss的计算方式：123456789101112# lossself.out = tf.nn.sigmoid(self.out)# loss = tf.losses.log_loss(label,out) 也行，看大家想不想自己了解一下loss的计算过程self.loss = -tf.reduce_mean( self.label * tf.log(self.out + 1e-24) + (1 - self.label) * tf.log(1 - self.out + 1e-24))# 正则：sum(w^2)/2*l2_reg_rate# 这边只加了weight，有需要的可以加上bias部分self.loss += tf.contrib.layers.l2_regularizer(self.l2_reg_rate)(self.weight["last_layer"])for i in range(len(self.deep_layers)): self.loss += tf.contrib.layers.l2_regularizer(self.l2_reg_rate)(self.weight["layer_%d" % I]) 大家也可以直接按照我注释掉的部分简单操作，看个人的理解了。 梯度正则12345678self.global_step = tf.Variable(0, trainable=False)opt = tf.train.GradientDescentOptimizer(self.learning_rate)trainable_params = tf.trainable_variables()print(trainable_params)gradients = tf.gradients(self.loss, trainable_params)clip_gradients, _ = tf.clip_by_global_norm(gradients, 5)self.train_op = opt.apply_gradients( zip(clip_gradients, trainable_params), global_step=self.global_step) 很多网上的代码跑着跑着就NAN了，建议加一下梯度的正则，反正也没多复杂。 执行结果1234567891011121314151617181920212223242526272829/Users/slade/anaconda3/bin/python /Users/slade/Documents/Personalcode/machine-learning/Python/deepfm/deepfm.py[2 1 0 3 4 6 5 7][0 1 2][6 0 8 2 4 1 7 3 5 9][2 3 1 0]W tensorflow/core/platform/cpu_feature_guard.cc:45] The TensorFlow library wasn't compiled to use SSE4.1 instructions, but these are available on your machine and could speed up CPU computations.W tensorflow/core/platform/cpu_feature_guard.cc:45] The TensorFlow library wasn't compiled to use SSE4.2 instructions, but these are available on your machine and could speed up CPU computations.W tensorflow/core/platform/cpu_feature_guard.cc:45] The TensorFlow library wasn't compiled to use AVX instructions, but these are available on your machine and could speed up CPU computations.W tensorflow/core/platform/cpu_feature_guard.cc:45] The TensorFlow library wasn't compiled to use AVX2 instructions, but these are available on your machine and could speed up CPU computations.W tensorflow/core/platform/cpu_feature_guard.cc:45] The TensorFlow library wasn't compiled to use FMA instructions, but these are available on your machine and could speed up CPU computations.embedding_part: Tensor("Mul:0", shape=(?, 39, 256), dtype=float32)first_order: Tensor("Sum:0", shape=(?, 39), dtype=float32)sum_square_second_order: Tensor("Square:0", shape=(?, 256), dtype=float32)square_sum_second_order: Tensor("Sum_2:0", shape=(?, 256), dtype=float32)fm_part: Tensor("concat:0", shape=(?, 295), dtype=float32)deep_embedding: Tensor("Reshape_2:0", shape=(?, 9984), dtype=float32)output: Tensor("Add_3:0", shape=(?, 1), dtype=float32)[&lt;tensorflow.python.ops.variables.Variable object at 0x10e2a9ba8&gt;, &lt;tensorflow.python.ops.variables.Variable object at 0x112885ef0&gt;, &lt;tensorflow.python.ops.variables.Variable object at 0x1129b3c18&gt;, &lt;tensorflow.python.ops.variables.Variable object at 0x1129b3da0&gt;, &lt;tensorflow.python.ops.variables.Variable object at 0x1129b3f28&gt;, &lt;tensorflow.python.ops.variables.Variable object at 0x1129b3c50&gt;, &lt;tensorflow.python.ops.variables.Variable object at 0x112a03dd8&gt;, &lt;tensorflow.python.ops.variables.Variable object at 0x112a03b38&gt;, &lt;tensorflow.python.ops.variables.Variable object at 0x16eae5c88&gt;, &lt;tensorflow.python.ops.variables.Variable object at 0x112b937b8&gt;]time all:7156epoch 0:the times of training is 0, and the loss is 8.54514the times of training is 100, and the loss is 1.60875the times of training is 200, and the loss is 0.681524the times of training is 300, and the loss is 0.617403the times of training is 400, and the loss is 0.431383the times of training is 500, and the loss is 0.531491the times of training is 600, and the loss is 0.558392the times of training is 800, and the loss is 0.51909... 看了下没啥大问题。 还有一些要说的 build_data.py中我为了省事，只做了标准化，没有进行其他数据预处理的步骤，这个是错误的，大家在实际使用中请按照我在公众号里面给大家进行的数据预处理步骤进行，这个非常重要！ learing_rate是我随便设置的，在实际大家跑模型的时候，请务必按照1.0，1e-3，1e-6，三个节点进行二分调优。 如果你直接搬上面代码，妥妥过拟合，请在真实使用过程中，务必根据数据量调整batch的大小，epoch的大小，建议在每次传递完成后加上tf.nn.dropout进行dropout。 如果数据量连10万量级都不到，我还是建议用机器学习的方法，xgboost+lr，mixed logistics regression等等都是不错的方法。 好了，最后附上全量代码的地址Github，希望对大家有所帮助。 欢迎大家关注我的个人bolg，更多代码内容欢迎follow我的个人Github，如果有任何算法、代码疑问都欢迎通过公众号发消息给我哦。]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>特征交叉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Tensorflow实现多层感知机网络MLPs]]></title>
    <url>%2F2018%2F07%2F25%2F%E5%9F%BA%E4%BA%8ETensorflow%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%B1%82%E6%84%9F%E7%9F%A5%E6%9C%BA%E7%BD%91%E7%BB%9CMLPs%2F</url>
    <content type="text"><![CDATA[之前在基于Tensorflow的神经网络解决用户流失概率问题写了一个MLPs的网络，很多人在问，其实这个网络看起来很清晰，但是却写的比较冗长，这边优化了一个版本更方便大家修改后直接使用。 直接和大家过一遍核心部分： 上次我们计算过程中，通过的是先定义好多层网络中每层的weight，在通过tf.matual进行层与层之间的计算，最后再通过tf.contrib.layers.l2_regularizer进行正则；而这次我们直接通过图像识别中经常使用的全连接（FC）的接口，只需要确定每层的节点数，通过layers_nodes进行声明，自动可以计算出不同层下的weight，更加清晰明了。另外，还增加了dropout的部分，降低过拟合的问题。 123456din_all = tf.layers.batch_normalization(inputs=din_all, name='b1')layer_1 = tf.layers.dense(din_all, self.layers_nodes[0], activation=tf.nn.sigmoid,use_bias=True,kernel_regularizer=tf.contrib.layers.l2_regularizer(self.regularzation_rate),name='f1')layer_1 = tf.nn.dropout(layer_1, keep_prob=self.drop_rate[0])layer_2 = tf.layers.dense(layer_1, self.layers_nodes[1], activation=tf.nn.sigmoid,use_bias=True,kernel_regularizer=tf.contrib.layers.l2_regularizer(self.regularzation_rate),name='f2')layer_2 = tf.nn.dropout(layer_2, keep_prob=self.drop_rate[1])layer_3 = tf.layers.dense(layer_2, self.layers_nodes[2], activation=tf.nn.sigmoid,use_bias=True,kernel_regularizer=tf.contrib.layers.l2_regularizer(self.regularzation_rate),name='f3') tf.layers.dense接口信息如下：12345678910111213141516tf.layers.dense(inputs,units,activation=None,use_bias=True,kernel_initializer=None,bias_initializer=tf.zeros_initializer(),kernel_regularizer=None,bias_regularizer=None,activity_regularizer=None,kernel_constraint=None,bias_constraint=None,trainable=True,name=None,reuse=None) inputs：必需，即需要进行操作的输入数据。 units：必须，即神经元的数量。 activation：可选，默认为 None，如果为 None 则是线性激活。 use_bias：可选，默认为 True，是否使用偏置。 kernel_initializer：可选，默认为 None，即权重的初始化方法，如果为 None，则使用默认的 Xavier 初始化方法。 bias_initializer：可选，默认为零值初始化，即偏置的初始化方法。 kernel_regularizer：可选，默认为 None，施加在权重上的正则项。 bias_regularizer：可选，默认为 None，施加在偏置上的正则项。 activity_regularizer：可选，默认为 None，施加在输出上的正则项。 kernel_constraint，可选，默认为 None，施加在权重上的约束项。 bias_constraint，可选，默认为 None，施加在偏置上的约束项。 trainable：可选，默认为 True，布尔类型，如果为 True，则将变量添加到 GraphKeys.TRAINABLE_VARIABLES 中。 name：可选，默认为 None，卷积层的名称。 reuse：可选，默认为 None，布尔类型，如果为 True，那么如果 name 相同时，会重复利用。 除此之外，之前我们定义y和y_的时候把1转化为[1,0]，转化为了[0,1]，增加了工程量，这次我们通过： 12cross_entropy_mean = -tf.reduce_mean(self.y_ * tf.log(self.output + 1e-24))self.loss = cross_entropy_mean 直接进行计算，避免了一些无用功。 最后，之前对于梯度的值没有进行限制，会导致整体模型的波动过大，这次优化中也做了修改，如果大家需要也可以参考一下：123456# 我们用learning_rate_base作为速率η，来训练梯度下降的loss函数解，对梯度进行限制后计算lossopt = tf.train.GradientDescentOptimizer(self.learning_rate_base)trainable_params = tf.trainable_variables()gradients = tf.gradients(self.loss, trainable_params)clip_gradients, _ = tf.clip_by_global_norm(gradients, 5)self.train_op = opt.apply_gradients(zip(clip_gradients, trainable_params), global_step=self.global_step) MLPs是入门级别的神经网络算法，实际的工业开发中使用的频率也不高，后面我准备和大家过一下常见的FM、FFM、DeepFM、NFM、DIN、MLR等在工业开发中更为常见的网络，欢迎大家持续关注。 完整代码已经上传到Github中。 欢迎大家关注我的个人bolg，更多代码内容欢迎follow我的个人Github，如果有任何算法、代码疑问都欢迎通过公众号发消息给我哦。]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>神经网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[伪标签半监督学习]]></title>
    <url>%2F2018%2F07%2F24%2F%E4%BC%AA%E6%A0%87%E7%AD%BE%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[之前在训练YoutubeNet和DCN的时候，我都发现平台用户中基础用户的信息数据缺失率特别高，比如性别一栏准确填写的不足60%，所以我一直想调研一下有没有什么更好的填充方法，要保证既不能太复杂太耗时，也要有足够好的效果。 其实这个问题就是一个缺失值填充，之前的文章中也写过很多办法，常规的也总结过： 均值、众数填充最简单的填充，效果也惨不忍睹 根据没有缺失的数据线性回归填充填充的好会造成共线性错误，填充的不好就没价值，很矛盾 剔除丢失信息量 设置哑变量会造成数据分布有偏 smote连续值有效，离散值就无法实施了 我在Google上看imbalance问题的时候，偶然看到了这个视频教程，上面讲了图像的缺失处理，提到了伪标签处理的半监督学习方式。我就在国内的论坛上找了下，阿里云技术论坛也同样注意到了这个问题，但是只给出了如下的粗糙的构思图： 有一份整理了的流程图，具体执行步骤总结，和大家一起看一下： 将有标签部分数据分为两份：train_set&amp;validation_set，并训练出最优的model1 用model1对未知标签数据(test_set)进行预测，给出伪标签结果pseudo-labeled 将train_set中抽取一部分做新的validation_set，把剩余部分与pseudo-labeled部分融合作为新的train_set，训练出最优的model2 再用model2对未知标签数据(test_set)进行预测，得到最终的final result label 我利用了已知标签的数据对这个方法进行测试，用了最简单的mixed logistic regression模型作为Basic Model，得到结果如下：利用伪标签半监督的方式，同样的mixed logistic regression模型AUC值会提高0.1pp左右，效果还不错，而且实施并不复杂，大家可以在缺失值处理或者分类问题中应用尝试一下。 欢迎大家关注我的个人bolg，更多代码内容欢迎follow我的个人Github，如果有任何算法、代码疑问都欢迎通过公众号发消息给我。]]></content>
      <categories>
        <category>特征刻画</category>
      </categories>
      <tags>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[热传导-物质扩散算法应用于推荐]]></title>
    <url>%2F2018%2F07%2F19%2F%E7%83%AD%E4%BC%A0%E5%AF%BC-%E7%89%A9%E8%B4%A8%E6%89%A9%E6%95%A3%E7%AE%97%E6%B3%95%E5%BA%94%E7%94%A8%E4%BA%8E%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[没有大量的数据，没有大量的人力就不能做好推荐么？当然不是，热传导/物质扩散推荐算法就是作为冷启动及小规模团队非常实用的推荐召回部分的算法。 目标是为a图中标有星号（不妨记为用户1）的用户推荐商品，该用户已经购买过的两件商品是我们可以利用的信息，用来给目标用户进行推荐。 物质扩散算法：初始，我们认为每件被目标用户购买过的商品的信息量为1。商品把自己的信息平均分给所有购买过它的用户，用户的信息值则是从所有商品所得到的信息值得总和，比如上图(b)中的第一个节点的信息就等于第一个商品平均分给三个用户的的平均信息1/3，再加上第四个商品平均分给两个用户的平均信息1/2，即为1/3+1/2=5/6；接下来，每一个用户再把自己的信息平均分给所有购买过的商品，商品的信息则是从所有用户收到的信息值得总和，如对于图(c)中的第一个商品，它的信息值就等于第一个用户信息值的一半，为5/12，加上第二个用户信息值的1/4，为5/24，再加上第三个用户信息值得一半，为1/6，总的能量值即为:5/12+5/24+1/6=19/24。 以上两个步骤加起来为从商品到商品信息扩散一步。针对大规模系统的推荐，为了保持实时性和效率，往往只需扩散三步以内。如果以一步为界，基于图(c)中的结果，则在目标用户没有购买过的所有商品中，第三个商品的信息值最大，因此基于物质扩散算法的推荐系统则会将此商品推荐给目标用户，同时可以得到对于用户1的商品得分排序，自然可以得到用户召回集。值得注意的是物质扩散这种算法得到的所有商品最后的信息值之和就等于初始时所有商品的信息值，即能量是守恒的，图(c)中所有商品的信息之和仍为2。 热传导算法： 初始，我们认为目标用户购买过的每件商品的信息量为1。目标用户的信息等于所有他购买过的商品信息的平均值，如图(d)所示，目标用户购买了商品1和商品4，则该用户的信息值即为(1 + 1) / 2 = 1。再根据目标用户浏览过的商品给所以商品计算信息，第一个商品、第四个商品信息量为1/2，其他商品的信息量为0（因为目标用户没有买过），接下来根据每一个商品的信息计算其他的用户的信息，如图(d)中的第二个用户的信息就为商品1,2,3,4的信息的平均值（1/2 + 1/2）/4 = 1/2；再根据每个用户的信息量平均分配信息到每个商品，如图(e)中的第一个商品来自第一个、第二个、第三个用户的信息的和，即为1/21/2+1/21/3+1/2*/12=2/3。 以上两个步骤加起来为从商品到商品热传导一步。因此基于热传导算法的推荐系统则会将此信息量大的商品推荐给目标用户，同时可以得到对于用户1的商品得分排序，自然可以得到用户召回集。与物质扩散不同的是这种算法得到的所有商品最后的信息值之和就不一定等于初始时所有商品的信息值，即不满足守恒定律，这是因为在信息传到的第二步过程中，有的用户的信息可能会被多次计算，从而导致不守恒。 基于物质扩散和基于热传导的推荐算法的区别在于： 基于物质扩散的方法在进行个性化推荐时，系统的总信息是守恒的；而热传导在推荐过程中，目标用户（即被推荐用户）的收藏品将被视作信息初始点，负责提供能量，所以系统的总信息量随着传递步骤的增加是在不断增加的。 如果对物理比较熟悉的朋友很容易联想到凸透镜和凹透镜，是的，我个人在理解的时候也是这样迁移理解，原理上确实一致。 基于物质扩散的方法相当于凸透镜一样把用户历史点击的信息聚焦到了少量优势的skn上了； 基于热传导的方法相当于是凹透镜一样把用户的历史点击信息发散到了那些较不流行的物品上，从而提高了推荐的新颖多样性。 欢迎大家关注我的个人bolg，更多代码内容欢迎follow我的个人Github，如果有任何算法、代码疑问都欢迎通过公众号发消息给我哦。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[量化评估推荐系统效果]]></title>
    <url>%2F2018%2F07%2F19%2F%E9%87%8F%E5%8C%96%E8%AF%84%E4%BC%B0%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E6%95%88%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[推荐系统最有效的方法就是A/B test进行模型之间的对比，但是由于现实原因的局限，存在现实实时的困难性，所以，梳理了一些可以补充替代的指标如下，但是离线评估也存在相应的问题：1) 数据集的稀疏性限制了适用范围，用户之间的交集稀疏。2) 评价结果的客观性，由于用户的主观性，不管离线评测的结果如何，都不能得出用户是否喜欢某推荐系统的结论，只是一个近似的评估。3) 深度评估指标的缺失。(如点击深度、购买客单价、购买商品类别、购买偏好)之间的关联关系。4）冷启动5）Exploration 和 Exploitation问题 离线模型之间的评估召回集测试 recall命中skn个数/用户真实点击skn个数 precision命中skn个数/所有预测出来的skn总数 F1-Measure2/(1/recall+1/precison) 交互熵 MAE RMSE 相关性常见的比如：Pearson、Spearman和Kendall’s Tau相关，其中Pearson是更具数值之间的相似度，Spearman是根据数值排序之间的相似度，Kendall’s Tau是加权下的数值排序之间的相似度。 基尼系数 信息熵 排序部分测试 NDCG（Normalize DCG） RBP（rank-biased precision） RBP和NDCG指标的唯一不同点在于RBP把推荐列表中商品的浏览概率p按等比数列递减，而ND CG则是按照log调和级数形式。 离线模型与在线模型之间的评估很多时候，我们需要确定离线模型的效果足够的健壮才能允许上线进行线上测试，那如何进行离线模型与线上模型的评估对比就是一个比较复杂的问题。 难点 缺乏公平的测试数据实际处理过程中，我们发现，所有的已知点击都是来自线上模型推荐的结果，所以极端情况下，线上的recall是100% 缺乏公认的衡量指标在线下对比中，我们发现比如recall、precision、F1-Measure等指标都是大家约定俗成的，不存在很大的争议，而离线在线模型对比却没有一个准确公认的衡量指标 指标设计 online_offline_cover_rate&amp;first_click_hit_rate 这一组指标是结合在一起看的，其中online_offline_cover_rate是指针对每一个用户计算理线模型推荐的商品与在线模型推荐的商品的重合个数/在线模型的推荐商品个数，online_offline_cover_rate越低代表离线模型相对在线模型越独立；first_click_hit_rate是指offline模型对用户每天第一次点击的命中率，也就是命中次数/总统计用户数。结合这两个指标，我们可以得到在online_offline_cover_rate越低的情况下，却能覆盖线上用户真实点击的次数越多，代表offline模型的效果优于线上模型。 online_precision_rate/offline_precision_rate 离线模型的准确率和在线模型的准确率。这边在实际计算的时候采取了一个技巧，针对某个推荐位计算在线模型准确率的时候，用的是从来没有浏览过这个推荐位的用户的浏览历史匹配这个用户这个推荐位的推荐结果。这样可以避免用户的点击结果受到推荐位推荐结果影响的问题。 举个例子：用户在推荐位A上没有浏览过，他的点击是不受推荐位A推荐的商品影响的，拿这个用户推荐位A我们给他线上推荐的结果作为线上模型的推荐结果去计算，这样才更加合理。 online_recall_rate/offline_recall_rate 离线模型的召回率和在线模型的召回率。同上解释。 roi_reall/roi_precision 同上解释，只是把未来的点击作为match源更换成了加购物车、购买、收藏这些数据。 其他评估方向覆盖率推荐覆盖率越高， 系统给用户推荐的商品种类就越多 ，推荐多样新颖的可能性就越大。如果一个推荐算法总是推荐给用户流行的商品，那么它的覆盖率往往很低，通常也是多样性和新颖性都很低的推荐。 多样性采用推荐列表间的相似度（hamming distance、Cosine Method），也就是用户的推荐列表间的重叠度来定义整体多样性。 新颖性计算推荐列表中物品的平均流行度。 其他用户满意度、用户问卷、信任度、鲁棒性、实时性、 评测维度最后说一下评测维度分为如下3种，多角度评测： 用户维度主要包括用户的人口统计学信息、活跃度以及是不是新用户等。 物品维度包括物品的属性信息、流行度、平均分以及是不是新加入的物品等。 时间维度包括季节，是工作日还是周末，是白天还是晚上等。 附常规评价指标的整理结果(来自论文Evaluation Metrics for Recommender Systems)： 欢迎大家关注我的个人bolg，更多代码内容欢迎follow我的个人Github，如果有任何算法、代码疑问都欢迎通过公众号发消息给我哦。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>推荐评估方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tensorflow在GPU下的Poolallocator Message]]></title>
    <url>%2F2018%2F06%2F28%2FTensorflow%E5%9C%A8GPU%E4%B8%8B%E7%9A%84Poolallocator%20Message%2F</url>
    <content type="text"><![CDATA[我在在用GPU跑我一个深度模型的时候，发生了以下的问题：1234567891011121314151617...2018-06-27 18:09:11.701458: I tensorflow/core/common_runtime/gpu/pool_allocator.cc:247] PoolAllocator: After 63521 get requests, put_count=63521 evicted_count=1000 eviction_rate=0.0157428 and unsatisfied allocation rate=0.01731712018-06-27 18:09:11.701503: I tensorflow/core/common_runtime/gpu/pool_allocator.cc:259] Raising pool_size_limit_ from 100 to 110Global_step 2000 Train_loss: 0.0758Global_step 3000 Train_loss: 0.0618Global_step 4000 Train_loss: 0.0564Global_step 5000 Train_loss: 0.0521Global_step 6000 Train_loss: 0.0492Global_step 7000 Train_loss: 0.0468Global_step 8000 Train_loss: 0.0443Global_step 9000 Train_loss: 0.0422Global_step 10000 Train_loss: 0.0410Global_step 11000 Train_loss: 0.0397Global_step 12000 Train_loss: 0.03832018-06-27 18:13:59.743133: I tensorflow/core/common_runtime/gpu/pool_allocator.cc:247] PoolAllocator: After 71532 get requests, put_count=71532 evicted_count=1000 eviction_rate=0.0139798 and unsatisfied allocation rate=0.01430132018-06-27 18:13:59.743167: I tensorflow/core/common_runtime/gpu/pool_allocator.cc:259] Raising pool_size_limit_ from 256 to 281... 除了常规的loss数据之外，我看到穿插在之间的warming informations ，虽然最后的结果没有任何问题，但是我抱着好奇的心态在stackoverflow找到了原因： TensorFlow has multiple memory allocators, for memory that will be used in different ways. Their behavior has some adaptive aspects.In your particular case, since you’re using a GPU, there is a PoolAllocator for CPU memory that is pre-registered with the GPU for fast DMA. A tensor that is expected to be transferred from CPU to GPU, e.g., will be allocated from this pool.The PoolAllocators attempt to amortize the cost of calling a more expensive underlying allocator by keeping around a pool of allocated then freed chunks that are eligible for immediate reuse. Their default behavior is to grow slowly until the eviction rate drops below some constant. (The eviction rate is the proportion of free calls where we return an unused chunk from the pool to the underlying pool in order not to exceed the size limit.) In the log messages above, you see “Raising pool_size_limit_” lines that show the pool size growing. Assuming that your program actually has a steady state behavior with a maximum size collection of chunks it needs, the pool will grow to accommodate it, and then grow no more. It behaves this way rather than simply retaining all chunks ever allocated so that sizes needed only rarely, or only during program startup, are less likely to be retained in the pool.These messages should only be a cause for concern if you run out of memory. In such a case the log messages may help diagnose the problem. Note also that peak execution speed may only be attained after the memory pools have grown to the proper size. 加粗部分解释机制、处理方式和原因。总结起来就是，PoolAllocator会有一个内存分配机制，GPU和CPU之间不是独立的可以相互传输，如果你使用的空间太多，他就会提高原有的预设的空间大小，如果够用了，就没有什么影响了，但是，需要注意的是，兄弟你的数据加载量太大了，看看是不是改改batch size，一次性少加载点数据，或者干掉隔壁同事的任务。]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>tensorflow代码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于'Deep Neural Networks for YouTube Recommendations'的一些思考和实现]]></title>
    <url>%2F2018%2F06%2F26%2F%E5%85%B3%E4%BA%8EDeep-Neural-Networks-for-YouTube-Recommendations%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%92%8C%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[论文 Deep Neural Networks for YouTube Recommendations 来自google的YouTube团队，发表在16年9月的RecSys会议。我想应该很多人都读过，之前参与了公司的推荐系统优化的项目，本来想从各大搜索引擎中寻找到现成的分析，但是出人意料的一无所获。Github上的代码实现也出奇的少以及不清晰，所以就借着这个机会和大家分享一下自己做的过程中的一些理论心得、工程坑、代码实现等等。 本文基于大家对Deep Neural Networks for YouTube Recommendations已经完成通读的基础上，不会做细致的论文解析，只会涉及到自己实现过程中的一些总结，如果没有论文了解，会非常不易理解。 系统概览上面这张图可以说是比较详细的涵盖了基础框架部分，整体的模型的优点我就不详述了，包括规模容纳的程度大啊、鲁棒性好啊、实时性优秀啊、延展性好啊等等，网上很多水字数的文章很多，我们主要总结几个愿论文上的亮点和实际去做的时候需要注意的地方： DNN网络可以怎么改 负采样的“避坑” example age有没有必要构造 user feature的选择方向 attention 机制的引入 video vectors的深坑 实时化的选择 整体上来说，G厂的这套算法基于的是两个部分：matching+ranking，这个的也给我们带来了更大的工作量，在做的时候，分成两个部分，我们在实际处理的时候，通过recall rate来判断matching部分的好坏，通过NDCG来判断排序部分的好坏。总体如下： candidate generation就是我们matching的模块，目的是把百万级的商品、视频筛选出百级、千级的可排序的量级；再通过ranking模块，选出十位数的展示商品、视频作为最后的推送内容。之所以把推荐系统划分成Matching和Ranking两个阶段，主要是从性能方面考虑的。Matching阶段面临的是百万级，而Ranking阶段的算法则非常消耗资源，不可能对所有目标都算一遍，而且就算算了，其中大部分在Ranking阶段排名也很低，也是浪费计算资源。 Matching &amp; Ranking Problems首先，我们都知道，G厂给出的这个解决方案用的就是基于DNN的超大规模多分类思想，即在时刻t，为用户U（上下文信息C）在视频库V中精准的预测出视频i的类别（每个具体的视频视为一个类别，i即为一个类别），用数学公式表达如下： 很显然上式为一个softmax多分类器的形式。向量u是信息的高纬“embedding”，而向量v则是视频 j 的embedding向量，通过u与v的点积大小来判断用户与对应视频的匹配程度。所以DNN的目标就是在用户信息和上下文信息为输入条件下学习视频的embedding向量v，从而得到用户的向量u。 说完基本思想，让我们看看实际的效果对比： DNN网络可以怎么改：softmax及revise的考虑 如我图中两处红色标记，论文中虽然给出了模型的整体流程，但是却没有指明，1处的video vectors需要单独的embedding还是沿用最下方的embedded video watches里面的已经embedding好的结果，我们称之为softmax问题；2处论文没有提及一个问题，就是在固定好历史watch的长度，比如过去20次浏览的video，可能存在部分用户所有的历史浏览video数量都不足20次，在average的时候，是应该除以固定长度（比如上述例子中的20）还是选择除以用户真实的浏览video数量，我们称之为revise问题。 根据我们的数据实测，效果对比如下： nosoft:沿用最下方的embedded video watches里面的已经embedding好的结果revise:除以用户真实的浏览video数量 我们尝试的去探求原因发现，nosoft比softmax好的原因在于user vector是由最下方的embedded video watches里面的已经embedding好的结果进行多次FC传递得来的，如果新增一个video embedded vector 的话，和FC传递得到的u vector的点积的意义就难以解释；revise比norevise好的原因是，实际在yoho!buy的购物场景下，用户的点击历史比较我们实际选取的window size要短不少，如果所有的用户都除以固定长度的话，大量的用户history click average的vector大小接近于0。 DNN网络可以怎么改：神经元死亡及网络的内部构造这是一个异常恶心还有没什么好方法的问题，在刚开始做的时候，我们遇到了一个常见的问题，神经元批量死亡的问题。在增加了batch normalization、clip_by_global_norm和exponential_decay learning rate 后有所缓解。 网络结构的变化比较常规，对比场景的激活函数，参考了论文中推荐的深度、节点数，效果对比如下： 虽然我们看到增加网络的深度（3—&gt;4）一定程度上会提高模型的命中率，增加leakyrelu的一层网络也可以有些许的提升，但是总的来说，对模型没有啥大的影响，所以在之后的实际模型中，我们选择了原论文中relu+relu+relu，1024+512+256的框架。 负采样的“避坑”我们都知道，算法写起来小半天就可以搞定，但是前期的数据处理要搞个小半个月都不一定能出来。作为爱省事的我，为了快速实现算法，没有重视负采样的部分，采取了列表页点击为label=1，未点击为label=0的方式，详情如下： 看上去没什么问题，省略了从全量样本中抽样作为负样本的复杂过程，实际上，我把代码狂改了n边效果也一直维持在1.57%，可以说是没有任何提升，在此过程期间，我还是了拿用户的尾次点击（last_record）进行训练，拿了有较多行为的用户的尾次点击（change_last_record）进行训练，效果很感人： 在我孤注一掷一致，选择按照原论文中说的，每次label=0的我不拿展现给用户但是用户没有点击的商品，而是随机从全量商品中抽取用户没有点击过的商品作为label=0的商品后，奇迹发生了： 事后我仔细分析了原因：a.在当次展现的情况下，虽然用户只点击了click商品，其他商品没有点击，但是很多用户在后续浏览的时候未click的商品也在其他非列表页的地方进行click，我实际上将用户感兴趣的商品误标记为了负样本b.后来我咨询看了论文，也发现了原论文中也提及到，展现商品极有可能为热门商品，虽然该商品该用户未点击，但是我们不能降低热门商品的权重（通过label=0的方式），实际上最后的数据也证明了这一点c.“偷窥未来的行为”，如下图，原论文中指出input构造时候不能拿还未发生的点击，只能拿label=1产生时之前的所有历史点击作为input；同理，在构造label=0的时候，只能拿在label=0的时候已经上架的商品，由于训练时间的拉长，不能偷窥label=1发生时还未上架的商品作为label=0的负样本 example age有没有必要构造首先，先稍微解释一下我对example age的概念的理解。所有的训练数据其实都是历史数据，距离当前的时刻都过去了一段时间，站在当前来看，距离当前原因的数据，对当前的影响应该是越小的。就比如1年前我买了白色的铅笔，对我现在需要不需要再买一支黑色的钢笔的影响是微乎其微的。而example age其实就是给了每一条数据一个权重，引用一下原论文的描述In (5b), the example age is expressed as tmax − tN where tmax is the maximum observed time in the training data，我这边采取了(tmax − tN)/tmax的赋权方式： 很悲催的是，直观的离线训练数据并没有给出很直观的效果提升，但是由于评估机制的问题（我们后面会说到），我会在实际上线 做abtest的时候重新验证我的这个example age的点，但是可以肯定的是，理论和逻辑上，给样本数据进行权重的更改，是一个可以深挖的点，对线上的鲁棒性的增强是正向的。 user feature的选择方向很不幸的是，在这一块的提升，确实没有论文中说的那么好，对于整个网络的贡献，以我做的实际项目的结果来说，history click embedded item &gt; history click embedded brand &gt; history click embedded sort &gt; user info &gt; example age &gt; others。不过，因为时间、数据质量、数据的真实性的原因，可能作为原始input的数据构造的就没有那么好。这边主要和大家说两个点： 1.topic数据原论文中在第四节的RANKING中指出:We observe that the most important signals are those that describe a user’s previous interaction with the item itself and other similar items, matching others’ experience in ranking ads论文中还举出了比如用户前一天的每个频道（topic）的浏览视频个数，最后一次浏览距今时间，其实说白了就是强调了过去的行为汇总对未来的预测的作用，认为过去的行为贯穿了整体的用户点击轨迹。除此之外，G厂大佬还认为一些用户排序性质的描述特征对后面的ranking部分的提高也是蛮重要的，这边还举出了用户视频评分的例子，更多的内容大家可以自己去看一下原论文的部分，应该都会有自己的体会。 回到我们的项目，因为yoho!buy是电商，我类比着做了用户每个类目（裤子、衣服、鞋子…）的历史浏览点击购买次数、最后一次点击距今时长等等的topic信息，提升不是很明显。但是在大家做G厂这边论文，准确率陷入困境的时候，可以尝试一下这边的思路。 2.query infomation相比于论文中的user information的添加，在实际模型测试中，我们发现，query的information的部分有更多的”遐想”。 原论文中点名指出user language and video language 做为basic info的重要性，这边给出的提升也是相对于user info有明显的增长的： 有提升也自然有该部分的缺点：1.语言模型的处理复杂，耗时久在该部分的处理中，我强行拖着隔壁组的nlp博士和我一起搞了一周，每天都加班的搞去做数据清理，句法分析，语句树解析。如果需要让一个常规做推荐的人去弄，会有各种各样的坑，而且耗时还久2.语言新增问题商品的标题这类的文本处理还好，毕竟每日更新的数据存在一个可控的范围，但是用户搜索内容的变化是巨大的，粗略估测一下，一周时间间隔后，原提纯文本数据和新提纯文本数据的交集覆盖率不到78%，这意味着要重复的做nlp工作 attention 机制的引入attention 机制的引入是我老大的硬性需求，我这边也就做了下，如果不了解attention 机制的朋友，可以阅读以下这边文章：Attention model。 我通俗的解释一下，不准确但是方便理解，Attention model就是让你每一个input与你的output计算一个similarity，再通过这些similarities给出每个input的权重。但是，很明显，我们离线训练还好，既有input也有output，但是线上预测的时候，就没有output了，所以，我们采取了lastclick替代的方式： 不得不说，老祖宗传下来的东西确实有独到之处，但是在提升了近1pp的rate代价之下，会有一个让人头疼的问题耗时。因为每一个input的weight需要和output进行一次相似度计算，而且后续还要对计算出的相似度进行处理，原本只需要6-7小时训练完的模型，在我加了3层Multihead Attention后被拖到了一天。数据量还只采样了一半，确实需要斟酌带来的提升与投入的成本之间的平衡问题。 video vectors的深坑G厂一句话，我们测断腿。这句话不是瞎说的，大家应该还记得一开始我给出的那张图，在最上面有一行不是很明显的小字：video vectors。G厂的大佬们既没有说这些video vectors该怎么构造，也没有说video vectors需不需要变动，留下了一个乐趣点让大家体验。 刚开始我很傻的用了我们最开始的embedded item作为video vectors，与模型FC出来的user vectors进行点击，计算top items。我来来回回测了一个月，老命都快改没了，最后提升rate到4pp。然而RNN随便跑跑就能到达3pp，我说很不服气的，所以拉着同事一起脑洞了一下，我们之前做图片相似度匹配的时候，喜欢把图片的向量拆成颜色+款式+性别，所以我们就借用了一下，改成了embedded item + embedded brand + embedded sort作为video vectors，历史总是给我们惊喜，效果上一下子就能大到5.2pp左右，这个点的提升应该是得来的最意外的，建议大家在用的时候考虑一下。 实时化的选择实时部署上，我们用了tensor flow serving，没什么好说的，给一下关键代码，大家看下自己仿一下就行，一般自己做做demo不需要，企业级上线才需要，企业级上线的那些大佬可能也比我有更多想法，所以就不展开了。 123456789101112部署及用python作为Client进行调用的测试：#1.编译服务bazel build //tensorflow_serving/model_servers:tensorflow_model_server#2.启动服务bazel-bin/tensorflow_serving/model_servers/tensorflow_model_server --port=9005 --model_name=test --model_base_path=/Data/sladesha/tmp/test/ #3.编译文件 bazel build //tensorflow_serving/test:test_client#4.注销报错的包注销：/Data/muc/serving/bazel-bin/tensorflow_serving/test/test_client.runfiles/org_tensorflow/tensorflow/contrib/image/__init__.pyc中的from tensorflow.contrib.image.python.ops.single_image_random_dot_stereograms import single_image_random_dot_stereograms参考：https://github.com/tensorflow/serving/issues/421#5.运行bazel-bin/tensorflow_serving/test/test_client --server=localhost:9005 相关的问题，有大佬已经梳理好了，自取其他可选的一些参数设置：tensorflow serving 参数设置。 还有一些评估技巧，模型之间的对比技巧，这边就不细讲了，可借鉴的意义也不大。 总结虽然早就读过这篇文章，但是实现之后，发现新收获仍然不少。我特别赞成清凇的一句话:’对于普通的学术论文，重要的是提供一些新的点子，而对于类似google这种工业界发布的paper，特别是带有practical lessons的paper，很值得精读。’G厂的这个推荐代码和attention model的代码之前是准备放GitHub的，想想还是算了。一是之前也放过很多此代码，也没什么反馈，二是这两个代码自己写也不是很难，可以作为练手项目。 鸣谢以上我个人在Yoho!Buy团队在实践中的一点总结，不代表公司的任何言论，仅仅是我个人的观点。最后感谢项目推进过程中所有合作方和项目组同学的付出和努力，感谢各个团队各位老大们的支持！溜了溜了。]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>论文解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tf.nn.embedding_lookup]]></title>
    <url>%2F2018%2F06%2F11%2FTensorflow%E4%B8%93%E9%A2%98tf-nn-embedding-lookup%2F</url>
    <content type="text"><![CDATA[我觉得这张图就够了，实际上tf.nn.embedding_lookup的作用就是找到要寻找的embedding data中的对应的行下的vector。 1tf.nn.embedding_lookup(params, ids, partition_strategy='mod', name=None, validate_indices=True, max_norm=None) 官方文档位置，其中，params是我们给出的，可以通过：1.tf.get_variable(&quot;item_emb_w&quot;, [self.item_count, self.embedding_size])等方式生产服从[0,1]的均匀分布或者标准分布2.tf.convert_to_tensor转化我们现有的array然后，ids是我们要找的params中对应位置。 举个例子：1234567import numpy as npimport tensorflow as tfdata = np.array([[[2],[1]],[[3],[4]],[[6],[7]]])data = tf.convert_to_tensor(data)lk = [[0,1],[1,0],[0,0]]lookup_data = tf.nn.embedding_lookup(data,lk)init = tf.global_variables_initializer() 先让我们看下不同数据对应的维度：123456In [76]: data.shapeOut[76]: (3, 2, 1)In [77]: np.array(lk).shapeOut[77]: (3, 2)In [78]: lookup_dataOut[78]: &lt;tf.Tensor 'embedding_lookup_8:0' shape=(3, 2, 2, 1) dtype=int64&gt; 这个是怎么做到的呢？关键的部分来了，看下图：lk中的值，在要寻找的embedding数据中下找对应的index下的vector进行拼接。永远是look(lk)部分的维度+embedding(data)部分的除了第一维后的维度拼接。很明显，我们也可以得到，lk里面值是必须要小于等于embedding(data)的最大维度减一的。 以上的结果就是：12345678910111213141516171819202122232425262728293031323334353637In [79]: dataOut[79]:array([[[2],[1]],[[3],[4]],[[6],[7]]])In [80]: lkOut[80]: [[0, 1], [1, 0], [0, 0]]# lk[0]也就是[0,1]对应着下面sess.run(lookup_data)的结果恰好是把data中的[[2],[1]],[[3],[4]]In [81]: sess.run(lookup_data)Out[81]:array([[[[2],[1]],[[3],[4]]],[[[3],[4]],[[2],[1]]],[[[2],[1]],[[2],[1]]]]) 最后，partition_strategy是用于当len(params) &gt; 1，params的元素分割不能整分的话，则前(max_id + 1) % len(params)多分一个id.当partition_strategy = ‘mod’的时候，13个ids划分为5个分区：[[0, 5, 10], [1, 6, 11], [2, 7, 12], [3, 8], [4, 9]]，也就是是按照数据列进行映射，然后再进行look_up操作。当partition_strategy = ‘div’的时候，13个ids划分为5个分区：[[0, 1, 2], [3, 4, 5], [6, 7, 8], [9, 10], [11, 12]]，也就是是按照数据先后进行排序标序，然后再进行look_up操作。]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>tensorflow代码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tf.scan]]></title>
    <url>%2F2018%2F06%2F04%2FTensorflow%E4%B8%93%E9%A2%98tf-scan%2F</url>
    <content type="text"><![CDATA[tf.scan(fn, elems, initializer=None, parallel_iterations=10, back_prop=True, swap_memory=False, infer_shape=True, name=None) fn：计算函数elems：以elems的第一维度的变量list作函数计算直到遍历完整个elemsinitializer：fn计算的初始值，替代elems做第一次计算 举个好理解的例子：123456789101112131415x = [1,2,3]z = 10x = tf.convert_to_tensor(x)z = tf.convert_to_tensor(z)def f(x,y):return x+yg = tf.scan(fn=f,elems = x,initializer=z)sess = tf.Session()sess.run(tf.global_variables_initializer)sess.run(g) 会得到：12In [97]: sess.run(g)Out[97]: array([11, 13, 16], dtype=int32) 详细的计算逻辑如下：11 = 10(初始值initializer)+ 1(x[0])13 = 11(上次的计算结果)+2(x[1])16 = 13(上次的计算结果)+3(x[2])]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>tensorflow代码解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写给想转行机器学习深度学习的同学]]></title>
    <url>%2F2018%2F03%2F18%2F%E5%86%99%E7%BB%99%E6%83%B3%E8%BD%AC%E8%A1%8C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%90%8C%E5%AD%A6%2F</url>
    <content type="text"><![CDATA[update 1:很多同学还是私信我，让我推荐或者提供一些电子书给他们，我这边也打包了一些我认为比较重要的，如果有需要的同学可以「邮箱」联系我。申明，我所发送的书个人均已购买正版实体书，建议大家也支持正版，谢谢。 自从我毕业以来，先是火机器学习，然后火大数据，之后火深度学习，现在火人工智能这些算法领域。越来越多的朋友想从工业，金融等等行业转行到算法相关的行业，我一年前在知乎上写了一个答案本科生怎样通过努力拿到较好的机器学习/数据挖掘相关的offer？，当时拿了不少的赞，所以也一直有同学找我咨询相关的问题，确确实实也有相当一批人拿到了不错的offer。 我个人不是很喜欢更新非技术的文章，但是我还是觉得如果能帮助到一些人，其实也是另一种技术输出的展现，所以我就写下了下面这篇短文，希望对迷茫的人有所帮助。 评估转行难度今天一大早，我在刷知乎的时候，刷到这个题目非计算机专业学生如何转行AI，并找到算法offer?，我看到这个叫做BrianRWang的答主的一个“10问检验你的基础水平”，我觉得是至少我看来非常全面考验数学基础的，所以这边就和大家分享一下（答案我会在最后给出，有兴趣的最好自己做一下，括号里面的我个人觉得没有意义所以没有给出解释，有兴趣的却又解不出来的同学可以私信我）： 1.什么是贝叶斯定理？请简述其公式？现分别有 A，B 两个容器，在容器 A 里分别有 7 个红球和 3 个白球，在容器 B 里有 1 个红球和 9 个白球，现已知从这两个容器里任意抽出了一个球，且是红球，问这个红球是来自容器 A 的概率是多少? 这题考了概率论的基础，虽然考了贝叶斯，但是后面的容器问题完全可以不用贝叶斯也可以算出来，算是一题数学敏感度的测试题，看看自己适不适合去努力切入这个方向。 2.请简述卡方分布和卡方检验的定义？(给你一个2*2的列表让你算卡方分布，你会怎么做？) 这题考了梳理统计的基础，括号里面的我个人觉得没有意义，有兴趣的可以查表算一下。 3.在概率统计学里，自由度是如何被定义的，又该怎样去应用？ 原作者BrianRWang认为这题比较偏，属于冷门题目。个人看法：其实我觉得如果是任何一个理工科的同学，这题都应该能答出来，大学的课程里，自由度的理解直接决定了统计科目大家的学习质量。 以上的三题考了概率论与数理统计的基础，在机器学习理论中，概率论和数理统计的基础是否扎实直接决定了能否很好的理解各个理论的前置条件，适用场景，提升方向等，着实重要。 4.请简述什么是线性代数里的矩阵特征值和特征向量？(求矩阵:A=np.array([[1,2],[3,4]])的特征值，特征向量，写出其运算公式) 线性代数题目，很简单给出对应的公式即可，我在SVD介绍的时候就完全讲过。如果换成，如何理解特征值及特征向量在空间中的实际意义，这题就会变得非常卡人。 5.如何使用级数分解的方法求解e^x?(并给出在数值计算中可能遇到的问题。) 数学分析的题目，一个公式。 以上的题目都是线性代数，数学分析的题目，都是比较考验大学的基本功，如果不记得也很正常，只要能说出大概的思想就行，比如空间选择啊，点导数展开。 6.数据结构的定义是什么？运用数据结构的意义是什么？ 计算机题，这题应该是几个问答中最简单的了。 7.请说明至少两种用于数据可视化（data visualization）的package。并且说明，在数据分析报告里用数据可视化的意义是什么？ 前一问如果主动接触过计算科学的人这题比较好答，如果是纯新手，这题就是无从下手的。后面一小问也是属于考察你的数据敏感度的，如果能够match到一些点，很加分。 8.假如让你用编程方法，比如python，处理一个你没见过的数学问题，比如求解一个pde或者整快速傅里叶变换，你应该查什么东西，找哪一个package的参考资料？ 同上一条前一部分。 9.请简述面向对象编程和函数式编程分别的定义，并举出其案例。 计算机题，考了基础的编程的一些风格的了解程度，说实话，这题我第一次看到也很懵，还去Google了一下。 原作者还有一个第10题，不涉及技术，我就没放。以上四题更偏向coding的能力，虽然说算法工程师、数据挖掘工程师、NLP工程师，等等，都是挂着科研的title，但是过硬的coding能力是完全不能缺少的，要其他人把很复杂的数学理论用代码帮你实现出来的交流成本巨大，我觉得精通或者熟悉至少一门语言还是非常重要的。 原作者认为： 以上提问如果能闭卷对7个及以上，证明一个学生的基础还是比较好的。只要聪明肯学，一定是有所裨益的。在7个，到3个之间，不妨提高一下自己的数学水平；努努力还是可以学会机器学习的。如果写对不了两个（“这都啥啊？”），郴州勃学院复读班欢迎你过去。 其实我还是比较认同的，答对3个或者2.5个以上的同学，完全可以试一试转一转，我觉得不存在说入不了门的情况。能答对7个或者7.5以上的同学，我觉得可以投简历了，如果我收到你的简历，即便是你没有历史的工作经验，我很愿意让你试一试的。 一些资料很多转行的朋友会问我，到底看什么书会比较好，我刚开始会推荐一堆，后来自己想了想发现，还是太天真，大家工作忙的要死，看一本就很难了，别说一堆。 我最后就浓缩了三本:：周志华老师的西瓜书（《机器学习》周志华 清华大学出版社），李航的带你玩转基础理论（《统计学习方法》李航 清华大学出版社），经典厕所读物（《数学之美》吴军 人民邮电出版社）。 确实是很经典很经典的书，我现在基本上每次必回答以上三本。 除此之外，在coursera上找吴恩达（Andrew Ng）教授的机器学习课程，他把要用到的数学知识也做了简单的讲解，机器学习方面的理论和算法讲的也很详细，而且很基础，肯定可以看懂。Machine Learning | Coursera，应该是最适合看的视频类的资料没有之一。 我不反对也不支持大家去参加几千几万的速成班，几十几百的live课程，但是我觉得你不妨先看完以上的书和视频再做决定，一定不会让你失望。之前我一直在给team做吴恩达（Andrew Ng）在线课程的分享，一直到最近我发现不如整理出来给team以外的大家一起看算了，所以在Gradient Checking(9-5)这节课之后的所有课程，如果有价值的地方，我都做了笔记后面会分享在我的GitHub中，希望给大家一些帮助。 最后，希望我们都不负自己的青春。 附录：1.BrianRWang的十条问题的答案链接2.吴恩达（Andrew Ng）Gradient Checking(9-5)这节课之后的课程整理（持续更新中）]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>公告</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yoho!buy注册概率预估]]></title>
    <url>%2F2018%2F03%2F04%2Fyoho!buy%E6%B3%A8%E5%86%8C%E6%A6%82%E7%8E%87%E9%A2%84%E4%BC%B0%2F</url>
    <content type="text"><![CDATA[GRU 部分的demo代码：model.py，注意，其中上传的lr_classification.py并没有做wide&amp;deep设计 前言本文主要介绍yoho!buy大数据团队在深度学习传统应用方向上的一些实践和思考。传统用户行为预估方向上，如何根据用户的行为数据，对用户行为建模，进而预测用户的购买行为，点击行为，注册行为等等一直以来都受到工业界及学术界的关注。相对而言，就用户注册概率的预测受限数据获取的局限性、传统的计算模型的时效性等原因并没有很多可参考的研究案例。我们想和大家分享的「yoho!buy基于GRU+LR算法下的用户注册概率预估」，基于循环神经网络的框架，充分的利用了用户在app上的行为信息，保证了高效的结果反馈速度，兼备算法框架良好的延拓性能。 注册概率预估定义注册概率预估，即预估用户下载app后，浏览app过程中主动注册的可能性。通过识别出有注册倾向的人群，辅助以人为介入的方式（优惠、折扣，关怀等），可以提高用户实际注册的概率。 基本的注册概率预估算法设计的流程如下： 数据整理节点：在于收集用户行为信息，包括地理位置，当时的时间，用户来源的渠道，用户点击行为等等；模型计算节点：在于根据数据整理节点的结果判断用户的注册概率高低；计算结果推送节点：在于根据不同注册概率用户采取不同的营销策略，个性化引导用户注册。 目前注册概率预估主要有两大难点： 传统模型难以实时预测：因为缺乏平台忠诚度，用户第一次也有可能是最后一次登陆app之前这段时间是相对暂短，如何压缩用户每一次步操作下的模型计算时间，提高反馈频率是需要考虑的重要问题，而传统模型在这方面的表现比较平庸。 传统模型特征加工复杂：因为用户可能是第一次接触app，在没有注册信息，历史行为信息，完成订单信息等等数据下，利用有限的数据进行的特征处理，如果想要有不错的效果相对而言特征加工过程的复杂程度和难度要比普通的项目更加具有挑战性。 我们通过以Recurrent Neural Network 及 Logistic Regression为基模型，通过Stacking方式，针对性的尝试去解决以上两个注册预估中的难点。其中Recurrent Neural Network最本质的能够work的地方在于，实际上在没有过多特征的时候，对于新用户来说，他的浏览路径实际上就是反映了他对这个app的喜好。 算法设计Recurrent Neural Network基模型数据整理部分无论在Kaggle还是天池大赛上，数据特征工程是非常重要而且繁琐的一个过程：关于预处理，通常我们会采取： 数据检查，提出异常字符、乱码等数据 缺失值处理，剔除、填充、拟合构造等 方差衡量，剔除方差低的低贡献特征 共线性检查，提高泛化能力 异常检验，剔除错误异常数据 … 在数据预处理结束之后，我们还会在更新完的数据集上进行特征筛选： 基于自变量与因变量之间的交互熵 基于模型中的特征贡献程度（Xgboost里面的importance/Lasso、Ridge中的参数绝对大小） 基于预训练模型中的特征参数的显著性 基于自变量之间的相关性 … 在数据特征筛选结束之后，我们还需要进行特征组合寻找最大方差下的新的特征，还会通过PCA/LDA/t-SNE/FM等寻找是否可以进行降维或者升维，交叉特征构造等等。通常无论是在离线训练还是线上预测中，对特征的加工处理过程都是非常耗时的，极有可能在用户已经离开app后，用户的注册概率还没有算出来。 我们利用Recurrent Neural Network来解决注册预估的时候，我们需要做的数据整理就非常的轻松，只需根据用户浏览的顺序，将用户浏览的页面编号Item_Page,同时记录用户浏览的先后顺序Time_Rank： 构造如下的数据形式： User_Imme Item_Page Time_Rank 012939003331092 92374573284354 1518422132 012939003331092 82374573771273 1518422142 012939003331092 92374573284354 1518422147 078939002221093 66774573284354 1518422247 078939002221093 66774573284442 1518422249 … … … 数据处理过程，只需要按照用户的浏览先后顺序进行排序即可，大大的降低了耗时，对整体算法的实效性上不会产生任何影响。因此，我们甚至可以在用户每一次产生动作之后就对其的注册概率进行重新判定，得到用户的浏览流对应的注册概率波动情况。 我们的用户可以大致可分为铁粉用户和普通用户两种。从用户的注册概率分布就可以很清晰的看出：铁粉用户浏览目的明确，寻找自己关注的商品，一旦找到立马注册下单，所以铁粉用户的时间流较短，注册概率呈现上升趋势，注册概率均值较高，需要我们运营手段干涉的情况较少；而普通用户属于无明确目的的浏览，所以注册概率的波动较大，注册概率均值较低，但是一旦察觉到用户有高概率注册的行为却未注册且注册概率持续下降时立刻进行营销引导，多次营销尝试后用户成功注册。 模型计算部分整体的模型框架概览如下： 我们试图通过循环网络部分提取出用户的浏览行为的汇总信息，再通过Logistic Regression部分融合用户基础信息，以行为特点+基础特征猜测用户每次浏览是属于随便点点还是认真挑选。 Recurrent Neural Network部分1.循环单元结构 在循环神经网络模块中，我们采取了Gated Recurrent Unit (GRU)代替普通RNN作为最小循环单元进行计算，以此来避免梯度消失等问题： 隐藏状态计算如下： 对比LSTM，GRU只用了两个gates，将LSTM中的输入门和遗忘门合并成了更新门。并且并不把线性自更新建立在额外的memory cell上，而是直接线性累积建立在隐藏状态上，并靠gates来调控，这样就可以大大的加快离线训练的速度，同时在RNN的官方论文中，我们看到了实测的效果如下： 很明显的可以看到:虽然GRU减少了一个门的存在，但是效果与LSTM相当，但是几乎每次测试的test效果都要优秀于传统方法，同时GRU是真的肉眼可见的比LSTM快。综合考虑了计算速度及最后计算结果的准确程度，我们选择了多层GRU模型而并非是以输入门、输出门、遗忘门为信息传递的LSTM模型。 2.循环网络结构 整体上看，网络结构也是非常简单的。如上图，先将用户浏览的所有商品进行embedding操作，然后根据用户每个商品的浏览顺序构建时序序列，进行多层的GRU模型训练，最后再以前馈网络传递，softmax后得到用户下次点击每个商品的概率，再根据预测结果Output Second Items 和 Real Second Items修正多层GRU layer中的参数。 通过已经训练好的循环网络，我们根据新用户浏览商品的顺序，得到用户每次浏览的后一次浏览每个商品的概率（output scores）及用户前N次浏览信息的trend，seasonality的汇总（隐藏状态GRU States）。与此同时，我们可以通过控制GRU layer的层数及优化多次隐藏状态GRU States的拼接方式控制整体模型框架的复杂程度。 3.用户数据构造 用户数据训练过程常常采用如上图这样的最小批处理。每一个Session就可以看作是一个用户，每一个i可以看作是一个商品，商品i的下标代表着商品的浏览顺序。 input中，每一行表示的为多个用户正常的浏览顺序中的起始商品，比如Session1用户浏览顺序：i1.1—&gt;i1.2—&gt;i1.3—&gt;1.4中的i1.1，i1.2，i1.3；对应的，在output中，每一行代表多个用户在input位置的下一次浏览内容，比如Session1用户浏览顺序：i1.1—&gt;i1.2，i1.2—i1.3，i1.3—&gt;i1.4中的i1.2，i1.3，i1.4；当input中的一个的用户或者说是一个的Session的点击信息被全部使用后，追加一个新的用户或者说是Session的点击信息，同时通过控制同时计算的用户或者说Session的个数，直到所有的Session信息都被使用完一遍，这样就构造完成了一个由用户的上次点击结果预测用户的下次点击结果的循环神经网络。 这样设计避免了通常的神经网络构造在用户行为上应用中的两个问题： 固定滑动窗口导致大量用户信息不能获取完整 拆分用户的浏览行为计算导致循环网络在信息理解上的歧义 4.损失函数选取 关于损失函数的选取，我们这边主要推荐两种方案：基于贝叶斯后验优化(BayesianPersonalizedRanking,BPR)和第一准则(TOP1)： 贝叶斯后验优化(BayesianPersonalizedRanking,BPR)是一个近似矩阵分解的方法，我们分别选取当前用户当前商品的下一个真实浏览的商品作为Positive Item，随机抽样的商品作为Negative Item，具体表达形如：，其中Ns即为随机采样个数，中k为i时对应Positive Item的真实计算得分，K为j时对应Negative Item，保持i=Positive Item不变，计算所有抽样出来的Negative Item作为j进行计算即可。 第一准则(TOP1)是我们自己设计的一个近似排序的方法，我们想要真实的Positive Item所计算出来的结果尽可能的接近1，Negative Item计算出来的结果尽可能的接近0，所以我们要保证采样出来的Negative Item比Positive Item在当前计算方式下的得分要低，所以，我们可以设计损失函数如下：，最末项增加了个正则项修正拟合程度。 除此之外，《SESSION-BASED RECOMMENDATIONS WITH RECURRENT NEURAL NETWORKS》中还提到了POP，S-POP，Item-KNN，BPR-MF等方法，可单独了解。 Logistics Regression部分通过Logistics Regression部分提高融合Recurrent Neural Network的潜藏层和传统的用户基础特征，进行一次重排序的操作，个性化的提供用户的注册激励也是非常重要的一环。整个Recurrent Neural Network部分在一定程度上帮助我们获取到了用户的浏览操作行为中的trend和seasonality（隐藏状态GRU States），但是缺乏考虑外部信息，比如热点爆品，用户区域，用户性别，用户需求等等。最典型的一个例子就是，我们不能向一个浏览了多个中性黑色太阳眼镜的正在试图走酷雅风格的东北女性推送潮牌男性短裤优惠券作为注册激励，很多时候会起到相反的作用。 如何兼顾Recurrent Neural Network部分的潜藏数据与为数不多的用户基础特征数据，并加以融合快速反馈出结果，是需要多方面考虑的：数据应用 数据类别 数据详解 基础用户画像 人口属性，地点，性别，消费力等 主动行为数据 品类偏好、品牌偏好、行为性别等 文本偏好数据 浏览商品文字描述特征 反馈数据 停留时长，复停留行为，当前时间段等 … … 基础用户画像&amp;主动行为数据：我们可以在用户原始日志中快速清洗出用户的地址，环境，设备等基础信息，结合用户浏览商品的性别+价格+品牌加权预估出用户的性别，消费力等价值属性，品类偏好、品牌偏好、行为性别等基础汇总属性。 文本偏好数据：根据用户的浏览商品，去匹配是否命中了我们预先提取出的注册用户浏览高频关键词，比如“鬼洗”，“典藏”等等及当前的一些热点词汇“小白鞋”，“华莱士”等。 反馈数据：在整个Recurrent Neural Network部分我们考虑的是用户的浏览顺序，但是忽略了用户的浏览质量，用户进入平台后的15s内，A商品重复浏览了3次，停留了9S，B商品重复浏览了1次，停留了1S，商品A的注册激励价值是远远高于商品B的。 通过以上的方式获取到的“用户画像”好处在于快速，再扩充了用户基本属性的同时还能够在规定的时间内完成所有的重排序计算，但是缺点在于一定程度上降低了用户特征刻画的精度。 数据融合 在实际的应用过程中，我们发现，在一定程度上交叉部分高价值的用户特征有助于提高最后的预测结果的准确性，构造的框架图如下： 这边借鉴但是没有完全采用wide&amp;deep的方法，借鉴了对原始用户特征需要通过embedding layer进行处理，比如通过简单的one hot encoding的形式，然后采取特征交叉的方式获取新的用户特征，最后再进行前向传播或者logistics regression；但是此处，在embedding layer的过程中会采取人为限制分箱逻辑去噪（剔除了比如地点归属000ex00f这样的错误数据），在交叉过程中只选取了部分对最后的用户注册影响较大的因素进行交叉，在提升了模型对用户拟合的能力的同时也保证了模型的实效性。 数据流设计 简单的数据执行流如下： 主要步骤如下： Kafka+Flume解析实时点击、搜索、浏览等用户操作日志流，在线进行用户操作数据的抽取 实时解析基础用户环境信息，获取环境特征：手机型号，网络，地址等，实时写入到线上Hadoop/Spark中的HDFS里 根据离线存储在HDFS中的用户操作数据、用户点击流数据和用户是否真实注册的结果离线更新循环网络GRU及LR模型参数 将新的模型参数应用于线上用户数据的预测 最后可得到个人及全站的注册概率变化可视化如下： 可优化方向 GRU卷积神经网络的层数优化，由多层隐藏层替代单层隐藏层提高对用户行为的汇总效果 Logistics Regression部分可以由多模型bagging替换，降低过拟合的可能 反馈数据清洗，对于有强烈意愿注册的用户进行识别，避免干扰正样本池 推荐内容干扰，那些热门爆款更多的用户看到，而且“被看到”这个行为也加深了它接下去被接连看到的可能性 GRU卷积神经网络的构造中，修改上一次操作预测下一次操作为上一次操作预测目标行为（常停留时长的点击、收藏点击等等高价值的行为节点） 总结传统的机器学习方案给用户行为预估的项目一个基准水平线，而深度学习的出现，一定程度上使得这个上限有所提高，但是以数据为基础，用算法去雕琢，只有将二者有机结合，才会带来更好的效果提升。 以上是yoho!buy团队在实践中的一点总结，当然我们还有还多事情要做，keep learning！最后感谢项目推进过程中所有合作方和项目组同学的付出和努力，感谢各个团队各位老大们的支持！]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>理论解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅入浅出深度学习理论实践]]></title>
    <url>%2F2018%2F02%2F07%2F%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[前言之前在知乎上看到这么一个问题：在实际业务里，在工作中有什么用得到深度学习的例子么？用到 GPU 了么？，回头看了一下自己写了这么多东西一直围绕着traditional machine learning，所以就有了一个整理出深度学习在我熟悉的风控、推荐、CRM等等这些领域的用法的想法。 我想在这边篇文章浅入浅出的谈谈这几个方面，当然深度学习你所要了解必然不仅仅如此，后面如果有机会我会一篇篇的完善： CNN/RNN理解 Attention理解 深度学习（CNN和RNN）传统领域的简单应用 关于深度学习的一些想法 大概会将全文分为以上几块，大家可以跳读，因为本文理论上应该会冗长无比，肯定也包括数据块+代码块+解析块，很多有基础的同学没有必要从头在了解一遍。好了，让我们正式开始。 CNN/RNN理解CNNCNN，卷积神经网络，让我们先从一个简单的网络结构来梳理一下： 输入层假如，我们有car,plane,desk,flower等等一共十类的图片，需要让电脑识别图片是哪种的话，自然需要把图片变成电脑理解的了的一种方式，比如：RxGxB（图片的高度、宽度和深度）也就是上面输入层32x32x3，至于什么是RGB，请自行阅读RGB百度百科。 卷积层一/卷积层二 这张图片我觉得形象的不能再形象了，让我们结合代码和图形来理解这个卷积到底是什么意思。tensorflow中卷积的集成代码如下： 123filter_weights = tf.Variable(tf.truncated_normal([window_size, embed_dim, 1, filter_num], stddev=0.1),name="filter_weights")conv_layer = tf.nn.conv2d(item_embed_layer_expand, filter_weights, [1, 1, 1, 1], padding="VALID",name="conv_layer") filter_weights的shape是window_sizexembed_dimx1xfilter_num，window_sizexembed_dimgx1就是类似于gif图中的黄色区域的大小，这边就可以看作window_size=embed_dim=3，filter_weights第三维的1是指HRG中的第三维度： filter_weights第三维如果是2的话： 想到于多了一维的并行处理，接下来看filter_weights的filter_num，最上方的gif的动图解释了卷积层的计算形式： 黑色字体的1/0矩阵是原来图像的像素值，红色的1/0是上面设置filter_weights值，他们的分别计算后的累计值即为一次扫描计算结果，比如黄色区域即为1x1+1x0+0x1+1x0+1x1+1x0+0x1+1x0+1x1.将所有的像素值所在的位置都进行一次扫描后就可以得到： 当然，除了随机生产filter_weights，图像操作中，指定不同的filter_weights会起到不同的作用： 但是这里面存在两个问题： 边界扫描 扫描速度 边界扫描（padding=”VALID”）VALID模式如上图所示，对原始图像进行卷积，卷积后的矩阵只有3×3阶，比原来的图片要小了。 SAME模式要求卷积后的feature map与输入的矩阵大小相同，因此需要对输入矩阵的外层包裹n层0，然后再按照VALID的卷积方法进行卷积。 n的求法如下式： 1234SAME：edge_row = (kernel_row - 1) / 2edge_cols = (kernel_cols - 1) / 2VALID：edge_row = edge_cols = 0 其中，edge_row是包裹0的行数，edge_cols是包裹0的列数 , kernel_row就卷积核的行数。 扫描速度（tf.nn.conv2d中的[1,1,1,1]）这个概率也是最好理解的了，就是图中的黄色方框位移的速度： 回到最上面filter_num，filter_num的值就是重复上述流程的次数，随着次数的增加，会增加后面pooling层的基础数据层数：每次黄色箭头后的pool层的层数就是filter_num。 到此为止，卷积层就简单的梳理完了，主要是要清楚几个概念：filter_weights的作用，filter_num的定义，padding的差异，还有扫描的速度。这些主要是围绕着下面我要实际应用的场景梳理的卷积神经网络的知识点，如果要深刻透彻的了解还需要更多更深入的解读。 池化层一/池化层二先从数学角度来看，它的操作步骤： 这张图看起来，和卷积层中的image —&gt; Convolved feature非常类似，也是确定一个shape之后，对shape内的数据进行操作，但是差异就在：卷积层中是采取对image里面的像素点逐点计算后汇总，相当于加权了每个像素点的作用；而池化层通常采用最大/最小/均值/求和等方式汇总Convolved feature。 罗列出来就是： 对象不同，一个是image，一个是Convolved feature 计算方式不同，一个matrix点对点乘积后求和，一个是直接求和（或者其他聚合操作） 池化层数学的操作比较简单，在实际工程中的理解比较让人困惑，其实，意义主要在三点： 其中一个显而易见，就是减少参数。通过对 Feature Map（通过的手段是聚合计算） 降维，有效减少后续层需要的参数 一个是 Translation Invariance。它表示对于 Input，当其中像素在邻域发生微小位移时，Pooling Layer 的输出是不变的。这就使网络的鲁棒性增强了，有一定抗扰动的作用 另一个是以区块的角度代替逐个点进行计算，降低每个点对最后结果的影响，避免了过拟合的现象 全连接层/输出层这个就比较简单了，全连接层（FC）构造如下： 1tf.layers.dense(brand_embed_layer, embed_dim, name="brand_fc_layer", activation=tf.nn.relu) 简单的来说，通过activation增加了特征的非线性的拟合能力；如果不设置activation的话，就增加了特征的线性拟合能力。 但是，我们要知道，全连接层会有很多缺陷： 在一定程度上，可以通过增加全连接的层数提高train data的准确率，但是如果过分的增加，会造成过拟合，所以如果是自己写的网络，一定程度上，如何控制还好全连接层的数量决定了valid data了准确率的波动。其实，完全可以通过pool层代替全连接层，17年年初很多论文指出：GAP（Global Average Pooling）的方法可以代替FC（全连接）。思想就是：用 feature map 直接表示属于某个类的 confidence map，比如有10个类，就在最后输出10个 feature map，每个feature map中的值加起来求平均值，然后把得到的这些平均值直接作为属于某个类别的 confidence value，再输入softmax中分类， 更重要的是实验效果并不比用 FC 差，所以全连接层的分类器的作用就可以被pool层合理代替掉。 而且，全连接层参数冗余（仅全连接层参数就可占整个网络参数60%-80%），计算量会集中在这些参数的计算上，而且随着你的层数的增加，你的计算成本越来越大，如果是非GPU的机器在计算的过程中会非常非常吃亏。 之所以，现在的很多很多流行网络还是以FC参与计算的原因： 简单，很方便了解。而且当前的各个计算框架tensorflow，caffe等等对FC的封装即成也是非常的完善 借鉴非常容易。举个例子，如果已经有了一个通过输出层产出10类的模型，我现在要做一个5类的模型的话，我只需要在最后一次FC层后面增加一个embed_dim=5的FC层即可。 上面就简单了梳理了CNN里面的简单的网络结构，是不是真的就是这么简单呢？让我们看看上面叫做相对成熟的网络： 图像中几年前的技术，Alexnet，SSD，Yolo，还有去年的RCNN，fast-RCNN等等，网络结构都远远比我们想象中的要复杂，在对数据操作的行为中，无非也是上面这些操作的一些组合。 再次强调，本文重点不在介绍CNN，而是利用CNN作为传统机器学习做协助，所以，如果想要深入了解CNN的同学建议从头开始学习，不建议阅读我这种跳讲的内容作为入门。 RNN相比CNN而言，RNN要简单而又有趣一些： 几乎所有的讲RNN的技术文章都会有下面这张图，无法免俗，因为确实囊括了RNN的核心： 不得不说，nlp是RNN非常优秀的应用场景，我们从nlp的角度去切入，观察RNN在其中所起的作用也是非常好的一个方式：假设有一句话：“今天天气真的不是很好，让我们去____吧。” 如果用朴素贝叶斯来解决这个填空问题，它的解决思路是： 先分词，今天，天气，真的，不是很好，让，我们，去，吧 去除语气词等，剩余天气，不是很好，我们，去 再根据贝叶斯公式得到概率最大的值 如果用N-Grams来解决这个填空问题，它的解决思路是： 先分词，今天，天气，真的，不是很好，让，我们，去，吧 去除语气词等，剩余天气，不是很好，我们，去 根据前缺失词的前N个词的条件概率来计算出具有最大概率的缺失值 朴素贝叶斯的方法只考虑每个词出现的结果没有考虑先后顺序，可能导致由意外的非真实排序决定缺失值的问题；N-Grams的方法虽然考虑了每个词出现的可能的同时，也考虑缺失值前N个词的内容，但是由于计算能力的约束，并不能够完整的保留全部的前置语句的信息。 而RNN的出现，利用state层来存储前面t-1刻的信息，并循环传递在每次输出计算中，解决ngram做不到的完整信息保存的问题，如下图： 很明显，在对Yt+2的结果预测的时候，考虑到了前面所有前置的信息。 这张图很好的解释了RNN的传递逻辑，将所有前期的信息以state的形式进行传递，在第t次的输出结果计算的过程中，不仅仅考虑第t次的输入值，同时考虑t-1次的state，也就是前t-1层的信息的流动汇总结果。我们知道，最简单最基础的RNN里面，可以通过tanh层来合并t-1时刻的state和t时刻的xt信息的。虽然理论上来说，无论信息是各多远，RNN都能够记得，但是！但是！实际上，我们发现，RNN随着tanh的重复操作，是无法稍远的信息就无法合理的被记忆，幸运的是后面优化出来的LSTM和GRU就能一定程度上缓解这些的问题。 下面让我们以GRU为例子，具体看看RNN是怎么进行一次循环神经网络的计算的： 这边大家需要注意，与LSTM不同，GRU将LSTM中的输入门和遗忘门合并成了更新门。而且没有建立中间过渡键memory cell，而是直接通过更新门和重置门来更新state。这样做的好处就是大大的降低了计算的成本，加快了整个RNN训练的速度。同时通过各种Gate将重要特征保留，保证其在long-term传播的时候也不会被丢失，也有利于BP的时候不容易造成梯度消失。 在RNN的官方论文中，我们看到了实测的效果如下： 很明显的可以看到，1.虽然GRU减少了一个门的存在，但是效果与LSTM相当，但是几乎每次测试的test效果都要优秀于传统方法。2.GRU是真的肉眼可见的比LSTM快，证实了我们上述说的内容。也是因为这些原因，在后面为实际应用的过程中，我也是选择了GRU来代替了LSTM做向量化及state层提取等等操作。 问题来了，虽然我知道LSTM和GRU在最后实测的效果上是比直接用tanh的简单RNN效果要好的，但是我也无法解释和理解为什么这样的构造就能够有这样的提升，这就比较尴尬了。 另外要提的一点就是，在GRU实际计算的过程中，采取了学习参数拼接的方式，比如上面的Wz，Wr等是通过拼接的方式存储的，在需要的计算的时候再拆分开进行计算： 这也是让我在学习GRU过程中眼前一亮的点，非常值得玩味的地方。 Attention理解在篇幅如此冗长的情况下，我依然坚持要和大家讨论一下关于Attention的一些看法和观点，我觉得正是有attention的存在，才让我们能够想到如何更好的去扩展应用这些深度学习的方法。 我之前一直没有找到很好的通俗易懂的解释attention的文章，这边我尝试以业务的角度为大家分析一下，尽可能的抛开数学的角度让大家浅入浅出一下。 假设存在用户A，及他的各种行为A_actions，如果我不做任何操作简单的把他的各种行为A_actions当成变量进行模型训练可以得到模型AM。但是，如果我知道，他可能是一个2年前流失近期活跃的用户，我选择剔除他两年前的A_actions，而只考虑他近期的行为，这样的过程其实就是一个Attention的过程，因为我们要预测他近期可能买什么，所以我们应该把关注点集中在了他近期的部分信息而不是全部信息上。 而在深度学习运用的过程中，我们也应该考虑attention的问题，比如用户商品点击流为A—&gt;B—&gt;A—&gt;C—&gt;D，我们常规操作是什么样的？无非是： 生成4xembed_dim的embedding层 将ABCD四个商品编号为0123 找到对应商品在embedding层中的向量表示 Encoder过程完成 通过RNN或者其他深度学习网络进行非线性Decoder输出对应的可能结果 以上就是一个非常简单的Encoder-Decoder过程。 仔细想想其实就会发现很多不合理的地方，比如我在B商品停留了2mins，而其他商品均只停留了不到10s；再比如，我有购买C商品的历史，ABD商品均为第一次接触等等。其实，对于ABCD而言，简单的理解就是它们为不是等权的。而且我们发现，随着你的信息量的增加，也就是item点击流的长度增加，encoder的信息丢失就会变得非常严重，decoder的难度会大大的提升。 回过头来看上述的流程，如果变成： 生成4xembed_dim的embedding层 将ABCD四个商品编号为0123 找到对应商品在embedding层中的向量表示 Xa,Xb,Xc,Xd = ∑(aiA,biB,ciC,diD) 通过RNN或者其他深度学习网络进行非线性Decoder输出对应的可能结果 换句话说，就是在坑爹的Encoder到Decoder过程中，增加了缓冲计算Ci，通过构造Ci代替Encoder结果进行Decoder的过程，让深度学习的过程更加的合理。 数学的形式就是: 1234y1=f1(C1)y2=f1(C2,y1)y3=f1(C3,y1,y2)... 比如我在B商品停留了2mins，而其他商品均只停留了不到10s时，我们就可以构造缓冲C=g(0.1xf(A)+0.6xf(B)+0.1xf(C)+0.1xf(D))，这意味着A—&gt;B—&gt;A—&gt;C—&gt;D—&gt;?，对于？的判断，B起了比ACD都要重要的作用。 大名鼎鼎的RNN在attention的机制下就会变成： 那么具体如何构造缓冲C呢，我们看下面这个流程：首先，在RNN最初参数设置的时候，我们会确定init memory，不妨记为z0；hi为当前时刻输出的隐层输出向量，所以对每个商品ABCD都有一个z0与hi的相似度∂0i： 在每次循环之前，相当于考虑了当前所有的输入（比如此刻的ABCD）与initmemory的匹配度，至于匹配度match在论文中的计算方式为：矩阵变换α=hTWz (Multiplicative attention，Luong et al., 2015) ，其实简化为余弦相似度也是可以的，只要能判断两者之间的相似程度都行。算出所有的∂0a,∂0b,∂0c,∂0d后归一化后的值即可作为ABCD对应的隐层ha，hb，hc，hd的权重： c0即可作为rnn的输入，有c0和z0，我们非常容易可以算出z1，得到z1后，重复上述的过程可以得到c1…，如此循环，直到结束。论文中的计算方式如下： 和nlp中构造方式对比起来，还是有一定的差异，nlp的训练集往往是确定的。比如：“我爱学习”翻译为“i love studying”，我翻译为i，所以我确定一定要对“i”进行翻译的时候，需要提高对应i的权重。而我在商品点击流预测购买概率的时候，只能通过停留时长，历史是否购买过来建立约等的关系，但是这个约等的关系是不存在强成立的前提的。 attention的机制最初理解起来有点绕，但是如果能够搞懂并在我们做深度网络设计中应用起来，理论上收益还是非常之大的，建议大家把上述为贴的论文详读一边，真的是写的非常不错的一篇文章。 深度学习传统领域的应用我们先来回想一下，我们做传统有监督是怎么做的，如果记不得了，可以回顾这篇文章：提升有监督学习效果的实战解析，我认为有几点传统有监督学习不是很友好： 特征工程 实效性 数据解析能力 特征工程想必有过特征工程项目经验的同学可能是对数据预处理及特征筛选过程心有余悸： 是不是用户信息，商品信息，用户历史信息，商品信息统计属性刻画，用户行为整合每一块写hive都要很久很久？跑数据的时间更久？ 是不是数据好不容易跑出来了，各种垃圾信息，各种格式问题，pandas，numpy来回折腾到几百行的代码？ 是不是好不容易数据处理完，一跑结果auc0.6？修改都不知道怎么修改？ 是不是四处看别人整理的调参心得，比如这个家伙的Kaggle&amp;TianChi分类问题相关纯算法理论剖析,然后发现优化后就提升了1个点？ 是不是上线之后发现数据量一旦一大，你本地跑的脚本全部都报出：MemoryError? 是不是立项一周后产品经理过来问什么时候上线的时候，你连数据还没整理完？ 诸如这样坑爹的事情实在多的不能再多，相对而言，无论是是CNN还是RNN或者其他深度学习网络的input都是非常简单很清晰的，我这边给出一些简单的例子： 你在构造卷积神经网络的时候，只需拿出商品的基础属性，然后用不同性质的向量化方法embedding成不同的向量对象进行channel叠加就行了： 你在构造循环神经网络的时候，只需拿出用户商品的点击流，然后构造一个流通的点对点的循环网络即可： 卷积网络的原始数据只需要整理item与attribute对应关系，循环网络的原始数据只需要整理item与clickflow对应关系，相比复杂的传统方法的各种技巧，特征工程的提取整理的时间会大大减少，而且在线上数据处理过程中发生Memory Error的可能也无限变小。 实效性这个就比较好理解了，如果我们需要知道用户在app上每一刻的下单概率分布，如果用传统方法实现难度比较大，比如汇总前若干长时间内的信息再处理加工成模型需要的形式，再通过模型判断概率，可能就不是实时概率预估了。 而如果按照上述深度学习特征梳理方法，离线训练训练好用户的点击信息商品信息，再利用训练好的模型加用户在app上的实时行为，去预测用户在app上每一步操作对目标变量的影响,虽然我在离线训练的时间会付出的更多，但是我在线上预测会更加快捷。 具体效果我们以订单预估为例，深度学习预估方法下我们会很容易看到一个用户从开始一个session到结束一个session的过程中，购买欲望的分布： 在用户购买欲望特别高涨的时候，通过相应的push或者文案提醒，促进用户下单，提高成单率。 除此之外，我们还可以观察到每一刻全平台用户的购买欲望分布： 数据解析能力在围绕构造特征的时候，我们在对过去的数据整理的过程中，其实构造的最多的就是“过去N天”，“历史上”，“最后一次”，“第一次至今”，等等。其实，这些构造方法要么是汇总整合一段时间的信息，要么是单点的考虑某个时刻的信息量。但是，深度学习一定程度上会选择的汇总过去的信息的累积，根据实际对最终结果的影响，改变单次行为上的权重，避免单次行为对因变量的错误影响。比如RNN中的state，上面RNN中的文章我也介绍了，它的生成其实就是保留了前t-1次中的部分信息。 知乎上有这么一个问题RNN方法能够捕捉到 传统时间序列回归中的 trend ，seasonality么？,其实我也很好奇，在引入深度学习的fc层到machine learing做stack的时候，确实绝大部分都能提高auc，但是是不是因为这些深度学习方法能捕捉到传统的数据里面的类似trend这些难以统计描述的性质？ 案例说了这么多，我觉得还是以具体的例子来剖析比较有说服力，因为深度学习的模型相对比传统的模型代码要长很多很多，我这边只截取我认为比较重要的地方解释一下，想要看demo的去看我的GitHub吧。我给出的例子都是最简单的网络设计，如果实际要应用大家可以按照自己业务的需求增加网络的深度，改变网络的结构，这边只是给大家一个方向。此外，数据的处理也并没有因为深度学习模型的出现而变得不重要，Garbage In, Garbage Out!!! RNN方案的思路是来自于Domonkos Tikk和Alexandros Karatzoglou在《Session-based Recommendations with Recurrent Neural Networks》 它构造了embedding层来把原始的输入item映射为一个长度定义好的向量： 1embedding = tf.get_variable('embedding', [self.n_risks, self.rnn_size], initializer=initializer) 通过把user浏览或者点击过的item进行index编号X，然后根据编号去embedding层去找对应的vector，后续只要用用户接触到了该item就重复以上的embedding过程就行了。 1inputs = tf.nn.embedding_lookup(embedding, self.X) 再构造了简单的GRU层来学习每次用户的点击先后顺序之间的关系： 1234# 多层简单GRU层定义cell = rnn_cell.GRUCell(self.rnn_size, activation=self.hidden_act)drop_cell = rnn_cell.DropoutWrapper(cell, output_keep_prob=self.dropout_p_hidden)stacked_cell = rnn_cell.MultiRNNCell([drop_cell] * self.layers) 它的网络结构一点也不复杂： 首先，需要把数据集构造成中间的uid+item+time的格式： 然后通过用户自身点击item的顺序，以时间靠前的item项预测时间靠后的item项，训练完成后记录每条数据对应的out和state。 但是我实测了多层GRU和单层GRU，因为我们需要进行stacking的过程，不建议做多层的GRU，层数越多每层的信息量越稀薄，我通过sum，mean处理后仍不如单层： CNN的方案通常可以采取以下通用的网络形式： 所以可优化的点我均在网络结构中标注了，但是我一直没有找到CNN再传统学习中比较好的应用方式，如果拿最后一个FC层的向量stacking实测效果并不理想，相关代码我也放在了GitHub中了，大家可以作为一个尝试性的demo去看。 一样的item的向量化处理方式： 12cate_embed_matrix = tf.Variable(tf.random_uniform([cate_max, embed_dim], -1, 1),name="cate_embed_matrix")cate_embed_layer = tf.nn.embedding_lookup(cate_embed_matrix, cate, name="cate_embed_layer") 网络结构中主要是通过构造全连接层和卷积层： 123456789# 全连接cate_fc_layer = tf.layers.dense(cate_embed_layer, embed_dim, name="cate_fc_layer", activation=tf.nn.relu)# 卷积层filter_weights = tf.Variable(tf.truncated_normal([window_size, embed_dim, 1, filter_num], stddev=0.1),name="filter_weights")filter_bias = tf.Variable(tf.constant(0.1, shape=[filter_num]), name="filter_bias")conv_layer = tf.nn.conv2d(item_embed_layer_expand, filter_weights, [1, 1, 1, 1], padding="VALID",name="conv_layer")relu_layer = tf.nn.relu(tf.nn.bias_add(conv_layer, filter_bias), name="relu_layer")maxpool_layer = tf.nn.max_pool(relu_layer, [1, sentences_size - window_size + 1, 1, 1], [1, 1, 1, 1],padding="VALID", name="maxpool_layer") 然后再把所有全连接完和卷积完的vector拼接： 123456# 第一层全连接cate_fc_layer = tf.layers.dense(cate_embed_layer, embed_dim, name="cate_fc_layer",activation=tf.nn.relu)brand_fc_layer = tf.layers.dense(brand_embed_layer, embed_dim, name="brand_fc_layer",activation=tf.nn.relu)# 第二层全连接bc_combine_layer = tf.concat([cate_fc_layer, brand_fc_layer, dropout_layer], 2) bc_combine_layer = tf.contrib.layers.fully_connected(bc_combine_layer, 200, tf.tanh) 最后通过全连接输出结果： 12inference_layer = item_combine_layer_flatinference = tf.layers.dense(inference_layer, 2, kernel_initializer=tf.truncated_normal_initializer(stddev=0.01),kernel_regularizer=tf.nn.l2_loss, name="inference") 关于深度学习一些想法这篇文章终于要结束了，漫漫长文。图像、语音、自然语言处理这三个领域，深度学习的性能就是比传统方法好得多，无可辩驳。但是传统领域，比如点击率预估，风控概率预估，金融风险预估等等，我不赞成非得和深度学习扯上关系，我们应该想想： 我们有足够大量的数据支撑计算么？ 我们的业务需求允许我们进行大量黑盒计算么？ 带来的“提高”允许你所付出的成本么？ 使用者真的知道自己在做什么么？ 最后，我以血和泪的教训知道自己写的网络对模型的效果提升是非常非常小的，建议大家先熟知现有的成熟的网络： 谷歌的wide&amp;deep思想，论文及快速上手的demo。 Youtube的推荐，论文地址。 网易考虑的考拉，论文地址。 参考文献 [1] Foundation of Convolutional Neural Networks [2] YJango的循环神经网络 [3] Deep Learning for Natural Language Processing [4] Attention机制 [5] Wide &amp; Deep Learning for Recommender Systems [6] Deep Neural Networks for YouTube Recommendations [7] Personal Recommendation Using Deep Recurrent Neural Networks in NetEase [8] Session-based Recommendations with Recurrent Neural Networks]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>理论解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[提升有监督学习效果的实战解析]]></title>
    <url>%2F2018%2F01%2F20%2F%E6%8F%90%E5%8D%87%E6%9C%89%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%E6%95%88%E6%9E%9C%E7%9A%84%E5%AE%9E%E6%88%98%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言最近很长时间没有和大家分享东西了，最近一直在忙公司的项目，先说一声抱歉。 之前写过销售预估算法,但是被诸多大佬吐槽有监督学习部分毫无深度，其实我是想写给一些刚入门的朋友看的，这边我boss最近也想让我总结一些相对”上档次”的一点的东西，我做了一些稍微深入一点的总结，希望能够给新人朋友有稍微深入的方法介绍。 去年年末的那段时间里，看了很多天池大赛里面得高分的选手的算法思路，大概总结了有监督学习中的一些核心流程及重要细节： feature processing tricks 这个是老生常谈的问题，但是我还是看到了一些不错的点，比如根据high importance feature剔除高度缺失的cases这些等等 single feature + crossing feature 交叉特征组合原始特征，可以显著的提升auc，提高命中的准确程度，这边除了FM，我们也可以在常规的算法中去实现这个trick 有监督学习架构思路 下面，我们来看看针对每个点，具体是如何实现的，及我们需要注意哪些相关的东西： feature processing trickscase and feature selection我们在做模型训练之前通常会对模型的feature做一些删减，比如共线性检验，去除掉相似度过高的连续feature；比如变异度检验，去除掉一些数据变化差异过小的feature等等。然而，在常规的样本处理中，我们通常只会根据初始的数据分布去看，比如用户在feature上缺失大于来某个阈值才回去剔除这个用户；其实，在深入的思考一下这个问题，会发现，如果用户在高重要性的feature缺失程度高去剔除才更合理一些，这样想可能不是很清晰，这边看下面这个feature flow： 针对uid来看，如果普通的统计的话，uid3的null的个数5个，uid5的null的个数4个，我们应该优先剔除uid3，再考虑剔除uid5，因为null过多的用户所能提供的信息量会相对的少，会增大泛化误差。 但如果我们提前知道，对于判断label的能力，feature3&gt;feature5&gt;feature6&gt;feature8&gt;其他，那么uid5在高重要性的缺失情况极度严重于uid3，所以我们应该优先剔除uid5，相对于上面一种情况，我们预先知道feature的重要性排序就显得很重要了。关于如何判断提供了几种简单的方法： 方差膨胀系数：我们认为，在数据归一化之后，数据波动的更大的feature能够提供的信息量相对而言也是更大的，举个很明显的例子，如果feature1全都是1的话，它对我们判断用户是否下单这样结果毫无意义。 互信息：我一直认为，互信息是判断feature重要性的非常好的方法。方差膨胀系数只单纯了考虑feature本身的特征，而互信息在考虑feature的同时也考虑了label之间的关系，H(X,Y) = H(X) - H(X/Y)，这个信息量的公式很好的解释了这一点。 xgb’s importance：如果互信息是方差膨胀系数的进阶，那么xgb’s importance则是互信息的进阶，在考虑label与feature之间的关系的时候，同时还考虑了feature与feature之间的关系，这样得出来的重要性排序更加全面了一些。 除此之外： Logistic regression的params的参数 Recursive feature elimination（递归参数选择方法） Pearson Correlation Distance correlation Mean decrease impurity/Mean decrease accuracy … 诸如这样的方法很多，需要根据数据的形式，目标变量的形式，时间成本，效率等等综合考虑，这边只是给大家梳理一下常规的方法，至于实际使用的情况，需要大家累积项目经验。 null-feature treatment method在空值或者异常值的处理上，基本上分为2个派别，要么剔除这个feature或者case，要么填充这个feature或者case，它们的缺点也显而易见，随意剔除会减少判断的信息，如果数据较少的时候，会降低模型的效果；填充的话会造成困惑，到底是众数？平均数？中位数？最大值？最小值？现在很多人的处理方法都是观察数据的分布，如果偏态分布就考虑分位数填充，如果是正态分布就考虑均值或者众数填充，相对而言，这样处理的时间成本会更高，而且很多时候解释的说服力不是很强。 我在看了17年3月份JD的订单预估赛，17年的天池工业赛等等的高分答案中，不得不说，有一个分箱的方法确实能够提高0.5-1.5的auc，我之前思考过，可能存在的原因： 保存了原始的信息，没有以填充或者删除的方式改变真实的数据分布 让feature存在的形式更加合理，比如age这个字段，其实我们在乎的不是27或者28这样的差别，而是90后，80后这样的差别，如果不采取分箱的形式，一定程度上夸大了27与26之前的差异 在数据计算中，不仅仅加快了计算的速度而且消除了实际数据记录中的随机偏差，平滑了存储过程中可能出现的噪音 这边就直接给大家分享一下我的梳理：这边涉及到一个问题，连续数值特征是否一定要切为离散特征，建议综合考虑以下几个问题:a.所使用的算法是否为knn、svm这样的距离计算的算法b.是否在实际业务中依赖于离散判断c.连续数值特征的实际意义是否支持离散化。如果以上问题都没有问题的话，我建议优先考虑离散化连续特征，在一定程度上，离散完的feature有更好的解释意义。 single feature + crossing feature我们在之前的FM理论解析及应用中提到过特征交叉这个概念，当时的文章中紧接着通过矩阵的计算技巧： 构造了全部feature的C(n,2)的形式，后面追加了线性模型，这样一定程度上可以提高分类算法的准确度。这是一个非常好的将低维特征向高维转化的方式，所以在我们其他算法的过程中也可以借鉴这种思路，但是假设我们初始的feature量特别多，比如我在日常的CTR预估或者feature梳理的过程中，很容易就整理500以上的feature集合，如果仅考虑C(n,2)的形式的话，就有250499个feature的新增组合，这个是不可能接受的，所以回到我们上面一节feature processing tricks中提到的case and feature selection就是一个非常好的解决办法，我们可以先通过比如xgboost中的importance：我这边实际的画出了我做下单概率预测时初始筛选完成后的417个feature经过xgboost初步分类后的importance，可以很明显看前37，前53，前94个feature对应了三次importance的拐点，我们可以在这些拐点中选择一个既能够涵盖绝大多数的信息量，又不会造成后续交叉特征个数过多的值，比如我这边选择的是60，那么我接下来会生成的新的的交叉feature就是30`59个，比不做处理下的417*`208要小很多倍，而且相对而言不会减少很多的信息量。 整体的流程我这边也画出来了，希望能够给大家一个比较清晰的认识： 可以看到，样本cases在经过了最初的空值筛选及第一轮高重要性feature后的空值筛选后，就保持不变了，而特征feature的筛选过程则贯穿了整个交叉特征生成流。 bagging及stacking的思路架构我相信在读的各位，不论是机器学习从业者抑或是算法工程师甚至是其他研发工程师，一定看过类似如下的快速拖动的模块流： 它相当于把每个功能封装到一个固定的盒子中，当我们需要使用某个模块的时候，进行模块的操作，不需要的时候直接切断模块的流向即可，我们甚至可以空值每个模块的var及bias的偏向程度，在bagging和stacking的思路框架中，我非常常用的就是类似这样的思想：确定好我要进行的组合模块的组合方式（stacking还是bagging还是blending），再确定这次为想要做的子模块是什么，在根据组合形式及子模块细微调节每个子模块。 首先，子模块可以有哪些？ svm分类/回归 logistic分类/回归 神经网络分类/回归 xgboost分类/回归 gbdt分类/回归 xgboost叶子节点index gbdt叶子节点index randomforest分类/回归 elastic net 除了这些，还有么？当然，如果你愿意的话，每一个你自己构造出来的分类或者回归的single model都可以成为你bagging或者stacking或者blending之前的子模块。 如何训练子模块？这边的方法可谓是多种多样，百花齐放，很大程度上来讲，你在天池也好，kaggle也好，你能前十还是前十开外决定因素是你的feature处理的好坏，但是你能拿第一还是第十很大程度上就是依赖你的子模块构造及子模块组合上。这边给大家分享我最近看到的比较有意思的三个子模块形式： 1.wepon的Large-Scale SVM 读过我之前写的SVM理论解析及python实现这篇文章的朋友应该还记得，我当时说过svm在10.7%的数据集中取得第一，算是传统的机器学习方法中非常值得一学的算法，但是实际应用中，在处理大规模数据问题时存在训练时间过长和内存空间需求过大的问题比较让人头疼，wepon同学采取的方法如下： 这种方法看似增加了计算复杂度，实际上是却是减小的，假设原始训练数据大小是n，则在原始数据上训练的复杂度是o(n^2)，将数据集n分成p份，则每份数据量是(n/p)，每一份训练一个子svm，复杂度是o((n/p)^2)，全加起来o(n^2/p)，复杂度比在原始数据上训练减小了p倍。变向的解决了在量大的数据集合上使用svm，提高速度同时保证质量这个问题。论文支持建议参考Ensemble SVM。 2.爱奇艺 Gbdts’ Node Leafs 我们分别来解释一下左右的Dense features 和 Spare Features。 首先，左侧这块很好理解，在上一次的文章中,我们已经讲了如何利用xgboost或者gbdt获得用户的数据落在的每棵树上面的叶子节点的index值：如果有不清楚的同学，请回顾一下上次讲的内容。 右侧这块分别写了user preference 和video content，当然这是因为它是视频公司的原因，在我实际的使用中，我用的是user preference 和 item content，这里的preference和content其实就是你个人信息及行为的向量化的形式。 最简单的表示就是把你的基本信息和item信息先onehotencoding，再首尾相接成一个超长的vector，这就是一个稀疏的Spare Features。 当然除了这种粗暴的办法，还有比如我们在若干天之前讲过的深度学习下的电商商品推荐中的word2vec的技巧，先将所有的用户随机生成为我们需要的长度N维下一一对应的向量，在通过huffman编码的形式找到每个item对应的Huffman树子的唯一路径，再通过在每个节点上生成一个logsitic分类的办法，使得所有该路径成立的概率最高，以此来修正我们最初随便生成的N维向量，最后这个N维向量就可以看作是一个Spare Features。 还有么？当然，我私下问了我之前在该公司任职的同学，他们还有一种思路就是划分数据集到M个子集，每个子集上面生成一个xgboost，然后每个子集取xgboost的叶子节点，相当于把左侧的Dense features复制了M份Dense features放在了右边的Spare Features，最后会得到一个M+1个Dense features。实际使用起来的效果完全不比word2vec的结果差。 3.基于GRU的潜藏层 Domonkos Tikk和Alexandros Karatzoglou在《Session-based Recommendations with Recurrent Neural Networks》文章中提到了可以用循环神经网络RNN来预估用户的行为，如下图： 我们可以清晰的看到，针对每个用户Session1，他的行为由i1.1变化至i1.4其实是一个有序的过程，我们可以设计一个从i1.1——&gt;i1.2,i1.2——&gt;i1.3,i1.3——&gt;i1.4这样的一个循环流程。同时在他的文章中还解释了这样的设计解决的两个问题： the length of sessions can be very different breaking down into fragments 一来通过了首尾相接，解决不同用户的session不同长度；二来通过了embedding layer，解决了不完整session下预测的可能。具体网络设计如下： 模型的更新流可以参考下面： 我们只需要拿到每个用户的item流下所对应的state即可，这state就包含了这个用前M次的操作潜藏信息，同时我们还可以随意定义这个信息向量的长度，这个就可以看作用户状态向量，作为子模块的输出。 这个思路的缺点就是，要预测的基础数据不存在时序性，效果极差。比如滴滴打车的下单过程，从登陆到打到车的时间最短在20s，最长在1分钟，否则用户就退出了app，这样的情况下，时序性质就显得格外薄弱，强行用这样的RNN获得的用户属性非常不存在代表性。 如何组合子模块？bagging 这个是我们Kaggle&amp;TianChi分类问题相关纯算法理论剖析就强调过的bagging的最简单的形式，在每个子模块的设计选择过程中要尽可能的保证： low biase high var 也就是说子模块可以适当的过拟合，增加子模型拟合准确程度，通过加权平均的时候可以降低泛化误差 stacking 这个是我们Kaggle&amp;TianChi分类问题相关纯算法理论剖析就强调过的stacking的最简单的形式，在每个子模块1、子模块2的设计选择过程中要尽可能的保证： high biase low var 在子模块3的时候，要保证： low biase high var 也就是说，在子模块1，2的选择中，我们需要保证可稍欠拟合，在子模块3的拟合上再保证拟合的准确度及强度 blending我们知道单个组合子模块的结果不够理想，如果想得到更好的结果，需要把很多单个子模块的结果融合在一起：这种方法也可以提高我们最后的预测的效果。 关于有监督学习的方法大概就梳理到这边，最后希望能够给一些新人同学对有监督的理解和实战有一些帮助。 没啥广告要打，就这样吧。 Reference:[1] 周志华。《机器学习》，清华大学出版社，3.7，2016[2] wepon。 《PPD_RiskControlCompetition》[3] 爱奇艺技术产品团队。 《爱奇艺个性化推荐排序实践》[4] slade。 《Kaggle&amp;TianChi分类问题相关纯算法理论剖析》[5] E Cernadas，D Amorim。 《Do we need hundreds of classifiers to solve real world classification problems?》[6] slade。 《深度学习下的电商商品推荐》[7] Domonkos Tikk，Alexandros Karatzoglo。 《Session-based Recommendations with Recurrent Neural Networks》[8] slade. 《FM理论解析及应用》]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>模型设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kaggle&TianChi分类问题相关算法快速实现]]></title>
    <url>%2F2017%2F12%2F28%2FKaggle-TianChi%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9B%B8%E5%85%B3%E7%AE%97%E6%B3%95%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[17/12/30-update ：很多朋友私密我想要代码，甚至利用金钱诱惑我，好吧，我沦陷了。因为原始代码涉及到公司的特征工程及一些利益trick，所以我构造了一个数据集后复现了部分算法流程，需要看详细代码实现朋友可以移步Ensemble_Github 更多代码内容欢迎follow我的个人Github，如果有任何算法、代码疑问都欢迎通过stw386@sina.com联系我。 导读无论是在TianChi，还是在Kaggle上，通常会出现类似0-1分类，多分类这样的问题，比如： Kaggle Competition Past SolutionsO2O优惠券使用预测移动推荐算法 除此之外，在金融、风控、交通领域，也会有比较相近的分类问题：Kesci“魔镜杯”风控算法大赛DataCastle微额借款用户人品预测 如果仔细阅读就会发现，很多很多case，但是总结下来都是一个套路： Bagging Boosting Stacking Ensemble 我想写这篇文章的目的就是让大家在比如竞赛、项目push的情况下，在较短时间内，快速的构造出一个效果中上的算法集合。 理论解析BaggingBagging通过构造一个预测函数系列，然后以一定的方式将它们组合成一个预测函数。更加形象的理解就是，我们考试，大家都有各种擅长的科目，都有自己弱势的科目，我们每个人都尽力把我们擅长的科目考好，然后最后把各自答案互相借鉴，这样每一科都能有不错的结果。如果以图形理解就是： BoostingBoosting通过改变训练样本的权重（增加分错样本的权重，减小分对样本的权重），学习多个分类器，并将这些分类器线性组合，提高分类器性能。更加形象的理解就是，我们考试，每次我们数学都考的不好，然后我们在平时学习的时候投入更多精力去学数学，然后再看什么考的不好，再去投入精力学什么。 StackingStacking通过用初始训练数据学习出若干个基学习器后，将这几个学习器的预测结果作为新的训练集，来学习一个新的学习器。更加形象的理解就是，我们考试，先让学霸去考，然后把每个学霸的答案按照他们历史上这科目考的成绩加权打分，最后确定每个学霸的各科目成绩加权的变化，重复再让学霸去考试修正这个各科目成绩加权。注意：其实，Stacking和Boosting的思想是很近的，其中很大的差异在于Stacking一般用的都是完善的模型中间件结果当作入参，生成了新的数据分布，算法设计核心应该考虑的Bias-Vars-Balance；而Boosting用的简单的模型结果当做权重分布优化原始入参，并没有生成新数据，算法核心的目的还是在考虑降低Bias。所以，在多数情况下，Stacking的模型应该更稳定，有更好的泛化性能。 EnsembleEnsemble通过对新的数据实例进行分类的时候，通过训练好多个分类器，把这些分类器的的分类结果进行某种组合（比如投票）决定分类结果。更加形象的理解就是，先让学霸去考试，尽可能的让每个学霸都考好，然后根据历史考的分数高低投票出每个科目对应的考的最好的那个学霸，决定每科抄对应的那个学霸。注意：对的，正如你们所想，Ensemble的思想就和Bagging的思想近似。Bagging的关键集中在，我不管我每个弱鸡的分类器的效果，只要我数量足够多，一定能得到不错的组合效果，相对而言简单，效果稍弱；而我们在Ensemble的时候，设计更加复杂而且要注意：a.尽可能让每个子分类器能识别出不同分布的数据，如果针对同一份数据做再多的子分类器，也只是只能起到堆砌的作用。b.加权方式的不同：简单平均（Simple Average），加权平均（Weight Average），概率投票（Soft vote）等等。 说了这么多，我们其实有个前提，就是加权或者组合或者堆砌能够提升准确度，不然等于以上都不合理，下面简单证明下： 假设，我们有5个分类器的正例率分别是{0.7,0.7,0.7,0.9,0.9}：a.如果直接判断的话，最好的一个子分类器的准确率也只能达到0.9b.采用简单投票方法（必须有三个以上分类正确），那么根据二项分布：3个分类器正确：0.73*0.1*0.1+3*0.72*2*0.9*0.1+3*0.7*0.32*0.9*0.94个分类器正确：0.73*0.9*0.1*2+3*0.72*0.3*0.925个分类器正确：0.73*0.92把这几个相加可得p≈0.933&gt;0.9。 这些都是是非常基础的，也不是本文的重点，如果有任何疑问，请自行百度了解或者邮件我。 Bagging的代表作有randomforest，Boosting的代表作有Adaboost及GBDT，Stacking和Ensemble就需要我们自己设计了。 如何设计一个Stacking|Ensemble的模型？先看一个Stacking的经典之作：FaceBook基于gbdt+lr下stacking的CTR预估。不得不说，虽然实测下来对Valid的准确率提升只有2-3pp，但是在泛化性能上稳定程度上升了若干个档次，后面我们细讲。Ensemble就更不用举例子了，随便打开一个互联网公司的算法库，99.9%的都已经有完善的成功案例了。我呆过的滴滴、电信、hp等等，还没有一个公司不用的。 讲理论之前，先看一个概念：Bias–variance tradeoff。我知道每多一个公式，会少一半的读者，我尽可能的用叙述的方式才阐述。首先，Error = Bias + Variance，这个公式请刻在脑子里。如果记不住，上面这个公式有个对应的图： 我们来解释Error = Bias + Variance，公式中的Error就是我们需要考虑的我们设计模型中的Loss；Bias就是我们预测数据距离真实数据的距离程度，比如你今年25，我预测你23，BIas=2；Variance就是我预测的结果的波动程度，比如，我预测三个人的年龄A、B组分别为（23，22，24）及（10，20，80），很明显B组波动程度要狠狠大于A。我们形象的来看，如果Error = Bias + Variance中Bias过大是什么样？结果就是红色线条，预测的结果几乎没有任何参考意义，偏离正常值非常远。 如果Error = Bias + Variance中Variance过大是什么样？结果就是红色线条，预测的结果几乎完全拟合了所有数据，预测的结果波动非常不稳定。 所以，我们在设计Stacking和Ensemble的过程需要避免上述的两个问题，最简单的举个例子：如果，我们在做Stacking模型，Model_1我们用的Adaboost的算法，我们improve了正例的权重，纠正了正负样本比，训练出了叶子结点。接下来，我们是选择做XGBOOST的时候，参数设置如下：123456789estimator=XGBClassifier(learning_rate=0.1,n_estimators=500,max_depth=3,min_child_weight=7,objective=&apos;binary:logistic&apos;,scale_pos_weight=0.707653,gamma=0.6,seed=27) 参数中scale_pos_weight是否应该更改为1？答案是yes的，这边建议大家自己思考一下。如果再做一次scale_pos_weight = negative /positive ，是不是相当于我们2次提高了正样本的权重？对正样本的拟合过度是的bias下降，Variance上升，Vaild的泛化能力就会非常的弱，极其不稳定。 除此之外，如果我们用了random forest的作为Model_1，后接一个Xgboost中的subsample还有必要设置为0.4或者0.5么？这边考虑到randomforest已经控制每棵树，随机采样的比例，也控制了每个feature，每个样本的被随机选取的前提，在后面追加模型stacking的过程就需要更注重拟合，此时就算接一个nernual network 都是可以的，所以后面可以但是不建议再追加注重Bagging的算法。 其实，核心在于不论我们如何组合一个stacking或者ensemble模型，需要时时刻刻考虑的是平衡bias和variable。上面这些描述很抽象，我自己返回的阅读也觉得不是解释的很清晰，但是建议各位自己好好想一下，如何搭建一个stacking和ensemble不需要考虑上面这些，但是要如何搭建好一个stacking和ensemble模型，最核心的就是上面这些。 案例复现先看结果，我借着公司case，训练了常规的方法其中stacking中基于tensorflow下的deepFM和FNN当时没有记录，就没有留下，其他的都如下：整体上，我写了包括sample、ensemble、stacking、deepFM、TF-FNN前后一共花了3天的时间，所以真的可以说是高效快速的方法而且可复制性极高。效果上，基本上比简单的处理完直接random forest，accuracy要高10-15pp，如果愿意深挖，效果应该还可以提升。 这边就着重和大家捋一遍Facebook15年出品的xgboost+sparse+lr这个思路吧，这边只贴了核心的代码段，后面看大家需求再考虑是不是GitHub共享吧，如果想要知道其他的模型或者其他什么想法，可以邮件我～ 数据预处理 修复一些DBA没有处理好的数据，这样需要在做数据处理之前纵览整体数据质量。12345678make_new_data = []for i in range(train_data[&apos;crm__crm_user_wechat_info__we_chat&apos;].shape[0]): if train_data[&apos;crm__crm_user_wechat_info__we_chat&apos;][i].replace(&apos;\&quot;&apos;, &apos;&apos;).replace(&quot;[&quot;, &apos;&apos;).replace(&apos;]&apos;, &apos;&apos;) == str( 0): make_new_data.append(0) else: make_new_data.append(1)train_data[&apos;crm__crm_user_wechat_info__we_chat&apos;] = make_new_data 离散化连续特征，这边也可以保留一些连续变量，我这边两种都尝试了，离散化的效果是要优于保留连续变量的。1234567# separate the classification data : define that if the set is under 10,the columns can be treated as classificationclass_set = []continue_set = []for key in arrange_data_col: if arrange_data_col[key] &gt;= 10 and key != 'uid': continue_set.append(key) class_set = [x for x in train_data.columns if x not in continue_set and x != 'uid' and x != 'label' and arrange_data_col[x] &gt; 1] 删除低方差的feature，我这边用的是我之前写的一个包，理论：特征工程代码模版，包地址：data_preprocessing，这个是我自己写的，也不难，大家嫌麻烦也可以自己写。1234567# remove the low variance columnsmeaningful_col = [&apos;uid&apos;, &apos;label&apos;]for i in cbind_classed_data_columns: if i != &apos;uid&apos; and i != &apos;label&apos;: if arrange_data_col[i] &gt;= 2: meaningful_col.append(i) meaningful_data = cbind_classed_data[meaningful_col] 同理，计算了互信量，删除低贡献的feature，也是上面包data_preprocessing.feature_filter()里面有的。12ff = data_preprocessing.feature_filter()res = ff.mic_entroy(reshaped_data.iloc[:, 1:], &apos;label&apos;) 然后，我自己定义了评价函数，根据importance删选了feature，特征由最开始的243个减少到最后的64个。1234567891011121314151617181920212223242526272829def metrics_spec(actual_data, predict_data, cutoff=0.5): actual_data = np.array(actual_data) predict_data = np.array(predict_data) bind_data = np.c_[actual_data, predict_data] res1 = 1.0 * (bind_data[bind_data[:, 0] == 1][:, 1] &gt;= cutoff).sum() / bind_data[bind_data[:, 0] == 1].shape[0] res2 = 1.0 * ( (bind_data[bind_data[:, 0] == 1][:, 1] &gt;= cutoff).sum() + ( bind_data[bind_data[:, 0] == 0][:, 1] &lt; cutoff).sum()) / \ bind_data.shape[0]return res1, res2# define the initial paramclf = XGBClassifier(learning_rate=0.01,n_estimators=500,objective='binary:logistic',)# best cutoff : 223 , more details follow the train_doc_guidefilter_columns = ['uid', 'label'] + [x[0] for x in res[-223:]]reshaped_data = reshaped_data[filter_columns]X_train = reshaped_data.iloc[:, 2:]y_train = reshaped_data.iloc[:, 1]model_sklearn = clf.fit(X_train, y_train)# calculate the importance ,best cutoff : 0.0022857142612338 , more details follow the train_doc_guideimportance = np.c_[X_train.columns, model_sklearn.feature_importances_]train_columns = [x[0] for x in importance if x[1] &gt; 0.0022857142612338] 这样，数据预处理就完成了，接下来就是模型设计部分了，但是上面的过程很重要，请务必重视！ xgboost叶子结点获取核心在于参数调优，没什么特别多的技术壁垒：1234567891011121314151617181920212223242526272829303132333435363738# update the values in the model# scale_weight_suggestion = (Y_train.count() - Y_train.sum()) / Y_train.sum()param_test = &#123;'n_estimators': [100, 250, 500, 750]&#125;gsearch = GridSearchCV(estimator=XGBClassifier(learning_rate=0.1,objective='binary:logistic',scale_pos_weight=0.707653,seed=27),param_grid=param_test,scoring='roc_auc',n_jobs=4,iid=False,cv=5)gsearch.fit(X_train, Y_train)print(gsearch.best_params_)# &#123;'n_estimators': 500&#125;# define the final paramclf = XGBClassifier(learning_rate=0.01,n_estimators=500,max_depth=3,min_child_weight=7,objective='binary:logistic',scale_pos_weight=0.707653,gamma=0.6,reg_alpha=1,seed=27)# train the valuesmodel_sklearn = clf.fit(X_train, Y_train)y_bst = model_sklearn.predict_proba(X_test)[:, 1]metrics_spec(Y_train, model_sklearn.predict_proba(X_train)[:, 1])metrics_spec(Y_test, y_bst) 为了避免冗长，我删除了调参数细节，留了一个case做guide，下面就是拿出xgboost的叶子结点，并enhotencoding的过程。123456789101112# 叶子结点获取train_new_feature = clf.apply(X_train)test_new_feature = clf.apply(X_test)# enhotcodingenc = OneHotEncoder()enc.fit(train_new_feature)train_new_feature2 = np.array(enc.transform(train_new_feature).toarray())test_new_feature2 = np.array(enc.transform(test_new_feature).toarray())res_data = pd.DataFrame(np.c_[Y_train, train_new_feature2])res_data.columns = ['f' + str(x) for x in range(res_data.shape[1])]res_test = pd.DataFrame(np.c_[Y_test, test_new_feature2])res_test.columns = ['f' + str(x) for x in range(res_test.shape[1])] 到此为止，将叶子结点获取过程就结束了，这边细心的人会发现，这个是一个非常稀疏的矩阵，我这边追加的是常规的LR，但是如果就单纯从数据特征的角度来讲，神经网络和FFM对这类数据类型有更好的表现，如果需要写FM收尾的同学，可以参考我写的这个FM包，理论：FM理论解析及应用，代码在：FM快速实现Github。 logistics模块python实现1234567lr = LogisticRegression(C=1, penalty='l2', max_iter=1000, solver='sag', multi_class='ovr')model_lr = lr.fit(res_data.iloc[:,1:], res_data['f0'])y_train_lr = model_lr.predict_proba(res_data.iloc[:,1:])[:, 1]y_test_lr = model_lr.predict_proba(res_test.iloc[:,1:])[:, 1]res = metrics_spec(Y_test, y_test_lr)correct_rank = X_train.columns# (0.80, 0.71) 简单易上手，实现了下图的流： 顺带附上ks值计算逻辑：12345678910# 算法评估# ks_xgb_lr = np.c_[Y_test,y_test_lr]# ks_xgb_lr = sorted(ks_xgb_lr , key = lambda x : x[1],reverse = True)# ks_xgb_lr = pd.DataFrame(ks_xgb_lr)# for i in range(9):# end = (i+1)*break_cut# res1 = 1.0*ks_xgb_lr.iloc[:end,:][ks_xgb_lr.iloc[:end,0]==0].shape[0]/ks_xgb_lr[ks_xgb_lr.iloc[:,0]==0].shape[0]# res2 = 1.0*ks_xgb_lr.iloc[:end,:][ks_xgb_lr.iloc[:end,0]==1].shape[0]/ks_xgb_lr[ks_xgb_lr.iloc[:,0]==1].shape[0]# res = res2-res1# print(res1,res2,res) 只要重复上述的案例浮现中的code流程，可以快速复刻出一份效果还不错的分类算法，但是如果想能够拿到很好的名次或者有更优秀的表现，等待下一篇文章中的原理剖析。 最后，给大家分享一下之前和Kaggle大神在算法竞赛或者解决项目问题的时候总结出来需要尤其注意的点： 请务必重视数据集构造，你能不能上榜或者得到leader的重视，这一点最关键，没有之一 如果条件允许，尽可能的离散化数据尝试一下，多做两次特征筛选这些预处理的步骤，收益是非常大的 请善于使用gridsearch，最后能进前十还是前三很大程度上相差的就是那零点几 在集群或者资源充足的情况下，利用交叉检验代替Valid test，管中窥豹的结果会让自己更加固步自封，离真相越走越远 乐于分享，表达出自己的观点，反过来在驳斥自己的观点，直到可以完全说服自己 没啥广告要打，就这样吧。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>模型设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kaggle&TianChi分类问题相关纯算法理论剖析]]></title>
    <url>%2F2017%2F12%2F28%2FKaggle%26TianChi%E5%88%86%E7%B1%BB%E9%97%AE%E9%A2%98%E7%9B%B8%E5%85%B3%E7%BA%AF%E7%AE%97%E6%B3%95%E7%90%86%E8%AE%BA%E5%89%96%E6%9E%90%2F</url>
    <content type="text"><![CDATA[17/12/30-update ：很多朋友私密我想要代码，甚至利用金钱诱惑我，好吧，我沦陷了。因为原始代码涉及到公司的特征工程及一些利益trick，所以我构造了一个数据集后复现了部分算法流程，需要看详细代码实现朋友可以移步Ensemble_Github 更多代码内容欢迎follow我的个人Github，如果有任何算法、代码疑问都欢迎通过stw386@sina.com联系我，知无不答。 导读在上一次的文章中，我们讲了，如何快速的利用bagging、boosting、stacking、ensemble的形式实现一个分类算法，当时我们直接看了代码以及核心的理论注意点。如果需要有更加优异的结果表现，对整套算法的设计及相关的理论了解是必不可少的。本文将从数学、工程、领域经验的角度去剖析如何用好bagging、boosting、stacking、ensemble去训练一个相对完善的模型。 再次提醒，本文中的数据公式较多，抽象概念较多，需要一定的高等代数、泛函分析、机器学习基础作为前置条件。如果你只需要知道如何运行或者完成分类识别，请参考Kaggle-TianChi分类问题相关算法快速实现。如果需要更详尽的理论解析或者有哪些地方不明白的同学，建议私下联系我stw386@sina.com。如果你想skip read本文，请直接阅读最后一个小节：调参流程梳理。 那么接下来让我们开始正文，虽然本文写的很冗长，我依旧建议阅读完此文，即便是处于懵懂的状态，对后续模型调整的理解也是有一定益处的，而且我会尽可能的用通俗易懂的语言来讲，很多地方会存在解释不严谨的地方但是更易于理解。 Bias-Variance-Tradeof在上次的文章中，我们就提到了一个好的模型应该有着非常好的拟合能力，就是说我的偏差要尽可能的小；同时，也要保证方差尽可能的小，这样我们才能在泛化能力上有很不错的表现。 设样本容量为n的训练集为随机变量的集合(X1, X2, …, Xn)，那么模型是以这些随机变量为输入的随机变量函数（这边的F虽然上函数，但是也是随机变化的）：F(X1, X2, …, Xn)。抽样的随机性带来了模型的随机性。那如何定义一个模型的Bias和Variance呢？这边我们采取的是基模型的加权均值E(F)=E(∑(γ*fi))移动来替代bias、基模型的加权方差Var(F)=Var(∑(γ*fi))替代Variance，更详细的数学定义如下：这边在Variance推导过程中用到了这个性质：Cov(X*Y) = E(X*Y) - E(X)*E(Y)，同时将方差拆分成协方差的形式。我们可以看到，组合后的模型的Bias和基模型的Bias的权重γ相关，组合后的模型的Var和基模型的权重γ、基模型个数m、基模型相关性ρ相关。请务必深刻的记得上述bias和var的数学式子，在后续无论是调参数还是模型设计，我们都是围绕着，降低bias和var的角度去做的。 Bagging Bias and Variance很多同学在没看这篇文章之前就知道，bagging算法和stacking算法是需要基模型保持强基模型（偏差低方差高）的，但是不知道大家有没有想过为什么？阿里15年校招的时候，我有幸回答过一个题目就是这个问题，下面让我们看看为什么是这样的？ 对于bagging算法而言，每次的抽样都是以尽可能使得基模型相互独立为前提的，为了维持这样的假设，我们做了三件事： 样本抽样：整体模型F(X1, X2, …, Xn)中各输入随机变量（X1, X2, …, Xn）对样本的抽样 子抽样：整体模型F(X1, X2, …, Xn)中随机抽取若干输入随机变量成为基模型的输入随机变量 弱抽样：整体模型F(X1, X2, …, Xn)中各输入随机变量（X1, X2, …, Xn）下的feature的抽样 同时，由此我们由此也可以得到bias和var公式中的γ=1/m，基模型的权重一定程度是可以看作是相等的，所以原来的E和Var公式就变成：组合模型F的bias和基模型fi的bias一致，这就是我们为什么要求基模型fi的bias要低的原因，因为组合模型F的拟合能力E(F)不随着基模型个数的增加而上升。 组合模型F的var与基模型fi的var、基模型fi的个数m、基模型的相关性ρ相关，很明显可以看出，随着基模型的个数上升Var(F)第二项是在下降的，所以基模型的个数上升会降低组合模型的方差，这就是为什么基模型的方差可以高一些。 除此之外，我们还可以看出，如果基模型相关性ρ越低，整体的方差是越小的，所以我们才去做样本抽样，子抽样，弱抽样等等行为。还有，基模型的个数上升一定程度上会降低组合模型F的方差，但是不是无限递减的，公式中它只能降低第二项的方差值，第一项的方差值不随基模型的个数而增减。 从这个角度看，是不是对Bagging算法的理解又深刻了一些？接下来让我们看看Boosting。 Boosting Bias and Variance依旧的是很多同学在没看这篇文章之前就知道，boosting算法是需要基模型保持弱基模型（偏差高方差低）的，让我们一探究竟。熟悉boosting算法的同学都知道，boosting算法的基模型的相关性几乎≈1的，后续模型强依赖于前模型，所以我们可以认为ρ=1，得到如上的简化式子。组合模型F的bias是基模型的bias的累加，基模型的准确度都不是很高（因为其在训练集上的准确度不高），随着基模型数的增多，整体模型的期望值增加，更接近真实值。而站在方差的角度，组合模型F的方差是随着基模型的fi个数上升而平方上升的，这就要求我们的基模型的方差不能太高，否则组合模型的F就会增长爆炸。这就是为什么我们在boosting模型设计的时候，需要基模型保持弱模型（偏差高方差低）的原因。 多说一句，大家也看到了，boosting的Var(F)是依赖于基模型的权重γ的，所以在后续的gbdt、xgboost，各位数据科学家选择了类似bagging的采样模式，降低模型的γ，控制方差，所以说，了解原理再去重新或者优化还是很重要的。 Bagging、Boosting、Stacking Bias&amp;Variance总结纵观刚才说了的这么多，我们在Bagging、Boosting、Stacking的模型设计中所围绕的就是降低bias的同时，降低Variance。而我们所做的sklearn里面的参数调整就可以说用来： a.构建基模型，变化基模型的Bias和Variance b.组合模型构建，控制基模型后，如何把这个基模型很好的组合成一个优秀的ensemble模型。 GBDT 理论剖析模型过程推导其实random forest和gbdt、xgboost都是非常好的Bagging、Boosting、Stacking算法的优化升级版本，我个人用的gbdt稍多，所以就以gbdt为例子给大家梳理一遍，从理论，到调参数，到trick分享。 我最讨厌很多博主贴个上面的伪代码就跑了，我念书的时候，老师讲题目也是，我靠，我要是看得懂还需要你贴？所以，我们选择一步一步的来看这个伪代码。 让我们先概览一下整个流程，gbdt有递归设计如下： 如果y(i)代表着第i个基模型，第i+1个基模型其实是基于第i个基模型的结果而追加了一个New function去修正前i个基模型的误差。如果以F代替y，h代替f的话，我们可以得到下面这个递归函数： 第i个基模型是由前i-1个基模型中的h(x)累计得到的，我们最后想要得到的分类器即为： 每一轮迭代中，只要集中精力使得Fi(x)每次loss下降的最快即可：每次构建一个残差负梯度作为更新方向的New function(即hi(x))，就可以解决这个复杂的递归问题，从而得到F(x)的解析式。 接下来，我们再看看更加详细的做法： 初始化部分，在这次梳理之前，我也一直认为是随机构造的，这边看完伪代码我才知道，在初始值设置的时候，考虑了直接使得损失函数极小化的常数值，它是只有一个根节点的树，即是一个c常数值。 构建回归树，这边就稍许复杂，让我们拆开一步一步来看： 首先，先求整体损失函数的反向梯度。先举个mse的例子，如果现在我们考虑的是mse(着重注意，只有mse的情况下以下的梯度才是这样的)的形式，我们要做的就是在每一步的时候让我们的预测值Fi(x)与真实值y的损失函数：1/2*(y-Fi(x))^2最小(前面的1/2是为了方便求导计算加上去的)，如果对梯度下降有了解的朋友就知道，此刻要求它的最小就是去求偏导： 按照这个方向去更新Fi(x)，可以保证，组合模型F(x)的每次都是按照最优的方向去优化。 MSE的损失函数确实是残差形式，不代表所有的损失函数下更新的方向都满足这样的残差形式。kaggle master 在blog里面提到Although we can minimize this function directly, gradient descent will let us minimize more complicated loss functions that we can’t minimize directly，我们就需要设计出一种更快速能提升泛化能力且不失一般性的解决方案，所以有大神提出了以梯度下降的值直接代替因变量y，也就是我每次预测不去比预测值与真实值y的差异，我们比较的是预测的梯度方向与真实的梯度方向。 再基于已经预估出来的负梯度去计算最优的更新步长，使得预测值与真实值更加靠近，因为每层的负梯度的方向不固定，所以每层i的步长都是变化的。 最后通过缩减率v（这边就是类似logistics里面的∂）控制速率。 综上，假设test集合第i轮预测中，根据训练集训练出来的负梯度拟合模型不妨记为fi(x)、最优步长γi、缩减率v，可得到最终的递归公式为： 损失函数介绍刚才上面我举了一个mse作为损失函数的例子，其实还有很多其他的，参考如下： 这边说个有意思的东西，就是如果有兴趣的朋友可以把exponential：指数损失函数计算一下，反向梯度为： 则有第i轮损失函数： 这货就是adaboost的第i轮损失函数的非归一化的结果，是不是很有趣，虽然知道了没啥用，但是起码得到了我们在用gbdt的时候，loss=’exponential’即为adaboost的结论啊，哈哈～所以说，我觉得去推推公式，还是很有意思的。 到此为止，gbdt是怎么构造得来的就讲完了，其实这个和bias&amp;variance关系不大，但是为了铺垫后续的GBDT实战剖析，我觉得还是非常有必要梳理一遍的，但就比起Bias-Variance-Tradeof这节的内容，我觉得各位还是着重理解Bias-Variance-Tradeof，这节可以看作是’甜品’缓解下气氛。 GBDT 实战剖析我们以python下的sklearn.ensemble中的GradientBoosting及RandomForest为例子，实战分析一下，如何能够理性的调好参数而并非玄学的gridsearch。 在Bias-Variance-Tradeof我们提到了参数设置分为两块：a.构建基模型,b.构建组合模型，我们分GradientBoosting参数如下： 构建组合模型：1) n_estimators:基模型的个数，对于gbdt来说，因为我们需要通过基模型的个数来提升准确率所以n_estimators一般都会大于random forest的n_estimators的个数，实际上RandomForestClassifier默认为10，GradientBoostingClassifier默认为100也证明了这点。 2）learning_rate：步长，对于gbdt来说，步长依赖于n_estimators，100=2*50=5*20，就是这个道理。而random forest里面不存在步长这个概念。在gbdt里面，关于步长的优化一般是伴随着基模型的变化而变化的。 3）subsample：子采样率，还记得我们上面对子采样的描述么？一般来说，降低“子采样率”（subsample），也会造成子模型间的关联度降低，整体模型的方差减小，但是当子采样率低到一定程度时，子模型的偏差增大，将引起整体模型的准确度降低。 4) init：初始化，更多见GBDT 理论剖析中，我们对初始化的描述。 5）loss：对于分类模型，有对数似然损失函数”deviance”和指数损失函数”exponential”两者输入选择。默认是对数似然损失函数”deviance”。对于回归模型，有均方差”ls”, 绝对损失”lad”, Huber损失”huber”和分位数损失“quantile”。默认是均方差”ls”。分类模型不说了，刚才在GBDT 理论剖析中讲了，一般用”deviance”比较多；回归模型中，”ls”我们也在GBDT 理论剖析中讲了，异常点多的情况下”huber”,训练集分段预测的话用”quantile”，但是我个人建议异常点或者分段预测还是在数据已处理中完成。 6) alpha：这个参数只有Huber损失”huber”和分位数损失”quantile”下的GradientBoostingRegressor，alpha越小对噪声处理的力度越强，alpha越小分位数的值越小。 构建基模型：1）max_features：每次划分最大特征数，有log2，sqrt，None等等，默认的是sqrt，该值越小，我们每次能获得信息越少，造成偏差时变大的，同时方差是变小的，所以当我们模型拟合能力不足的时候，可以考虑提升该值。 2）max_depth:基模型最大深度，深度越大，模型的拟合能力越强，bias越小。根据Bias-Variance-Tradeof我们对bagging和boosting里面的Var和Bias的描述可知，如果在boost（gbdt）采用了过深的基模型，组合模型的var会很大，在泛化能力会降低，造成训练集效果优秀，测试集差；如果在bagging（random forest）采取了过浅的基模型，组合模型的拟合能力会不足，我们可以考虑增加深度，甚至不控制生长。 3）min_samples_split：内部节点再划分所需最小样本数，这个值限制了子树继续划分的条件，如果某节点的样本数少于min_samples_split，则不会继续再尝试选择最优特征来进行划分。随着分裂所需的最小样本数的增加，子模型的结构变得越来越简单，极端情况下，方差减小导致整体模型的拟合能力不足。 4）min_weight_fraction_leaf：叶节点最小权重总值，这个值限制了叶子节点所有样本权重和的最小值，如果小于这个值，则会和其他子叶节点一起被剪枝，会使得模型变得简单，降低了方差，提高了偏差，如果正负样本不一致，需要考虑调整这个值。 5）max_leaf_nodes：最大叶子节点数，通过限制最大叶子节点数，可以防止过拟合，会使得模型变得简单，降低了方差，提高了偏差。这边需要注意如果设置了max_leaf_nodes，会忽略max_depth参数值。 梳理完以上每个参数的对模型拟合的能力及对Vaild集合泛化能力的影响，我们可以根据项目训练中，实际模型的训练集拟合效果，检验集的泛化效果进行优化参数。 调参流程梳理ok，问题来了，很多同学看了之后说，你说了这么多参数作用，你还是没告诉我改如何调参数？我就喜欢这种很关注结果的同学，以下干货来自个人及个人朋友及我从知乎等网站”剽窃”来的观点，不负任何理论责任。 我第一任老大，现在在阿里做算法专家，他根据24个数据集合上以不同的调参流程去训练相同的测试集得出的效果对比，总结出以下一个流程： 先确定快速训练的n_estimators和learning_rate，之后所有的调参基于这个确定的值 再确定合适的subsample 再调优最大树深度（max_depth） 再考虑是否有必要修改叶节点最小权重总值（min_weight_fraction_leaf）,这边是不一定使用的 再调优最大叶节点数（max_leaf_nodes） 再组合优化分裂所需最小样本数（min_samples_split）、叶节点最小样本数（min_samples_leaf） 最后，优化分裂时考虑的最大特征数（max_features） 组合调整n_estimators和learning_rate 但是，我今年在逛知乎的时候偶然看到一个帖子，里面讲的就是调参数的困扰，提到了一个点，就是先确定了max_depth=3后，无论怎么优化min_samples_split和min_samples_leaf对结果都没有任何影响了。当时我想了很久，最后是一位知友解答了这疑惑，其实这样的： 假设原始数据中正负样本比是1:1000，在做max_depth=3的时候，因为样本不均衡，已经可以通过非常简单的少量feature对正负样本进行区分，所以，在之后怎么调节分裂所需要最小样本树和子节点最小样本数都不能够影响到回归树的构造，然而该区分的回归树是没有泛化能力的。 要解决这个问题要么平衡数据，要么就是先确定回归决策树每个叶子结点最小的样本数(min_samples_leaf),再确定分裂所需最小样本数（min_samples_split），才能确定最大深度,这样就能保证不会出现某棵树通过一个feature将数量较少的的正类以较过拟合的简单浅层树拟合出来，而是优先保证了每一次我构造树都尽可能的平衡满足了数据量合理，数据具有样本具有代表性，不会过拟合这样的假设。所以，可以优化为： 先确定快速训练的n_estimators和learning_rate，之后所有的调参基于这个确定的值 再确定合适的subsample 再组合调优最大树深度（max_depth）和叶节点最小样本数（min_samples_leaf） 再调优最大叶节点数（max_leaf_nodes） 再考虑是否有必要修改叶节点最小权重总值（min_weight_fraction_leaf）,这边是不一定使用的 再组合优化分裂所需最小样本数（min_samples_split） 最后，优化分裂时考虑的最大特征数（max_features） 组合调整n_estimators和learning_rate 去年Aarshay Jain大神总结的调参数整理也给出了一种调优思路： 优先，调整最大叶节点数和最大树深度 其次，分裂所需最小样本数（min_samples_split）、叶节点最小样本数（min_samples_leaf）及叶节点最小权重总值（min_weight_fraction_leaf） 然后，分裂时考虑的最大特征数（max_features） 容我多嘴一句，我们思考了这么多，其实如果能在最开始做一个正负样本平衡就会避免很多问题，所以，再次强调数据预处理的重要性。 除此在外，很多人会选择在以上模型调优结束后再以10*learning_rate进行”鞍点逃逸”，以0.1*learning_rate进行”极限探索”。至于random forest及xgboost的更多调参数的细节与gbdt类似，我就不赘述了，有问题可以问我。 终于结束了，这篇文章真的是又繁琐又冗长，希望能够给一些同学对gbdt更深刻的理解。 没啥广告要打，就这样吧。 另求一个比较好的公式编辑器，鬼知道我现在在excel里面写完公式截图过来有多扯淡，而且图片质量超差，谢谢了。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>模型设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[风控用户识别方法]]></title>
    <url>%2F2017%2F12%2F09%2F%E9%A3%8E%E6%8E%A7%E7%94%A8%E6%88%B7%E8%AF%86%E5%88%AB%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[update:18.1.1 :Frcwp已如期上线，满足本文中的所有方法，欢迎拍砖 前言因为工作方向相关，之前我也尝试着在Google、arXiv、wikipedia等等地方搜一些风控识别的资料或者思路，但是事与愿违的是，绝大多数的与风控算法都毫无关系，基本上都是推销自己家的产品的，所以，我之前也尝试着写了一些方法的梳理，如: 多算法识别撞库刷券等异常用户 异常值识别与处理 但是在我前几天再回过头去看自己写的这些东西的时候，作为一个老司机来说，我都不想去看一篇又一篇动则上千字的文章，理论交错，文笔粗陋，正巧现在公司内部也有一个风控的项目，所以，我准备做一个开源的项目Frcwp，核心在于： 简单操作，几乎不用多少调参，自动识别异常点 理论清晰，支持的方法多，兼容性好 集成数据预处理的过程，减轻前置工作量 “纠结”了几个朋友的情况下，一期已经完工，主要是搭建了最简单的框架，我相信，这只是一个开始，欢迎大家试用，也欢迎每一个人来批评，更希望有想法的同学一起来做这个事情。 接下来，让我们来讲讲，一期我们做了什么？核心我们一期做的异常点识别中，核心是利用的14年周志华教授提出的isolation forest算法进行识别，详细的理论部分请参见：Isolation Forest，重复说一个事情的意义也不大。这边需要解释几点： 具体是怎么得到当前的算法流程的呢？ 为什么用当前的算法进行识别而不用其他的识别算法？ 当前的设计下存在哪些问题？ 未来的方向会在哪边？ 让我们来一一来回答这些问题。 为了用Isolation Forest而不用其他的识别算法？在设计这套算法之前，我们其实是遇到了一个实际的业务问题，黑产撞库。相信大家毫不陌生这个词，无论是阿里、京东、滴滴还是腾讯，被撞库是一件普通了不能再普通的事情，“黑产”的人从第三方渠道，获取到你历史上的手机号和一些你曾经用的密码，重复的登陆，暴力的尝试，如果你的密码设置的比较简单，比如：“123456”，“qwerty”…非常容易被破解，然后再根据你历史下单的情况，进行假冒“客服”退款，进行诈骗，百度一搜就有一堆这样的新闻： 频发假冒电商客服 当心!近期有人冒充假客服行骗 几分钟骗走市民八九万元… 所以，我们需要阻止“黑产”人员进行这样的暴力破解，获取用户的资料，由此而引发了我们对这个问题的思考。我们在对这个问题分析的时候，巧妙的发现了如下的一些信息：因为涉及公司机密，这边隐去了具体坐标和值，很容易发现以下问题： 正常扇面内数据分布密集，未知扇面内数据分布松散，异常扇面内数据分布稀疏 正常扇面内的数据量占全量数据的绝大多数 不存在明显的分割线，正常扇面和异常扇面存在过度地带 这个给了我们一些启发，我们做了如下的分析： 我们观察了异常扇面内的用户黑白比，如我们预计的黑白比为20:3，也就是说分布远离大量数据点的用户绝大多数存在问题 为止区域的用户黑白比为1:2，这说明在黑白用户之间不存在明显的界限，有交错地带 正常区域内也存在黑名单用户，比例在504:1，也就是说，我们划分有一定识别能力，但是还是不能做到全量识别 综合上述这些预先的处理，我们要用算法完成三件事情：1.切分全量用户，做到识别出正常，未知，异常用户2.识别出异常用户和正常用户之间的差异约束切割3.在异常用户+未知用户里面，找出利用差异约束切割出黑名单 为什么用当前的算法进行识别而不用其他的识别算法？切分数据的时候，我们这边采用的是切比雪夫切割。非理工科的同学可能比较疑惑什么是切比雪夫切割，这边如果数据是正态下，箱式图的Q3+3/2xQI作为上top点进行切割，大家就应该很熟悉了，其实利用的就是数据出现的概率。上面这张图很好的解释了，在数据服从正态分布的情况下，出现数据值比均值+3x标准差要大的概率不足0.1%，所以，我们可以认为这些数据是异常点了。那现在出现了一个问题，日常数据分布都不一定是正态的，所以引出来了类似的切比雪夫理论，它用的是马氏距离距离中心点的程度，详细的马氏距离理论见马氏距离分布。 切分完成数据之后，我们要做寻找差异约束切割逻辑。从最上面的扇面图，我们很容易发现，正常数据与异常数据之间的密度差异很明显，所以如何识别密度差异的算法就是我们需要的，这边我大概找了6、7种常见的切分方法，这边主要讲三种：isolation forest，lof，distance similarity。理论我之前也讲过，贴上地址，不废话了：密度算法。这边主要展示效果差异：通过68个数据集，很明显的可以看出LOF的识别出来的用户的异常用户异常程度是低于Isolation Forest和Distince Similarity的，起码在我们这些数据集样本中，Isolation Forest和Distince Similarity识别效果差异不大，所以，我们再考虑了另一个性能问题：我们用了CV=10的交叉检验，发现，平均下来，Isolation Forest识别速度是Distince Similarity的1/3以下。综合上述，还有一些其他因素，最后我们选择了Isoation Forest的方法。 当前的设计下存在哪些问题？上面说的都是比较正面的问题，让我们看看，有哪些缺点。首先，从头到尾，我们一直在围绕密度差异这个问题，但是就我平时做的一些小爬虫都知道，降低暴力获取的速度，慢慢搞，这时候就以上的方法就无法做到有效的识别。除此之外，因为我们用了切比雪夫不等式，所以对其有概念的同学知道，算马氏距离的时候需要算协方差矩阵，当数据量异常异常大(我测算的是12mx100)的时候计算资源紧张，可能算不出来；数据量异常异常小的时候feature严重共线性，也可能计算不出来。 未来的方向会在哪边？所以，后续我们会新增其他算法，支持过大过小情况下的识别方法。针对数据量过小的识别情况，我在V0.0.3版本下更新了一个简单识别的方法，之后会优化更好的算法替代掉的。只要数据量太大无法计算的问题，我之后会采取矩阵切割分块计算的方法，这个是后话了。 最后，我们以当前算法包的使用来结束整篇介绍：12#安装pip install Frcwp 自动识别过程：123456789101112131415161718from Frcwp import Frcwptraindata = pd.read_table('../路径')#数据可以在https://github.com/sladesha/machine_learning/tree/master/data下的data_all.csv获取frc = Frcwp()traindata = frc.changeformat(traindata, index=0)# You can define your own outlier size , the details of these params can be got from ../Frcwp/Frcwp.py:params = &#123;'na_rate': 0.4,'single_dealed': 1,'is_scale': 0,'distince_method': 'Maha','outlier_rate': 0.05,'strange_rate': 0.15,'nestimators': 150,'contamination': 0.2&#125;# train the frc modelfrc.fit(traindata, **params) 相关的结果显示：123456789# predict outliers with the trained frc modelpredict_params = &#123;'output': 20,'is_whole': 1&#125;frc.predict(frc.potentialdata_set, **predict_params)# if you want get the whole probability of your potential outliersfrc.similarity_label 以上部分内容截取自我的github，希望对大家有一些帮助。 最后，谢谢大家的阅读，欢迎大家关注我的个人博客。 本文拒绝任何形式的转载，若要转载请联系stw386@sina.com]]></content>
      <categories>
        <category>开源项目</category>
      </categories>
      <tags>
        <tag>风控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FM理论解析及应用]]></title>
    <url>%2F2017%2F12%2F04%2FFM%E7%90%86%E8%AE%BA%E8%A7%A3%E6%9E%90%E5%8F%8A%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[FM的产生背景我其实没有做过很多CTR预估的事情，但是我在工作中常常遇到CRM流失预估、订单预估这些依赖于特征工程的事情，其中就涉及到特征的组合问题。 one-hot过程在feature选取过程中，不可避免的会出现，学历这种高中、大学、研究生等多分类的feature，在实际应用中，我们对单个feature需要进行一种one hot过程，就是将原来的学历拆解为 是否为高中，是否为大学，注意，可以不用加是否为研究生一列，因为是否为高中，是否为大学的两列已经可以推导这个用户是否为研究生，加上这一列有时候反而会共线性。但是这样做，看起来没什么问题，想想看要是100个这样的特征，每个特征有100个这样单独的feature value的话，整体数据将是一个非常庞大的稀疏矩阵，无论是计算还是分析都是会存在巨大的问题的，所以看看我们能不能组合一些特征降低维度。 什么叫做组合问题现在有一组数据，其中特征包含性别（男女），学历（高中，大学，研究生），想要判断这两个feature对是否对化妆品感谢兴趣。单独的观察性别这一栏，发现有一定相关性，但是比较弱，并不是所有的女性都对化妆品感兴趣；单独的观察学历这一栏也发现，学历与对化妆品感兴趣的程度并没有显著的相关性。其实，我们可以从自己的感知理解，首先，数据中女生可能比男生对化妆品更感兴趣，但是女生数据中存在大量的高中生，相对于高中生而言，大学生和研究生可能对化妆品更加感兴趣一点，所以原来的两个feature：性别，学历就组合成了是否为性别女+学历大于高中一个feature，这就是特征组合的过程。如果feature总个数少还可以，要是要有上千上万个，光两两组和就有n*(n-1)/2种可能，所以我们需要想一个其他办法。 组合特征后的表达形式首先，我们都知道一般的线性模型为： 为了考虑组合特征的作用，我们采用多项式来代表，形如特征xi与xj的组合用xixj表示，具体的表达式如下：其中，wij为组合特征xixj的权重，n表示样本的feature个数，xi为第i个feature。 方程定义完成了，下面就要开始数学定义对每一个特征xi引入辅助向量Vi=(vi1,vi2,…vik),这边的k就是矩阵拆解的规模值，利用ViVj.T对交叉项的系数wij进行估计,及则这边需要注意一点，k理论上讲，越大越能强化拟合的能力，但是实际在运算过程中，一来受限于计算能力，二来受限于数据量，过大的k只会带来过拟合的问题。我实测了40w左右的数据，观察到k值在6-8左右，valid集合数据拟合效果最优，仅供参考 很明显，上面这么多未知数：1+n是线性未知数个数，nxfeature是组合特征的未知数个数，常规求解的效率可想而知。但是看到xixj这样的形式，我们很容易联想到：2ab = (a+b)^2 -a^2 -b^2，所以在解决这个wij、xi、xj点积的问题上，我们采用了：1/2 * ( (a+b+c)^2 - a^2 - b^2 - c^2)的方式 下面让我们来解这个式子这边需要一点导数功底，我们先来看对w0也就是bias求导，这个毫无意外，梯度为1；再对wi求导，这个也很简单，xi即可，这个也很简单，少许繁琐的就是wij求导，让我来仔细看看：ok，我知道我的字很丑，别说话，看问题，所以我们可以总结为下面这个网上到处都有的式子：这个式子就是上面这么来的。把上面的那个点积形式代入求解及为： 引申一个FFM概念在FM模型中，每一个特征会对应一个隐变量，但在FFM模型中，认为应该将特征分为多个field，每个特征对应每个field分别有一个隐变量。 举个例子，我们的样本有3种类型的字段：qualifications, age, gender，分别可以代表学历，年龄段，性别。其中qualifications有3种数据，age有5种数据，gender有男女2种，经过one-hot编码以后，每个样本有7个特征，其中只有3个特征非空。如果使用FM模型，则7个特征，每个特征对应一个隐变量。如果使用FFM模型，则7个特征，每个特征对应3个隐变量，即每个类型对应一个隐变量，及对应qualifications, age, gender各占一个。 我看了Yu-Chin Juan实现了一个C++版的FFM模型的源码，倒过来想他的表达式应该是这样的：其他模块都与fm差不多，主要看Vj1f2Vj2f1这个东西。我们假设j1特征属于f1这个field，j2特征属于f2这个feild，则Vj1f2表示j1这个特征对应j2所属的field的隐变量。很恶心的解释，通俗的来讲就是，性别为女与学历这个field的组合有个隐变量，性别女与年龄这个field的组合又有一个不一样的隐变量，而却不考虑到底是什么学历是啥，年龄具体到什么细节。Yu-Chin Juan大神在实际写code的过程中，干掉来常数和一次项，可能是为了方便计算，保留的如下：整理的最优化损失函数如下：前面为l2正则，后面为交互熵形式，我们看到了y*Φ(V,x)这个及其类似hinge loss里面的1−t⋅y部分，所以注意这边的y属于{-1，1}这边的求导，我算了一个小时都没搞出来，等哪天有空了，再仔细的去算一下，去翻了原论文，最后的迭代形式如下：η是常规的速率，V是初始均匀分布即可 代码实现我这边完成了FM的代码实现，详细见我的github：fm代码为了方便不想看细节，只想撸代码的同学，我打包上传到了pypi，你只需要pip install Fsfm即可体验至于ffm，我下午实在没写出来，对不起彭老师，丢脸了，后续看什么时候有空再研究一下。 最后，着重提示，本文很多思路很解析都参考的Yu-Chin Juan的源代码，附上github地址，欢迎去关注原作者的内容，感谢大神带路，谢谢大家阅读。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>特征交叉</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SMOTE算法]]></title>
    <url>%2F2017%2F12%2F01%2FSMOTE%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[17.11.28更新一下：最近把这个算法集成到了数据预处理的python工程代码中了，不想看原理想直接用的，有简易版的python开发：特征工程代码模版 ，进入页面后ctrl+F搜smote就行，请自取 之前一直没有用过python，最近做了一些数量级比较大的项目，觉得有必要熟悉一下python，正好用到了smote，网上也没有搜到，所以就当做一个小练手来做一下。 首先，看下Smote算法之前，我们先看下当正负样本不均衡的时候，我们通常用的方法： 抽样常规的包含过抽样、欠抽样、组合抽样过抽样：将样本较少的一类sample补齐欠抽样：将样本较多的一类sample压缩组合抽样：约定一个量级N，同时进行过抽样和欠抽样，使得正负样本量和等于约定量级N 这种方法要么丢失数据信息，要么会导致较少样本共线性，存在明显缺陷 权重调整常规的包括算法中的weight，weight matrix改变入参的权重比，比如boosting中的全量迭代方式、逻辑回归中的前置的权重设置 这种方式的弊端在于无法控制合适的权重比，需要多次尝试 核函数修正通过核函数的改变，来抵消样本不平衡带来的问题 这种使用场景局限，前置的知识学习代价高，核函数调整代价高，黑盒优化 模型修正通过现有的较少的样本类别的数据，用算法去探查数据之间的特征，判读数据是否满足一定的规律比如，通过线性拟合，发现少类样本成线性关系，可以新增线性拟合模型下的新点 实际规律比较难发现，难度较高 SMOTE（Synthetic minoritye over-sampling technique,SMOTE）是Chawla在2002年提出的过抽样的算法，一定程度上可以避免以上的问题 下面介绍一下这个算法： 很明显的可以看出，蓝色样本数量远远大于红色样本，在常规调用分类模型去判断的时候可能会导致之间忽视掉红色样本带了的影响，只强调蓝色样本的分类准确性，这边需要增加红色样本来平衡数据集 Smote算法的思想其实很简单，先随机选定n个少类的样本，如下图 再找出最靠近它的m个少类样本，如下图 再任选最临近的m个少类样本中的任意一点， 在这两点上任选一点，这点就是新增的数据样本 R语言上的开发较为简单，有现成的包库，这边简单介绍一下：1234567rm(list=ls())install.packages(“DMwR”,dependencies=T)library(DMwR)#加载smote包newdata=SMOTE(formula,data,perc.over=,perc.under=)#formula:申明自变量因变量#perc.over：过采样次数#perc.under：欠采样次数 效果对比：简单的看起来就好像是重复描绘了较少的类这边的smote是封装好的，直接调用就行了，没有什么特别之处 这边自己想拿刚学的python练练手，所有就拿python写了一下过程：12345678910111213# -*- coding: utf-8 -*-import numpy as npimport pandas as pdfrom sklearn.preprocessing import StandardScalerfrom numpy import *import matplotlib.pyplot as plt#读数据data = pd.read_table('C:/Users/17031877/Desktop/supermarket_second_man_clothes_train.txt', low_memory=False)#简单的预处理test_date = pd.concat([data['label'], data.iloc[:, 7:10]], axis=1)test_date = test_date.dropna(how='any') 数据大致如下：12345678910test_date.head()Out[25]:label max_date_diff max_pay cnt_time0 0 23.0 43068.0 151 0 10.0 1899.0 22 0 146.0 3299.0 213 0 30.0 31959.0 354 0 3.0 24165.0 98test_date['label'][test_date['label']==0].count()/test_date['label'][test_date['label']==1].count()Out[37]: 67 label是样本类别判别标签，1:0=67:1，需要对label=1的数据进行扩充 12345678# 筛选目标变量aimed_date = test_date[test_date['label'] == 1]# 随机筛选少类扩充中心index = pd.DataFrame(aimed_date.index).sample(frac=0.1, random_state=1)index.columns = ['id']number = len(index)# 生成array格式aimed_date_new = aimed_date.ix[index.values.ravel(), :] 随机选取了全量少数样本的10%作为数据扩充的中心点 12345678910111213# 自变量标准化sc = StandardScaler().fit(aimed_date_new)aimed_date_new = pd.DataFrame(sc.transform(aimed_date_new))sc1 = StandardScaler().fit(aimed_date)aimed_date = pd.DataFrame(sc1.transform(aimed_date))# 定义欧式距离计算def dist(a, b): a = array(a) b = array(b) d = ((a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2 + (a[2] - b[2]) ** 2 + (a[3] - b[3]) ** 2) ** 0.5 return d 下面定义距离计算的方式，所有算法中，涉及到距离的地方都需要标准化去除冈量，也同时加快了计算的速度这边采取了欧式距离的方式，更多计算距离的方式参考：多种距离及相似度的计算理论介绍 1234567891011# 统计所有检验距离样本个数row_l1 = aimed_date_new.iloc[:, 0].count()row_l2 = aimed_date.iloc[:, 0].count()a = zeros((row_l1, row_l2))a = pd.DataFrame(a)# 计算距离矩阵for i in range(row_l1): for j in range(row_l2): d = dist(aimed_date_new.iloc[i, :], aimed_date.iloc[j, :]) a.ix[i, j] = db = a.T.apply(lambda x: x.min()) 调用上面的计算距离的函数，形成一个距离矩阵 1234567891011121314151617181920# 找到同类点位置h = []z = []for i in range(number): for j in range(len(a.iloc[i, :])): ai = a.iloc[i, j] bi = b[i] if ai == bi: h.append(i) z.append(j) else: continuenew_point = [0, 0, 0, 0]new_point = pd.DataFrame(new_point)for i in range(len(h)): index_a = z[i] new = aimed_date.iloc[index_a, :] new_point = pd.concat([new, new_point], axis=1)new_point = new_point.iloc[:, range(len(new_point.columns) - 1)] 再找到位置的情况下，再去原始的数据集中根据位置查找具体的数据 123456789101112import randomr1 = []for i in range(len(new_point.columns)): r1.append(random.uniform(0, 1))new_point_last = []new_point_last = pd.DataFrame(new_point_last)# 求新点 new_x=old_x+rand()*(append_x-old_x)for i in range(len(new_point.columns)): new_x = (new_point.iloc[1:4, i] - aimed_date_new.iloc[number - 1 - i, 1:4]) * r1[i] + aimed_date_new.iloc[ number - 1 - i, 1:4] new_point_last = pd.concat([new_point_last, new_x], axis=1)print new_point_last 最后，再根据smote的计算公式new_x=old_x+rand()*(append_x-old_x)，计算出新的点即可，python练手到此就结束了 其实，在这个结果上，我们可以综合Tomek link做一个集成的数据扩充的算法，思路如下：假设，我们利用上述的算法产生了两个青色方框的新数据点：我们认为，对于新产生的青色数据点与其他非青色样本点距离最近的点，构成一对Tomek link，如下图框中的青蓝两点 我们可以定义规则：当以新产生点为中心，Tomek link的距离为范围半径，去框定一个空间，空间内的少数类的个数/多数类的个数&lt;最低阀值的时候，认为新产生点为“垃圾点”，应该剔除或者再次进行smote训练；空间内的少数类的个数/多数类的个数&gt;=最低阀值的时候,在进行保留并纳入smote训练的初始少类样本集合中去抽样所以，剔除左侧的青色新增点，只保留右边的新增数据如下： 参考文献： https://www.jair.org/media/953/live-953-2037-jair.pdf https://github.com/fmfn/UnbalancedDataset Batista, G. E., Bazzan, A. L., &amp; Monard, M. C. (2003, December). Balancing Training Data for Automated Annotation of Keywords: a Case Study. In WOB (pp. 10-18). Batista, G. E., Prati, R. C., &amp; Monard, M. C. (2004). A study of the behavior of several methods for balancing machine learning training data. ACM Sigkdd Explorations Newsletter, 6(1), 20-29.]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>理论解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多算法识别撞库刷券等异常用户]]></title>
    <url>%2F2017%2F12%2F01%2F%E5%A4%9A%E7%AE%97%E6%B3%95%E8%AF%86%E5%88%AB%E6%92%9E%E5%BA%93%E5%88%B7%E5%88%B8%E7%AD%89%E5%BC%82%E5%B8%B8%E7%94%A8%E6%88%B7%2F</url>
    <content type="text"><![CDATA[在运营业务中，绝大多数公司会面临恶意注册，恶意刷接口，恶意刷券等流量问题，此类问题的常规解决方案都是拍定单位时间内的ip访问上限次数、qps上限次数等等，会存在误伤、频繁修改阀值等问题。 问题剖析：此类问题的关键在识别出与正常数据集群差异较大的离群点。所以，存在两个难点： 1.难以找到一个很清晰的边界，界定什么是正常用户，什么是异常用户 2.维数灾难及交叉指标计算之间的高频计算性能瓶颈 算法概述： 1.图形位置分布 2.统计方法检测 3.距离位置检测 4.密度位置检测 5.无监督模型识别 算法详述：1.图形位置分布当我们不需要长期监控异常用户，只需要少数几次识别异常用户，且精度要求不高的时候，我们可以采取简单方便的图形识别方式，例如：箱式图。 箱式图判断中，一般我们只需要锁定25%(Q1)分位点的用户特征值，75%(Q3)分位点的用户特征值，Q3与Q1之间的位差即为IQR，一般认定Q3+1.5个IQR外的点即为异常点，对应的用户即为异常用户。这种方法也叫做“盖帽法”，不必人为设定上限阀值，随着用户的数据变化而变化上界，避免了高频修改的问题，只是精度欠缺且绝大多数情况下识别出的异常用户较少。 方法比较简单，也不多加解释了。 2.统计方法检测方法也比较简单，上线开发简单。一直是分两步： 先假设全量数据服从一定的分布，比如常见的正太分布，泊松分布等 在计算每个点属于这个分布的概率，也就是大家常用的以平均值和方差定密度函数的问题 因为这边，我们前期无法知道数据服从什么样的分布，所以，我们这边可以用切比雪夫不等式来代替确定的分布形式。除此之外，也就是同时用了马氏距离来衡量了每个具体的点在整体数据集中的位置。 核心代码就是下面这个协方差矩阵及矩阵相乘：123456789101112#两个维度之间协方差矩阵S=np.cov(X) #协方差矩阵的逆矩阵SI = np.linalg.inv(S) #第一次计算全量用户的维度重心XTmean = XT.mean(axis=0)d1=[]n = XT.shape[0]for i in range(n): delta = XT[i] - XTmean d = np.sqrt(np.dot(np.dot(delta,SI),delta.T)) d1.append(d) 这个方法的最核心的优点就是对全量数据进行了分块，可以理解为将1拆分成了必定有问题的1/m用户，可能有问题的1/n用户，必定没问题的1/w用户（1/m+1/n+1/w=1），这也奠定了后续更好的方法的基础。但是问题也是很明显的，对于1/m，1/n的大小确定无法非常的精准，多了则影响正常用户，少了则无法准确拦截，还是一个划分的算法，并不能给出每个人的好坏程度。 3.距离位置检测距离探测的方法有一个非常强的假设，正常的用户都比较集中，有较多的邻居，而异常用户都特立独行。在常见的业务问题中都是满足的，比如对爬虫ip的识别，撞库的识别，这些一看那些高频访问的就不是正常用户，但是对于特别稀疏的业务场景，比如企业融资，高深度的敏感页面访问，均不是很适用，它们的频次较低无法构成一个邻居的概念。 这边非常常用的有2种，一个是连续特征间的欧式距离（标准化下的欧式距离（马氏距离）），另一个是名义变量下的余弦相似度。 这边只讨论第一种情况，连续特征下如何衡量数据是否为异常数据。前面我们也说到了，切比雪夫不等式的方法能够有效的划分出三个类别正常用户，异常用户，未知用户。所以，相应的，我们只需要在未知用户的集群里面去寻找与正常用户更不相似的，或者和异常用户更相似的用户就可以了。 对于单变量衡量： 对于多变量衡量： 核心计算相似度的方式就是以上两个公式，会有一些细节处理的问题及注意点，大家可自行研究。 4.密度位置检测这边先等下谈原理，较为冗长，先说结论，其实，在能够使用距离位置检测的情况下，优先使用距离位置检测的方法。密度方法的前提几乎与位置方法的前提一致，但是在计算量级上而言，存在较大的差异差别。 上述的图片是Fei Tony Liu, Kai Ming Ting, Zhi-Hua Zhou的一篇论文里面对比的常见的iForest,ORCA,LOF(也就是密度位置检测),RF方法的准确率和耗时情况，也清晰的可以看出，同为距离衡量的ORCA的耗时较大，但是LOF的耗时更高，甚至部分情况下都无法计算出结果。 下面让我们看下理论先，密度位置检测的方法之一，LOF：概念定义：1) d(p,o)：两点p和o之间的距离；2) k-distance：第k距离 对于点p的第k距离dk(p)定义如下： dk(p)=d(p,o)，并且满足： a) 在集合中至少有不包括p在内的k个点o,∈C{x≠p}， 满足d(p,o,)≤d(p,o) ； b) 在集合中最多有不包括p在内的k−1个点o,∈C{x≠p}，满足d(p,o,)&lt;d(p,o) ； 上面两个条件总结起来就是1.距离范围内至少满足一定数量的点数，2.最多允许有一个距离最大的非p点形象的看，距离就是p的第k距离，也就是距离p第k远的点的距离，不包括p，如下图箭头的路径长度。 3) k-distance neighborhood of p：第k距离邻域 点p的第k距离邻域Nk(p)，就是p的第k距离即以内的所有点，包括第k距离。 因此p的第k邻域点的个数记为 |Nk(p)|，且|Nk(p)|≥k 我们在定义一些衡量指标，那么LOF就算是完成了：1、可达距离（reach-distance）点o到点p的第k可达距离定义为：reach-distancek(p,o)=max{k−distance(o),d(p,o)} 2、局部可达密度（local reachablility density）点p处的局部可达密度为： 其中，|Nk(p)|为p的第k领域点的个数，∑o∈Nk(p)reach-distk(p,o)计算的是p的k领域内的点到p的可达距离，也就是1中涉及的计算方式。 3、局部离群因子（local outlier factor）点p的局部离群因子为：LOF（p） = （∑o∈Nk(p)lrdk(o)/lrdk(p)）/|Nk(p)|其中，lrdk(o)/lrdk(p)比值衡量了p点与附近的点之间的密切差异情况，LOF值=1时，代表p与p附近的点密度一致；LOF值1时，代表p点的密度小于p附近点的密度，也是非常符合我们的前提假设的，异常点总是比较稀疏，正常点总是比较稠密的。 到此位置LOF的数学理论就完成了，让我们回顾一下它的思想。它其实就是找数据集合中的每一个点及其邻居的点，计算它和它的邻居的密度，当它的密度大于等于它邻居的密度的时候，则认为它是稠密中心，是正常用户数据；否则异常。但是要计算每个点及对应的邻居的LOF值，计算成本也是非常的高的，最初我们也指出了这一点。 核心代码：12345678910111213141516171819def k_distance(k, instance, instances, distance_function=distance_euclidean): distances = &#123;&#125; for instance2 in instances: distance_value = distance_function(instance, instance2) if distance_value in distances: distances[distance_value].append(instance2) else: distances[distance_value] = [instance2] distances = sorted(distances.items()) neighbours = [] k_sero = 0 k_dist = None for dist in distances: k_sero += len(dist[1]) neighbours.extend(dist[1]) k_dist = dist[0] if k_sero &gt;= k: break return k_dist, neighbours 5.无监督模型识别其实这边说完全的无监督，我觉得不是很准确，我觉得叫“半监督”可能更好一些。这边方法很多，我只介绍两种：1.Iforest2.RNN 先让我们看下Iforest：算法的关键在于:对于一个有若干维的数据集合，对于其中的任一维度，如果该维度是连续属性的话，在若干次随机二分类后，边界稀疏点最容易优先达到子叶节点,如下图： 算法实现详细的过程为：假设数据集有N条数据，构建一颗iTree时，从N条数据中均匀抽样(一般是无放回抽样)出m(通常为256)个样本出来，作为这颗树的训练样本。在样本中，随机选一个特征，并在这个特征的所有值范围内(最小值与最大值之间)随机选一个值，对样本进行二叉划分，将样本中小于该值的划分到节点的左边，大于等于该值的划分到节点的右边,重复以上划分步骤，直到达到划分层数上限log(m)或者节点内只有一个样本，一棵树Itree的结果往往是不可信的，所以我们可以训练100-255棵树，最后整合所以树的结果取平均的深度作为输出深度，也叫做Isolation Forest。 有了算法逻辑，再看衡量指标： 其中，h(x)为x对应的节点深度，c(n)为样本可信度，s(x,n)~[0,1]，正常数据来讲s(x,n)小于0.8，s(x,n)越靠近1，数据异常的可能性越大。（这边需要注意，在sklearn中的Isolation是取得相反的逻辑，score越小数据异常的可能性越大。） 这边也贴上核心代码：12345678910111213141516171819202122232425262728def fit(self, X, y=None, sample_weight=None): X = check_array(X, accept_sparse=['csc'], ensure_2d=False) if issparse(X): # Pre-sort indices to avoid that each individual tree of the # ensemble sorts the indices. X.sort_indices() rnd = check_random_state(self.random_state) y = rnd.uniform(size=X.shape[0]) # ensure that max_sample is in [1, n_samples]: n_samples = X.shape[0] if not (self.max_samples &lt;= n_samples): warn("max_samples is larger than the total number of samples" " n_samples. Corrected as max_samples=n_samples") self.max_samples = n_samples if not (0 &lt; self.max_samples): raise ValueError("max_samples has to be positive") super(IsolationForest, self).fit(X, y, sample_weight=sample_weight) return self def _cost(self, n): if n &lt;= 1: return 1. else: harmonic_number = np.log(n) + 0.5772156649 return 2. * harmonic_number - 2. * (n - 1.) / n 2.RNN通常我们会以5层的卷积神经网络作为训练网络。我在这边处理之前将切比雪夫不等式划分出来的正常用户作为0-output，异常用户作为1-output，然后尽可能的降低损失函数的误差即可。 第一层是常规层，将不同的input做线性组合： 第二层、第四层是做数据非线性变化：这边选用的是tanh函数 第三层是做梯度分层下的非线性变化，抹平相似特征间的ouput：其中，k为3，N为想要分的梯度的个数，a3为一个阶梯跳跃到另一个阶梯的转换效率，形如： 第五层，也就是最后一层通过sigmoid进行0-1之间的压缩。 这边的损失函数用的是常见的mse： 当通过测试数据训练完成后，再将未知数据进行模型训练，观察得到结果的大小，越靠近1，越有可能为异常用户。 以上就是5种常见的只基于数据下的异常用户的识别，更偏方法技术一点，但是无论是算法实现还是业务应用中，同样需要注意输入特征的问题。由于大家运用方向不同，就不细节赘述。 欢迎大家关注我的个人bolg，更多代码内容欢迎follow我的个人Github，如果有任何算法、代码疑问都欢迎通过公众号发消息给我哦。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>风控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python开发：特征工程代码模版(二)]]></title>
    <url>%2F2017%2F12%2F01%2Fpython%E5%BC%80%E5%8F%91%EF%BC%9A%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[update:17.12.21 : Mutual Information互信息中mic_entroy函数里的I应该是i，已修正 转载请注明文章来源：python开发：特征工程代码模版（二），你们免费转我文章，不标注来源就算了，现在还开始写“原创”，这就过分了～ 正题开始：这篇文章是入门级的特征处理的打包解决方案的python实现汇总，如果想get一些新鲜血液的朋友可以叉了，只是方便玩数据的人进行数据特征筛选的代码集合，话不多说，让我们开始。 首先，让我们看一张入门级别的数据预处理的基本操作图，网上有很多版本，这个是我自己日常干活的时候必操作的行为罗列，其中数据整理部分已经在上一篇文章中给出了，下面我们讲一起来看看特征筛选这块。此图请尊重一下我，别拿出去传播，纯属个人的方法论，大家看看就行，谢谢。网上有其他版本的，你们去传播那些就ok了～ 方差选择法1234567def var_filter(data, k=None): var_data = data.var().sort_values() if k is not None: new_data = VarianceThreshold(threshold=k).fit_transform(data) return var_data, new_data else: return var_data 这个方法的思路很明确，我们筛掉方差过小的feature，也很好理解，一列值完全或者几乎完全一致的feature对于我们去训练最后的模型没有任何好处。熵理论也同样印证了这一点。 线性相关系数衡量123456789101112131415161718192021def pearson_value(data, label, k=None): label = str(label) # k为想删除的feature个数 Y = data[label] x = data[[x for x in data.columns if x != label]] res = [] for i in range(x.shape[1]): data_res = np.c_[Y, x.iloc[:, i]].T cor_value = np.abs(np.corrcoef(data_res)[0, 1]) res.append([label, x.columns[i], cor_value]) res = sorted(np.array(res), key=lambda x: x[2]) if k is not None: if k &lt; len(res): new_c = [] # 保留的feature for i in range(len(res) - k): new_c.append(res[i][1]) return res, new_c else: print('feature个数越界～') else: return res 当你明确了自变量与因变量之间存在线性关系的时候，你就需要剔除掉一些关心比较弱的变量，奥卡姆剃刀原理告诉我们，在尽可能压缩feature个数大小的情况下去得到效果最优的模型才是合理模型。 共线性检验123456789101112131415161718192021222324252627def vif_test(data, label, k=None): label = str(label) # k为想删除的feature个数 x = data[[x for x in data.columns if x != label]] res = np.abs(np.corrcoef(x.T)) vif_value = [] for i in range(res.shape[0]): for j in range(res.shape[0]): if j &gt; I: vif_value.append([x.columns[i], x.columns[j], res[i, j]]) vif_value = sorted(vif_value, key=lambda x: x[2]) if k is not None: if k &lt; len(vif_value): new_c = [] # 保留的feature for i in range(len(x)): if vif_value[-i][1] not in new_c: new_c.append(vif_value[-i][1]) else: new_c.append(vif_value[-i][0]) if len(new_c) == k: break out = [x for x in x.columns if x not in new_c] return vif_value, out else: print('feature个数越界～') else: return vif_value 2-3年前面试必考题，什么叫做共线性？如何解决共线性？答案之一就是共线性检验啊，判断feature之间的相关性，剔除相关性较高的feature，在R语言里面有个VIF函数可以直接求的。除此之外，采用非线性函数做特征拆解也是很好的方法。共线性严重的情况下，会导致泛化误差异常大，需着重注意～ Mutual Information互信息12345678910111213141516171819202122232425262728293031323334353637383940def MI(X, Y): # len(X) should be equal to len(Y) # X,Y should be the class feature total = len(X) X_set = set(X) Y_set = set(Y) if len(X_set) &gt; 10: print('%s非分类变量，请检查后再输入' % X_set) sys.exit() elif len(Y_set) &gt; 10: print('%s非分类变量，请检查后再输入' % Y_set) sys.exit() # Mutual information MI = 0 eps = 1.4e-45 for i in X_set: for j in Y_set: indexi = np.where(X == i) indexj = np.where(Y == j) ijinter = np.intersect1d(indexi, indexj) px = 1.0 * len(indexi[0]) / total py = 1.0 * len(indexj[0]) / total pxy = 1.0 * len(ijinter) / total MI = MI + pxy * np.log2(pxy / (px * py) + eps) return MIdef mic_entroy(data, label, k=None): # mic_value值越小，两者相关性越弱 label = str(label) # k为想删除的feature个数 x = data[[x for x in data.columns if x != label]] Y = data[label] mic_value = [] for i in range(x.shape[1]): if len(set(x.iloc[:, i])) &lt;= 10: res = MI(Y, x.iloc[:, I]) mic_value.append([x.columns[i], res]) mic_value = sorted(mic_value, key=lambda x: x[1]) return mic_value 本来我想偷懒，直接import minepy然后就得了，发现真的是特么难装，各种报错，一怒之下自己写了，这边求大佬告知，为什么pip install minepy会有这样的问题：12345678xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrunerror: command '/usr/bin/clang' failed with exit status 1----------------------------------------Command "/Users/slade/anaconda3/bin/python -u -c "import setuptools, tokenize;__file__='/private/var/folders/hv/kfb7n4lj06590hqxjv6f3dd00000gn/T/pip-build-hr9ej0lw/minepy/setup.py';f=getattr(tokenize, 'open', open)(__file__);code=f.read().replace('\r\n', '\n');f.close();exec(compile(code, __file__, 'exec'))" install --record /var/folders/hv/kfb7n4lj06590hqxjv6f3dd00000gn/T/pip-30cn7rbs-record/install-record.txt --single-version-externally-managed --compile" failed with error code 1 in /private/var/folders/hv/kfb7n4lj06590hqxjv6f3dd00000gn/T/pip-build-hr9ej0lw/minepy/ 回到正题，互信息其实很简单，我们看个公式I(X;Y)=H(X)-H(X|Y)，看完是不是超级清晰了，其实就是X发生的概率中去掉Y发生后X发生的概率，或者说是一个随机变量由于已知另一个随机变量而减少的不肯定性。计算公式如下，你们也可以在上面的代码里找到影子。最后还是吐槽下，这个minepy太难装了，为了个互信息，不至于不至于～ 递归特征消除法123456789101112131415def wrapper_way(data, label, k=3): # k 为要保留的数据feature个数 label = str(label) label_data = data[label] col = [x for x in data.columns if x != label] train_data = data[col] res = pd.DataFrame( RFE(estimator=LogisticRegression(), n_features_to_select=k).fit_transform(train_data, label_data)) res_c = [] for i in range(res.shape[1]): for j in range(data.shape[1]): if (res.iloc[:, i] - data.iloc[:, j]).sum() == 0: res_c.append(data.columns[j]) res.columns = res_c return res 这边开始的代码就基本上是方法梳理了，没啥亮点，我就大概和大家聊聊，递归特征消除法，用R语言里面的step()函数是一毛一样的东西，都是循环sample特征，选一个对于当前模型，特征组合最好的结果。如果数据量大，你会有非一般的感觉，这边就有小trick了，以后有空可以和大家分享～ l1/l2正则方法12345678910111213def embedded_way(data, label, way='l2', C_0=0.1): label = str(label) label_data = data[label] col = [x for x in data.columns if x != label] train_data = data[col] res = pd.DataFrame(SelectFromModel(LogisticRegression(penalty=way, C=C_0)).fit_transform(train_data, label_data)) res_c = [] for i in range(res.shape[1]): for j in range(data.shape[1]): if (res.iloc[:, i] - data.iloc[:, j]).sum() == 0: res_c.append(data.columns[j]) res.columns = res_c return res 正则理论参考：总结：常见算法工程师面试题目整理(二)，这边要提一点，并不是所有情况下都需要正则预处理的，很多算法自带正则，比如logistic啊，比如我们自己去写tensorflow神经网络啊，模型会针对性的解决问题，而这边单纯用的logstic方法来筛选，相对而言内嵌的效果会更好的。 基于树模型特征选择12345678910111213def tree_way(data,label): label = str(label) label_data = data[label] col = [x for x in data.columns if x != label] train_data = data[col] res = pd.DataFrame(SelectFromModel(GradientBoostingClassifier()).fit_transform(train_data, label_data)) res_c = [] for i in range(res.shape[1]): for j in range(data.shape[1]): if (res.iloc[:, i] - data.iloc[:, j]).sum() == 0: res_c.append(data.columns[j]) res.columns = res_c return res 这边用的是决策树每次分支下，如果改变一列值为随机值，观察对整体数据效果的影响。举个通俗易懂的例子，看看你在公司的重要性，就去和你老板提离职，要是老板疯狂给你加工资做你的思想工作，代表你很重要；如果你的老板让你去财务结账，代表你没啥意义。这里你就是这个feature，你老板就是数据效果的检验指标，常见的就是oob之类的。 这边facebook有个非常好的拓展的思路，但是大家都吹的多实际应用很少，我最近在搞这事情，等下更完这边的特征工程和下面一个nlp的case后，我想专门聊聊这个事情，用的就是决策树的另一角度，以叶子结点代替原feature，做到了非线性的特征融入线性模型，虽然很老套，但是我稍稍做了测试，效果斐然： 最后的最后，感谢大家阅读，希望能够给大家带来收获，谢谢～]]></content>
      <categories>
        <category>代码集合</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python开发：特征工程代码模版(一)]]></title>
    <url>%2F2017%2F12%2F01%2Fpython%E5%BC%80%E5%8F%91%EF%BC%9A%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[作为一个算法工程师，我们接的业务需求不会比数据分析挖掘工程师少，作为一个爱偷懒的人，总机械重复的完成一样的预处理工作，我是不能忍的，所以在最近几天，我正在完善一些常规的、通用的预处理的code，方便我们以后在每次分析之前直接import快速搞定，省的每次都要去做一样的事情。 如果大家有什么想实现但是懒得去弄的预处理的步骤也可以私信我，我相对而言闲暇还是有的（毕竟工资少工作也不多，摊手：《），我开发完成后直接贴出来，大家以后一起用就行了 我们需要预加载这些包，而且接下来所有的操作均在dataframe格式下完成，所以我们需要将数据先处理成dataframe格式123456789101112131415from __future__ import divisionimport numpy as npimport pandas as pdfrom sklearn import preprocessingfrom sklearn.cross_validation import train_test_splitfrom sklearn.neighbors import NearestNeighbors__author__ = 'slade_sal'__time__ = '20171128'def change_data_format(data): # 以下预处理都是基于dataframe格式进行的 data_new = pd.DataFrame(data) return data_new 接下来就开始我们的正题了，首先，我们需要判断哪些列是空值过多的，当一列数据的空值占列数的40%以上（经验值），这列能够带给我们的信息就不多了，所以我们需要把某个阀值（rate_base）以上的空值个数的列干掉，如下：123456789101112# 去除空值过多的featuredef nan_remove(data, rate_base=0.4): all_cnt = data.shape[0] avaiable_index = [] # 针对每一列feature统计nan的个数，个数大于全量样本的rate_base的认为是异常feature，进行剔除 for i in range(data.shape[1]): rate = np.isnan(np.array(data.iloc[:, i])).sum() / all_cnt if rate &lt;= rate_base: avaiable_index.append(i) data_available = data.iloc[:, avaiable_index] return data_available, avaiable_index 把空值过多的列去完之后，我们需要考虑将一些特别离群的点去掉，这边需要注意两点： 异常值分析类的场景禁止使用这步，比如信用卡评分，爬虫识别等，你如果采取了这步，还怎么去分离出这些异常啊 容忍度高的算法不建议使用这步，比如svm里面已经有了支持向量机这个东西，你如果采取了这步的离群识别的操作会改变原分布而且svm里面决定超平面的核心与离群点无关，后接函数会引发意想不到的彩蛋～ 这边采取盖帽法与额定的分位点方法，建议组合使用，用changed_feature_box定义需要采用盖帽法的列的index_num，代码如下：12345678910111213141516171819202122232425262728293031323334353637383940# 离群点盖帽def outlier_remove(data, limit_value=10, method='box', percentile_limit_set=90, changed_feature_box=[]): # limit_value是最小处理样本个数set，当独立样本大于limit_value我们认为非可onehot字段 feature_cnt = data.shape[1] feature_change = [] if method == 'box': for i in range(feature_cnt): if len(pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &gt;= limit_value: q1 = np.percentile(np.array(data.iloc[:, i]), 25) q3 = np.percentile(np.array(data.iloc[:, i]), 75) # q3+3/2*qi为上截距点，详细百度分箱图 top = q3 + 1.5 * (q3 - q1) data.iloc[:, i][data.iloc[:, i] &gt; top] = top feature_change.append(i) return data, feature_change if method == 'self_def': # 快速截断 if len(changed_feature_box) == 0: # 当方法选择为自定义，且没有定义changed_feature_box则全量数据全部按照percentile_limit_set的分位点大小进行截断 for i in range(feature_cnt): if len(pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &gt;= limit_value: q_limit = np.percentile(np.array(data.iloc[:, i]), percentile_limit_set) data.iloc[:, i][data.iloc[:, i] &gt; q_limit] = q_limit feature_change.append(i) else: # 如果定义了changed_feature_box，则将changed_feature_box里面的按照box方法，changed_feature_box的feature index按照percentile_limit_set的分位点大小进行截断 for i in range(feature_cnt): if len(pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &gt;= limit_value: if i in changed_feature_box: q1 = np.percentile(np.array(data.iloc[:, i]), 25) q3 = np.percentile(np.array(data.iloc[:, i]), 75) # q3+3/2*qi为上截距点，详细百度分箱图 top = q3 + 1.5 * (q3 - q1) data.iloc[:, i][data.iloc[:, i] &gt; top] = top feature_change.append(i) else: q_limit = np.percentile(np.array(data.iloc[:, i]), percentile_limit_set) data.iloc[:, i][data.iloc[:, i] &gt; q_limit] = q_limit feature_change.append(i) return data, feature_change 在此之后，我们需要对空值进行填充，这边方法就很多很多了，我这边实现的是基本的，分了连续feature和分类feature，分别针对continuous feature采取mean,min,max方式，class feature采取one_hot_encoding的方式；除此之外还可以做分层填充，差分填充等等，那个比较定制化，如果有需要，我也可以搞一套，但是个人觉得意义不大。12345678910111213141516171819202122232425262728293031323334# 空feature填充def nan_fill(data, limit_value=10, countinuous_dealed_method='mean'): feature_cnt = data.shape[1] normal_index = [] continuous_feature_index = [] class_feature_index = [] continuous_feature_df = pd.DataFrame() class_feature_df = pd.DataFrame() # 当存在空值且每个feature下独立的样本数小于limit_value，我们认为是class feature采取one_hot_encoding； # 当存在空值且每个feature下独立的样本数大于limit_value，我们认为是continuous feature采取mean,min,max方式 for i in range(feature_cnt): if np.isnan(np.array(data.iloc[:, i])).sum() &gt; 0: if len(pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &gt;= limit_value: if countinuous_dealed_method == 'mean': continuous_feature_df = pd.concat( [continuous_feature_df, data.iloc[:, i].fillna(data.iloc[:, i].mean())], axis=1) continuous_feature_index.append(i) elif countinuous_dealed_method == 'max': continuous_feature_df = pd.concat( [continuous_feature_df, data.iloc[:, i].fillna(data.iloc[:, i].max())], axis=1) continuous_feature_index.append(i) elif countinuous_dealed_method == 'min': continuous_feature_df = pd.concat( [continuous_feature_df, data.iloc[:, i].fillna(data.iloc[:, i].min())], axis=1) continuous_feature_index.append(i) elif len(pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &gt; 0 and len( pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &lt; limit_value: class_feature_df = pd.concat( [class_feature_df, pd.get_dummies(data.iloc[:, i], prefix=data.columns[i])], axis=1) class_feature_index.append(i) else: normal_index.append(i) data_update = pd.concat([data.iloc[:, normal_index], continuous_feature_df, class_feature_df], axis=1) return data_update 分类feature的one hot encoding过程，常见操作，不多说123456789101112131415# onehotencodingdef ohe(data, limit_value=10): feature_cnt = data.shape[1] class_index = [] class_df = pd.DataFrame() normal_index = [] # limit_value以下的均认为是class feature，进行ohe过程 for i in range(feature_cnt): if len(pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &lt; limit_value: class_index.append(i) class_df = pd.concat([class_df, pd.get_dummies(data.iloc[:, i], prefix=data.columns[i])], axis=1) else: normal_index.append(i) data_update = pd.concat([data.iloc[:, normal_index], class_df], axis=1) return data_update 正负样本不平衡的解决，这边我写的是smote，理论部分建议参考：Python：SMOTE算法,其实简单的欠抽样和过抽样就可以解决，建议参考这边文章：Python:数据抽样平衡方法重写。都是一些老生常谈的问题了，不多说了，上代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# smote unbalance datasetdef smote(data, tag_label='tag_1', amount_personal=0, std_rate=5, k=5,method = 'mean'): cnt = data[tag_label].groupby(data[tag_label]).count() rate = max(cnt) / min(cnt) location = [] if rate &lt; 5: print('不需要smote过程') return data else: # 拆分不同大小的数据集合 less_data = np.array(data[data[tag_label] == np.array(cnt[cnt == min(cnt)].index)[0]]) more_data = np.array(data[data[tag_label] == np.array(cnt[cnt == max(cnt)].index)[0]]) # 找出每个少量数据中每条数据k个邻居 neighbors = NearestNeighbors(n_neighbors=k).fit(less_data) for i in range(len(less_data)): point = less_data[i, :] location_set = neighbors.kneighbors([less_data[i]], return_distance=False)[0] location.append(location_set) # 确定需要将少量数据补充到上限额度 # 判断有没有设定生成数据个数，如果没有按照std_rate(预期正负样本比)比例生成 if amount_personal &gt; 0: amount = amount_personal else: amount = int(max(cnt) / std_rate) # 初始化，判断连续还是分类变量采取不同的生成逻辑 times = 0 continue_index = [] # 连续变量 class_index = [] # 分类变量 for i in range(less_data.shape[1]): if len(pd.DataFrame(less_data[:, i]).drop_duplicates()) &gt; 10: continue_index.append(i) else: class_index.append(i) case_update = pd.DataFrame() while times &lt; amount: # 连续变量取附近k个点的重心，认为少数样本的附近也是少数样本 new_case = [] pool = np.random.permutation(len(location))[0] neighbor_group = less_data[location[pool], :] if method == 'mean': new_case1 = neighbor_group[:, continue_index].mean(axis=0) # 连续样本的附近点向量上的点也是异常点 if method =='random': new_case1 =less_data[pool][continue_index] + np.random.rand()*(less_data[pool][continue_index]-neighbor_group[0][continue_index]) # 分类变量取mode new_case2 = [] for i in class_index: L = pd.DataFrame(neighbor_group[:, i]) new_case2.append(np.array(L.mode()[0])[0]) new_case.extend(new_case1) new_case.extend(new_case2) case_update = pd.concat([case_update, pd.DataFrame(new_case)], axis=1) print('已经生成了%s条新数据，完成百分之%.2f' % (times, times * 100 / amount)) times = times + 1 data_res = np.vstack((more_data, np.array(case_update.T))) data_res = pd.DataFrame(data_res) data_res.columns = data.columns return data_res 一期的内容就这样吧，我感觉也没有啥好说的，都是数据分析挖掘的一些基本操作，我只是为了以后能够复用模版化了，下面贴一个全量我做预处理的过程，没啥差异，整合了一下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220from __future__ import divisionimport numpy as npimport pandas as pdfrom sklearn import preprocessingfrom sklearn.cross_validation import train_test_splitfrom sklearn.neighbors import NearestNeighborsimport sys__author__ = 'slade_sal'__time__ = '20171128'def change_data_format(data): # 以下预处理都是基于dataframe格式进行的 data_new = pd.DataFrame(data) return data_new# 去除空值过多的featuredef nan_remove(data, rate_base=0.4): all_cnt = data.shape[0] avaiable_index = [] # 针对每一列feature统计nan的个数，个数大于全量样本的rate_base的认为是异常feature，进行剔除 for i in range(data.shape[1]): rate = np.isnan(np.array(data.iloc[:, i])).sum() / all_cnt if rate &lt;= rate_base: avaiable_index.append(i) data_available = data.iloc[:, avaiable_index] return data_available, avaiable_index# 离群点盖帽def outlier_remove(data, limit_value=10, method='box', percentile_limit_set=90, changed_feature_box=[]): # limit_value是最小处理样本个数set，当独立样本大于limit_value我们认为非可onehot字段 feature_cnt = data.shape[1] feature_change = [] if method == 'box': for i in range(feature_cnt): if len(pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &gt;= limit_value: q1 = np.percentile(np.array(data.iloc[:, i]), 25) q3 = np.percentile(np.array(data.iloc[:, i]), 75) # q3+3/2*qi为上截距点，详细百度分箱图 top = q3 + 1.5 * (q3 - q1) data.iloc[:, i][data.iloc[:, i] &gt; top] = top feature_change.append(i) return data, feature_change if method == 'self_def': # 快速截断 if len(changed_feature_box) == 0: # 当方法选择为自定义，且没有定义changed_feature_box则全量数据全部按照percentile_limit_set的分位点大小进行截断 for i in range(feature_cnt): if len(pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &gt;= limit_value: q_limit = np.percentile(np.array(data.iloc[:, i]), percentile_limit_set) data.iloc[:, i][data.iloc[:, i] &gt; q_limit] = q_limit feature_change.append(i) else: # 如果定义了changed_feature_box，则将changed_feature_box里面的按照box方法，changed_feature_box的feature index按照percentile_limit_set的分位点大小进行截断 for i in range(feature_cnt): if len(pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &gt;= limit_value: if i in changed_feature_box: q1 = np.percentile(np.array(data.iloc[:, i]), 25) q3 = np.percentile(np.array(data.iloc[:, i]), 75) # q3+3/2*qi为上截距点，详细百度分箱图 top = q3 + 1.5 * (q3 - q1) data.iloc[:, i][data.iloc[:, i] &gt; top] = top feature_change.append(i) else: q_limit = np.percentile(np.array(data.iloc[:, i]), percentile_limit_set) data.iloc[:, i][data.iloc[:, i] &gt; q_limit] = q_limit feature_change.append(i) return data, feature_change# 空feature填充def nan_fill(data, limit_value=10, countinuous_dealed_method='mean'): feature_cnt = data.shape[1] normal_index = [] continuous_feature_index = [] class_feature_index = [] continuous_feature_df = pd.DataFrame() class_feature_df = pd.DataFrame() # 当存在空值且每个feature下独立的样本数小于limit_value，我们认为是class feature采取one_hot_encoding； # 当存在空值且每个feature下独立的样本数大于limit_value，我们认为是continuous feature采取mean,min,max方式 for i in range(feature_cnt): if np.isnan(np.array(data.iloc[:, i])).sum() &gt; 0: if len(pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &gt;= limit_value: if countinuous_dealed_method == 'mean': continuous_feature_df = pd.concat( [continuous_feature_df, data.iloc[:, i].fillna(data.iloc[:, i].mean())], axis=1) continuous_feature_index.append(i) elif countinuous_dealed_method == 'max': continuous_feature_df = pd.concat( [continuous_feature_df, data.iloc[:, i].fillna(data.iloc[:, i].max())], axis=1) continuous_feature_index.append(i) elif countinuous_dealed_method == 'min': continuous_feature_df = pd.concat( [continuous_feature_df, data.iloc[:, i].fillna(data.iloc[:, i].min())], axis=1) continuous_feature_index.append(i) elif len(pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &gt; 0 and len( pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &lt; limit_value: class_feature_df = pd.concat( [class_feature_df, pd.get_dummies(data.iloc[:, i], prefix=data.columns[i])], axis=1) class_feature_index.append(i) else: normal_index.append(i) data_update = pd.concat([data.iloc[:, normal_index], continuous_feature_df, class_feature_df], axis=1) return data_update# onehotencodingdef ohe(data, limit_value=10): feature_cnt = data.shape[1] class_index = [] class_df = pd.DataFrame() normal_index = [] # limit_value以下的均认为是class feature，进行ohe过程 for i in range(feature_cnt): if len(pd.DataFrame(data.iloc[:, i]).drop_duplicates()) &lt; limit_value: class_index.append(i) class_df = pd.concat([class_df, pd.get_dummies(data.iloc[:, i], prefix=data.columns[i])], axis=1) else: normal_index.append(i) data_update = pd.concat([data.iloc[:, normal_index], class_df], axis=1) return data_update# smote unbalance datasetdef smote(data, tag_label='tag_1', amount_personal=0, std_rate=5, k=5,method = 'mean'): cnt = data[tag_label].groupby(data[tag_label]).count() rate = max(cnt) / min(cnt) location = [] if rate &lt; 5: print('不需要smote过程') return data else: # 拆分不同大小的数据集合 less_data = np.array(data[data[tag_label] == np.array(cnt[cnt == min(cnt)].index)[0]]) more_data = np.array(data[data[tag_label] == np.array(cnt[cnt == max(cnt)].index)[0]]) # 找出每个少量数据中每条数据k个邻居 neighbors = NearestNeighbors(n_neighbors=k).fit(less_data) for i in range(len(less_data)): point = less_data[i, :] location_set = neighbors.kneighbors([less_data[i]], return_distance=False)[0] location.append(location_set) # 确定需要将少量数据补充到上限额度 # 判断有没有设定生成数据个数，如果没有按照std_rate(预期正负样本比)比例生成 if amount_personal &gt; 0: amount = amount_personal else: amount = int(max(cnt) / std_rate) # 初始化，判断连续还是分类变量采取不同的生成逻辑 times = 0 continue_index = [] # 连续变量 class_index = [] # 分类变量 for i in range(less_data.shape[1]): if len(pd.DataFrame(less_data[:, i]).drop_duplicates()) &gt; 10: continue_index.append(i) else: class_index.append(i) case_update = pd.DataFrame() while times &lt; amount: # 连续变量取附近k个点的重心，认为少数样本的附近也是少数样本 new_case = [] pool = np.random.permutation(len(location))[0] neighbor_group = less_data[location[pool], :] if method == 'mean': new_case1 = neighbor_group[:, continue_index].mean(axis=0) # 连续样本的附近点向量上的点也是异常点 if method =='random': new_case1 =less_data[pool][continue_index] + np.random.rand()*(less_data[pool][continue_index]-neighbor_group[0][continue_index]) # 分类变量取mode new_case2 = [] for i in class_index: L = pd.DataFrame(neighbor_group[:, i]) new_case2.append(np.array(L.mode()[0])[0]) new_case.extend(new_case1) new_case.extend(new_case2) case_update = pd.concat([case_update, pd.DataFrame(new_case)], axis=1) print('已经生成了%s条新数据，完成百分之%.2f' % (times, times * 100 / amount)) times = times + 1 data_res = np.vstack((more_data, np.array(case_update.T))) data_res = pd.DataFrame(data_res) data_res.columns = data.columns return data_res# 数据分列def reload(data): feature = pd.concat([data.iloc[:, :2], data.iloc[:, 4:]], axis=1) tag = data.iloc[:, 3] return feature, tag# 数据切割def split_data(feature, tag): X_train, X_test, y_train, y_test = train_test_split(feature, tag, test_size=0.33, random_state=42) return X_train, X_test, y_train, y_testif __name__ == '__main__': path = sys.argv[0] data_all = pd.read_table(str(path)) print('数据读取完成！') # 更改数据格式 data_all = change_data_format(data_all) # 删除电话号码列 data_all = data_all.iloc[:, 1:] data_all, data_avaiable_index = nan_remove(data_all) print('空值列处理完毕！') data_all, _ = outlier_remove(data_all) print('异常点处理完成！') data_all = nan_fill(data_all) print('空值填充完成！') data_all = ohe(data_all) print('onehotencoding 完成！') data_all = smote(data_all) print('smote过程完成！') feature, tag = reload(data_all) X_train, X_test, y_train, y_test = split_data(feature, tag) print('数据预处理完成！') 大家自取自用，这个也没啥好转载的，没啥干货，只是方便大家日常工作，就别转了，谢谢各位编辑大哥了。 最后，感谢大家阅读，谢谢。 大家自取自用，这个也没啥好转载的，没啥干货，只是方便大家日常工作，就别转了，谢谢各位编辑大哥了。 最后，感谢大家阅读，谢谢。]]></content>
      <categories>
        <category>代码集合</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见算法工程师面试题目整理(二)]]></title>
    <url>%2F2017%2F12%2F01%2F%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86-%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[接着上回写的《总结：常见算法工程师面试题目整理(1)》,继续填接下来的坑。 boost算法的思路是什么样的？讲一下你对adaboost 和 gbdt的了解？答：boost的核心思想不同于bagging，它在基于样本预测结果对照与真实值得差距，进行修正，再预测再修正，逐步靠近正确值。 我对adaboost和gbdt了解的也不算很全面：大概的梳理如下：不足：1.adaboost存在异常点敏感的问题2.gbdt一定程度上优化了adaboost异常点敏感的问题，但是存在难以并行的缺点3.两者的目标都是优化bias，必然导致训练出来的数据var的不稳定 亮点：1.发现非线性的特征关系，网格化的切分feature2.拟合的效果相较于其他分类器更加精准，且训练参数较少 Adaboost:adaboost初始数据权重都是1/M，然后通过训练每一个弱分类器Classifier使得在每一次y_pred误差最小，得到每一个弱Classifier的权重方法对：（αi，yi）然后提高错分了的数据的权重，降低正确分类的数据权重，循环训练，最后组合最后若干次的训练弱Classifier对，得到强分类器。其中，αi由误差决定：该弱分类器分类错误率em越大，则该若分类器作用越小。1.剖析了原理之后，我们发现，这样做对异常点非常敏感，异常点非常容易错分，会影响后续若干个弱分类器 gbdt:gbdt的核心在于下面这个公式：L（y，y_pred）：预测值与实际值间的误差F(x):前若干个弱分类器的组合关键的在于当前预测结果=对前若干个弱分类器+当前弱分类器修正，所以对前若干个分类器组合求偏导的方向进行梯度处理，保证L（x）出来的值最小。这边结果在于你选取什么样的误差函数： Loss即为损失函数，Derivative即为导数除此之外，在每一步弱分类器构建的同时，它还考虑了正则化：Ω=入T+μ*linalg.norm(f(xi))T为子叶节点数目，同时也对预测结果得分的值进行了l1或者l2压缩，避免过拟合。 我个人更喜欢用xgboost，在求解速度上，对异常值处理上面都要比gbdt要快，而且基于R、python版本都有package。 听说你做过用户关系，你用的什么方法？社群算法有了解，讲讲什么叫做Modularity Q？1.我用的是Jaccard相关。比如，用户1一共收过150个红包，发了100个红包，其中20个被用户2抢过用户2一共收过100个红包，发了50个红包，其中30个被用户1抢过similarity(user1=&gt;user2)=(30+20)/(150+100)similarity(user2=&gt;user1)=(30+20)/(50+100)similarity(user2=&gt;user1)=(30+20+30+20)/(150+100+50+100) 2.社区算法主要是用来衡量用户关系网中，不同用户、链接、信息之间的相似程度。本来这边我准备讲pagerank的，结果被打断了，说需要讲内部结构相关的，其实我觉得PageRank这边来描述更加合适。不过，无所谓，我这边谈的是一个很基本的叫做：Kernighan-Lin算法（后面简称了KL算法）KL算法中，先随机切分原数据集群，得到不同社区集，随机交换不同社区集内的不同点，观察优化值得变化程度是否为正向，循环即可。 共需执行次数：循环次数x集群A内点的个数x集群B内点的个数 感觉这边答的不行，被嫌弃了，有知道的大神可以自行去研究一下相关的社区算法，我这边只了解PageRank和LK。 3.Q-modularity： 这个简单，E：关系点连接线之间的个数，I：关系点连接线两端都在社群内的数量，O：关系点连接线有至少一端在社群外的连接线的数量 这个指标是用来衡量社群划分的稳定性的，讲真我也没用过，只是在周志华的算法的书上看过。 如果让你设计一套推荐算法，请说出你的思路？讲真，这个点，我起码说了有25分种，对面的面试管也很耐心的听完了，并且还给予了很多点的反馈，个人觉得非常受到尊重，我下面细节梳理一下。首先，我个人非常赞同阿里现在的推荐算法这边的设计思路：推荐＝人＋场景＋物其中，人＝新用户＋老用户＋综合特征＋…场景＝属性偏好＋周期属性＋黏度偏好＋…物＝相关性＋物品价值＋特殊属性＋…接下来，我简单的剖析三个最常见也最重要的问题： 冷启动很多人有一种错觉，只要业务上线时间长了就不存在所谓的冷启动问题，实则不是，新用户是持续进入的、流失用户也是在增长的、很多盲目用户（没有有价值行为）等等都可以归纳为冷启动问题，这类问题的核心在于你可用的数据很少，甚至没有，我这边采取的是热门推荐的方法。然而在热门推荐的算法中，我这边推荐一些方法：威尔逊区间法：综合考虑总的行为用户中，支持率与支持总数的平衡hacker new排序：综合考虑时间对支持率的影响pagerank排序：考虑用户流向下的页面权重排序梯度效率排序：考虑商品增速下的支持率的影响…方法很多，但是核心的一点是热门推荐是冷启动及实时推荐必不可少的一环，优化好实时推荐的算法是占到一个好的推荐算法的30%以上的权重的，切忌0推荐。 不同种算法产生的推荐内容互不冲突这个是苏宁易购的首页推荐位，1、2、3分别是三个推荐位，我们在做算法的时候常常会特别注意，不能用太多相关性比较高的变量，会产生共线性，但在推荐内容上，“58同城”的算法推荐团队之前有一份研究证明，同一个页面上由不同算法产出的推荐结果不存在相互影响。所以，我非常赞同不同的算法产出不同的结果同时展示，因为我们不知道对目标用户是概率模型、距离模型、线性模型等不同模型中哪个产出的结果更加合适。关于常用的推荐算法，我之前梳理过，这边也不再多加重复，需要仔细研究的可看我上面的图，或者看我之前的文章：《深度学习下的电商商品推荐》、《偏RSVD及扩展的矩阵分解方法》等等 你的对象是用户，不是冰冷的数字我在苏宁呆的时间不长，但是我有个感觉，身边算法工程师很容易把自己陷入数字陷阱，近乎疯狂去用各种算法去拟合当前的用户数据，以求得得到高的ctr或者转化率。不同的推荐场景需要使用不同的用户行为。举例假设存在经典的关系：买了炸鸡和番茄酱的用户，接下来的一周有35%的用户会来买汽水。所以，很多工程师会选择只要买了炸鸡和番茄酱的用户，就弹窗汽水，因为就35%的百分比而言，是非常高的支持度了。其实只要有用户画像的支持就会发现，这35%的用户中，80%的都是年龄在青少年，如果在推送之前做一个简单的逻辑判断只针对所有青少年进行推送汽水的话，35%轻而易举的上升到了70%，这是任何算都无法比拟的。 最上方的橙黄色的横条中，橙色代表原始的目标用户，黄色代表非目标用户，假设我们知道黑色方框所框选的用户的转化率达到最小置信度的时候，我们可以通过特征映射、非线性分解、用户画像刻画等不同方法得到左右完全不同的新的用户分布，在同样的用户框选占比下，效果也是完全不同的。真实推荐中，比如针对用户冬装推荐，我不仅仅以用户近期的搜索、浏览、购买商品等行为判断用户的偏好，我也根据他夏天的购买风格款式、他的年龄、生理性别、浏览性别等综合判断他可能会买什么。推荐算法才不会是冷漠的。 至于想要了解具体实现算法及创新的一些想法可以看上方的脑图，但是我觉得那并不是最重要。 什么是P、NP、NP-Hard、NP-Complete问题？P：很快可以得出解的问题NP：一定有解，但可很快速验证答案的问题 后面两个我没答出来，网上搜了下，分享下：NP-Hard：比所有的NP问题都难的问题NP-Complete：满足两点： 是NP-Hard的问题 是NP问题 个人不喜欢这种问题。 常见的防止过拟合的方法是什么？为什么l1、l2正则会防止过拟合？当被问了第一个问题的时候，我愣了下，因为我觉得挺简单的，为什么要问这个，我感觉接下来有坑。我回答的是：先甩出了下面的图解释了一波欠拟合、正常、过拟合：然后举了几个例子： 针对error递归的问题，l1，l2正则化 扩充数据量，使得数据更加符合真实分布 bagging等算法技巧 当问到为什么的时候，我觉得自己回答的不好，有点蛋疼：我说的是，l1以：l2以：l1中函数与约束点偏向相切于四个端点，端点处压缩了某个特征＝0；l2中函数与约束点偏向相切于圆，会造成某些特征值压缩的接近于0；根据奥卡姆剃刀原理，当两个假说具有完全相同的解释力和预测力时，我们以那个较为简单的假说作为讨论依据，而通常过拟合的模型的特征维度过高过多，所以一定程度可以缓解过拟合。 面试管以一种奇怪的眼神看着我，然后表示他其实想让我通过先验概率解释，不过我这样说仿佛也有道理。我回来之后就研究了一下，比如l2，大致如下：首先，我们确定两点：l2，其实就给了系数w一个期望是0，协方差矩阵是 1/alpha的先验分布。l1对应的是Laplace先验。 我们相当于是给模型参数w设置一个协方差为1/alpha 的零均值高斯分布先验。根据贝叶斯定律： 这一步我没看懂，我计算了半天也没由最大似然估计算出下面这个式子，有会的朋友可以私信我一下。 有了上面的式子就很简单了，alpha在0-正无穷之间，如果a接近0的话，左侧及为正常的MSE也就是没有做任何的惩罚。如果alpha越大的话，说明预测值越接近真实值的同时，协方差也控制的很小，模型越平稳，Var也越小，所以整体的模型更加有效，避免了过拟合导致训练数据拟合效果很差的问题。 到这里，我觉得常见的算法题目都讲完了，很多简单的知识点我没有提，上面这些算是比较经典的，我没答出来的，希望对大家有所帮助，最后谢谢大家的阅读。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见算法工程师面试题目整理(一)]]></title>
    <url>%2F2017%2F12%2F01%2F%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E6%95%B4%E7%90%86-%E4%B8%80%2F</url>
    <content type="text"><![CDATA[最近抽风，出去面试了不少公司，和不少算法工程师招聘的朋友有所交流，整理了相关比较有意思的题目，供大家参考： 附：每题视情况给出答案或答案简介，如有疑问，欢迎私信 基于每日用户搜索内容，假设只有少量已知商品的情况下，如何根据用户搜索内容获取平台内没有的新商品？ 答案：这是一条类似于分词“新词获取问题”，答案是基于信息熵＋聚合度。 这边需要考虑排除，首先做stop词库，先去除形容词等。信息熵：比如用户搜索“曲面显示屏 白色”，假设现在我们的商品库中没有显示屏这个商品，我们需要判断“显示屏”是否是潜在的商品，我们需要考虑“显示屏”左词、右词出现的可能。换句话说，如果大家都在搜索“显示屏”商品的话，会出现大量的“便宜显示屏”、“可旋转显示屏”、“显示屏 黑色”等搜索短语，根据信息熵计算公式-p∑logp，“显示屏”前后出现的词语类别越多，信息熵越大，代表用户搜索的需求越旺盛，“显示屏”越有可能是没有的商品。 聚合度：根据信息熵的理论也会出现“显示”等高频出现的干扰词，再用聚合度，比如先计算出p(“显示”)、p(“屏”)、或p(“显”)、p(“示屏”)的概率，如果“显示”是一个高频合理的搜索词的话，p(“显示”)*p(“屏”)应该远远大于p(“显示屏”)，p(“显”)＊p(“示屏”)应该远远大于p(“显示屏”)的概率，而实际电商搜索中，用户连贯搜索“显示屏”的概率才是远超其它。 为什么logistic回归的要用sigmoid函数？优缺点？答案：优点：1.数据压缩能力，将数据规约在［0，1］之间2.导数形式优秀，方便计算缺点：1.容易梯度消失，x稍大的情况下就趋近一条水平线2.非0中心化，在神经网络算法等情况下，造成反向传播时权重的全正全负的情况。 为什么要用？答案1:logistic是基于Bernoulli分布的假设，也就是y|X~Bernoulli分布，而Bernoulli分布的指数族的形式就是1/(1+exp(-z))其实还有一个答案二，我当时没想起来，如就是：对于logistic多分类而言，x1、x2、…、xn，属于k类的概率正比于： 我们回到2类：x1、x2、…xn属于1的概率是： 分子分母同除以分子极为1/(1+exp(-z))，z＝w11-w01，个人觉得这样的证明才有说服力 对比牛顿法、梯度下降法的关系讲真，大学学完牛顿法就丢了，一时没回答出来，回来整理如下：答案：牛顿法快于梯度下降法，且是梯度下降法的极限。 首先，我们有展开式：f′(x+Δx)=f′(x)+f″(x)∗ΔxΔx=−μ∗f′(x)合并两个式子，有：f′(x+Δx)=f′(x)+f″(x)∗(−μ∗f′(x))令f′(x+Δx)＝0，μ＝1/f″(x)，极为牛顿法在随机梯度下降中的μ 两个盒子，50个红球，50个白球，问如何放球，抽到红球的概率最高？（每个盒子必须有球）答案：一个盒子1个红球，另外一个盒子剩余的99个球 先假设第一个盒子放x个红球，y个白球，另外的一个盒子里面就有50-x红球，50-y个白球.求的目标函数：p＝1/2(x/(x+y))+1/2((50-x)/(100-x-y))subject to. x+y&gt;0 &amp; 100-x-y&gt;0 常规解法如上，被坑了一手的是，面试的说没有常规解，我回来思考了半天，可能是盒子里面的排练顺序有差异，上层的抽取概率&gt;下层的抽取概率，所以需要通过EM算法，先得到若干次抽取的结果下，每层的最大概率密度函数，再结合上述的结果去回答。 常见的正则化有是么，有什么作用，为什么l1是会把feature压缩到0而l2做不到？答案：(1)l1,l2正则化l1对应python里面numpy.linalg.norm(ord=1)形如|w1|+|w2|+|w3|+…l2对应python里面numpy.linalg.norm(ord=2)形如w1^2+w2^2+w3^2+… (2)防止过拟合其它防止过拟合的方法还有：1.增加数据量2.采取bagging算法，抽样训练数据 (3)画图解决** 左边的l1，右边的l2，l1在作图只要不是特殊情况下与正方形的边相切，一定是与某个顶点优先相交，那必然存在横纵坐标轴中的一个系数为0，起到对变量的筛选的作用。l2的时候，其实就可以看作是上面这个蓝色的圆，在这个圆的限制下，点可以是圆上的任意一点，所以q＝2的时候也叫做岭回归，岭回归是起不到压缩变量的作用的，在这个图里也是可以看出来的。 分类模型如何选择？如何判断效果？如何计算AUC？你最熟悉的ensemble Classification model是什么？我这边参考了《Do we Need Hundreds of Classifiers to Solve Real World Classification Problems》里面的结论，有兴趣的自行去搜答案：整体上讲：数据量越大，神经网络越好；维度越多，bagging算法越优秀；数据量上不多不少的情况下，SVM效果最好；常用判断：roc、auc、ks、f1值、recall等；AUC计算方法：roc曲线下方的面积积分即可，或者大数定律的投点实验 最熟悉的集成分类模型，我说的是randomforest，详述了原理及实际应用的注意点，后来我问了面试管，主要在这块想了解的是实际解决的相关项目的真实性：1.randomforest是由若干颗cart树构成的，每棵树尽情生长不枝剪，最后采取加权投票或者均值的方式确定输出值2.每棵树的数据是采取bagging式的随机抽取特征及数据样本，两颗树之间的数据有可能会重复3.一般流程会先以sqrt(feature_number)作为每次输入的特征数，采取grid_search的方法观察tree的数量由0-500，oob的变化这边被打断了，解释什么叫做oob，也就是out of bag，每次抽取的数据样本进行训练，没有被抽取到的数据作为检验样本，检验样本上的误差就叫做oob4.根据实际要求的精度上后期可以跟进调整：每次输入的特征个数、每棵树的最大深度、每个节点的分支方式（GINI还是信息增益率）、子节点最少数据量、父节点最少数据量等等这边又被打断了，问，什么叫做信息增益率？首先熵的计算如下：信息增益如下：比如14个人，好人5个坏人9个。这14个人被通过性别划分开，10个男性中3个坏人，7个好人；4个女性中2个坏人，2个好人。 信息增益就是:IGain＝(-5/14)log(5/14)+(-9/14)log(9/14)-(10/14(-3/10log(3/10)-7/10log(7/10))+4/14(-1/2log(1/2)-1/2log(1/2)))看到这样的计算方式，必然会存在问题，假设我们身份证为区分类别的化，每个身份证号码都是独一无二的，势必存在存在1/n*log(1)=0这样的最佳划分，但是这样的结果就是将所有的情况分别作为子节点，很明显没有意义，所以引出下面的信息增益率。 信息增益率就是:比如上面分人的例子，Info＝-10/14log(10/14)-4/14log(4/14)很明显也可以看出，当你划分的子类别越多，你的info会越大，Gain_ratio就越小，信息增益率就越低，惩罚了刚才身份证分类这种行为。 这也是id3和c4.5之间最大的差异，c4.5以信息增益率代替率id3里面的信息增益，除此之外，id3只能对分类变量处理而c4.5既可以分类变量也可以连续变量，还是很强的，同时他们都可以做多分类，而后续的cart等做多分类的成本会增加（叠加的方式） 其实，这些都很基础但是时间长了，真的很绕人，我也是先自己默默的在纸上画了挺久才和面试管聊，有点出乎我的意料。 循环神经网络中介绍一个你熟悉的？我说的是LSTM。首先，先跑出了循环的机制，同时点明了RNN潜在隐藏节点对output的影响，做了下图： 及当前的预测结果，与input及上次的layer1节点下的结果相关。 正向循环：节点1的值 = sigmoid(np.dot(输入参数,神经元1) + np.dot(上次节点1的值,潜在神经元))输出值＝sigmoid(np.dot(节点1的值,神经元2)) 误差计算：真实y－输出值 delta：节点2处的deltas=误差计算*sigmoid(np.dot(节点1的值,神经元2))／(1-sigmoid(np.dot(节点1的值,神经元2))) 反向修正神经元：神经元2 += (节点1的值).T.dot(节点2处的delta)潜藏神经元 += (上次的节点1的值).T.dot(节点1处的delta)神经元1 += 输入值.T.dot(节点1处的delta) 核心强调了：sigmoid(np.dot(输入参数,神经元1) + np.dot(上次节点1的值,潜在神经元))，输出值与输出值及上次节点1处的输入值有关。然后讲了简单的在语义识别的实际作用。 kmeans的原理及如何选择k？如何选择初始点？原理是送分题，原理：在给定K值和K个初始类簇中心点的情况下,把每个点(亦即数据记录)分到离其最近的类簇中心点所代表的类簇中，优点在于易于理解和计算，缺点也是很明显，数据一多的情况计算量极大，且标签feature定义距离的难度大。 K的选择，我答的一般，欢迎大家补充，1.根据具体的业务需求，实际需求确定最后聚成的类的个数2.grid_search去试，看那种距离下，损失函数最小（其实这样回答不好，数据量大的情况下，机会不可能）这边的损失函数类别较多，可能包括组内间距和／组外间距和等3.随机抽样下的层次聚类作为预参考理论上，随机采样的数据分布满足原来的数据集的分布，尤其是大量采样次数下的情况，针对每一个较小的数据集合采取层次聚类确定最后的聚类个数，再针对原始的数据集合进行kmeans聚类 如何选取初始点？这个问题我被问过好多次，其实，不管是r或者python里面，或者大家日常使用中都是默认的随机选取，然后通过多次k-折等方法不断的去迭代，其实这样存在的问题就是如果初始点随机选取的有误，导致无论这么迭代都得不到最优的点，如： 在随机初始点的情况下，红色区域的部分点被蓝色和绿色侵占为己点，修正初始点，也就是将随机初始点的聚类中心全部上移的情况下，蓝色点区收回了原属于自己的点区。之前我恶补过一片论文：《K-means 初始聚类中心的选择算法》，里面提出了两个指标来衡量：1.k-dist某个点 p 到它的第k 个最近点的距离为点 p 的 k-dist 值。点的 k-dist 半径范围内至少包含k + 1 个点，理论上同一个聚类中改变k值不会引起k-dist值明显变化。将 k-dist 值由小到大排序，a、b、c表示平缓点，d，e，f为跃迁点。2.DK图k-dist 图中相邻两点的 k-dist 值之差记为 DK。k-dist 图中相邻两点pm和pm－1的 k-dist的差为DKm=k-distm －k-distm－1 ( m ＞ 1) 。由于 k-distm 非递减，显然 DKm ＞ 0。DK 值接近的连续邻近点处于 k-dist 图的同一条平缓曲线上，即处于同一个密度层次; DK 值大幅跳动的点处于密度转折曲线或噪声曲线上。3.选择对 DK 值从小到大排序，得到 DK 标准范围δ。依据 DK 标准范围内对应的数据点的分布情况，在 k-dist 图中找出 k’ 个平缓曲线，代表 k’ 个主要密度水平。选择每个密度水平的第一个点作为初始聚类中心。重复若干次，得到若干组的优化聚类中心，在根据优化聚类中心组下的组内间距和／组外间距和判断那个点组为最优点组。 其实这样的开销也挺大的，目前也没有看到其它比较易理解的kmeans的初始点计算的方式。 大致讲解一下最优化中拉格朗日乘子法的思路？KKT是什么？当我们求解一个函数的最小值，且这个函数也被某些确定的限制条件限制的时候： 我们可以将限制条件加入f(x)中一同进行后续的偏导计算： 至于KKT我了解的其实不多，也是回来之后恶补了一下，通过例子入手： 求解上面这个问题的化，我们需要考虑构造两个约束变量a1，b1，使得h1(x，a1)＝g1(x)＋a1^2＝a－x＋a1^2=0h2(x，b1)＝g2(x)＋b1^2＝b－x＋b1^2=0在根据普通拉格朗日乘子的方法对下面公式的每一项求偏导： 这个条件就是KKT条件其实我觉得，http://www.cnblogs.com/zhangchaoyang/articles/2726873.html，这篇文章写的挺好的，想要详细了解的可以仔细参考一下。 听说你做过风控，异常点检测你用过什么办法？之前正好整理过，内心大喜：1.6个西格玛的原理2.箱式图大于3/2QI＋Q3，小于Q1－3/2Qi3.基于距离离群检测（聚类），包括欧式、马氏距离、街道距离这边被打断了，问了马氏距离的细节，好处：追问了协方差Sigma怎么算：Cov(X,Y)=E(XY)-E(X)E(Y)追问了什么时候用马氏距离比较好：举例很有名的曲线分布图，如下： 4.pca的基于特征值压缩的方法5.基于isolation forest识别的方法这边被追问了一次原理：1234567method:1.从原始数据中随机选择一个属性feature；2.从原始数据中随机选择该属性的下的一个样本值value；3.根据feature下的value对每条记录进行分类，把小于value的记录放在左子集，把大于等于value的记录放在右子集；4.repeat 1-3 until： 4.1.传入的数据集只有一条记录或者多条一样的记录； 4.2.树的高度达到了限定高度； 以s(x,n)为判断数据是否异常的衡量指标。 其中，h(x)为x对应的节点深度，c(n)为样本可信度，s(x,n)~[0,1]，正常数据来讲s(x,n)小于0.8，s(x,n)越靠近1，数据异常的可能性越大。 详细的可以参见我的另一篇博客：http://www.jianshu.com/p/ac6418ee8e3f 本来准备一次写完的，后来写着写着发现真的挺多，准备写个系列，最后谢谢大家的阅读。]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVM理论解析及python实现]]></title>
    <url>%2F2017%2F12%2F01%2FSVM%E7%90%86%E8%AE%BA%E8%A7%A3%E6%9E%90%E5%8F%8Apython%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[关于常见的分类算法在不同数据集上的分类效果，在《Do we Need Hundreds of Classifiers to Solve Real World Classification Problems?》这个篇论文上有比较完善的总结，因为文章内容比较长，这边我总结了下我认为比较关键的一些结论： 仅仅参考论文评价我们常用的： 神经网络的效果最好，13.2%的数据集中取得第一 SVM的效果其次，10.7%的数据集中取得第一 Bagging和Boost紧随其后，9%~10%左右的数据集取得第一 Elastic Net等的线性算法效果普通，5%-7%的数据集上取得第一 附加一些我个人平时调参的经验及感悟： 神经网络拟合的效果好是基于大量的数据量上，如果数据集较小，训练结果通常不如上述其他算法；除此之外，神经网络的训练成本高，关于控制非线性变换的隐藏层层数，控制线性力度的节点个数的设置需要大量的历史经验，相对成本非常高。 SVM对数据集合量以及维度没有很高的要求，而且可以解决线性问题（kernel=linear），非线性问题（kernel=RBF等），而且相对来说效果优秀。但是SVM的核心是计算最大分隔的间隔，如果全都是分类变量，效果会受一定的影响，而且需要额外的操作才能获取概率结果。 Bagging和Boost，能够解决非线性问题，Bagging基于抽样抽特征，控制Var的情况下降低Bias；Boost基于N个弱分类器的强化组合，控制Bias的情况下降低Var，对数据格式的要求也很低，实现上比较友好。缺点可能就是太一般，没有专业领域的亮点。 Elastic Net等线性回归算法，对数据量数据维度没有什么要求，部分算法会自己压缩feature，简单易操作，相比于上述任何一个算法都好实现，除此之外，还可以得到概率结果。缺点就是效果较差，如果在feature和label没有线性关系的时候无法得到理想结果。 除了上述的方法，还有比如KNN、线性判别分析、Naive Bayes等方法，每个都有自己适用的场景，也但是通常不做首要考虑的分类算法。 针对其中的SVM，本文接下来和大家解析三个方面：1.感知机、线性感知机、核感知机的理论概览2.如何利用python中的sklearn快速的实现svm分类3.SMO方法的核心功能实现 如果你只是想快速了解分类算法的概览，方便面试或者日常“交流”，到此就可以不用往下看了。如果你是数据分析师或者软件工程师，只是想快速了解如果使用，直接跳到2。如果你是机器学习工程师，需要对整个算法有个了解，贯穿整个SVM过程，直接看1，2。如果你是算法工程师，需要重构算法，或在当前解决核函数计算瓶颈的，请全文阅读，并阅读推荐书籍。 让我们开始正文： 感知机、线性感知机、核感知机的理论概览感知机我们日常说的SVM其实只是一个感知机，也就是没有任何的核函数的情况。 上面图中，对于二维数据来说，平面π1，π2，π3都可以将红色和蓝色的点给划分开。对于多维数据来说，这边的平面就可以引申为超平面，wx+b=0。 所以，我们可以说，对于数据集:如果我们可以得到超平面wx+b=0，使得y=1的点集合与y=-1的点的集合分隔在平面两边（如上图所示），那我们就说原始数据集D线性可分，wx+b=0为其超平面。 首先，我们定义损失函数为：L=max(-y(wx+b),0)，我们来看下，如果我们预测正确，y=1，我们预测的为wx+b&gt;0或者，y=-1，我们预测的为wx+b0,则不贡献梯度；否则，我们可以取-y(wx+b)为梯度，也就得到了上述的梯度公式。接下来的就是常规意义上的对w和b的偏导，然后梯度下降求极值。 线性感知机现在我们思考两个问题：a.上述的π1、π2、π3都是感知机，如何选取最优？b.下面这张图线性不可分，如何解决？ 我们先来看，平面π1外任意点到平面的距离如何计算：假设任意点为X(x，y)，垂点X1(x1，y1)，垂点在π1平面(wx+b=0)上，所以，我们有X-X1=ρw，w为平面π1的法向量。所以，我们有：||X-X1||**2=ρw(X-X1)=ρ(wx+b-(wx1+b))=ρ(wx+b)=ρ(wx+b)在计算距离的时候，我们需要去归一化，无量纲化。不难看出，距离的计算方式为： 所以，我们在超平面选取的时候，需要考虑两点：(1)所以的分类结果要保持正确： (2)保证决策面离正负样本都极可能的远： 里面的min的作用是计算所有的点到平面π的最小距离，外面的max的作用是尽可能的让最小距离最大，保证决策面离正负样本都尽可能的远。 假设(x1,y1)到决策平面的距离最近，所有y1(wx1+b)&gt;=1,所以目标函数：max(1/||w||)，可以优化为min(||w||^2/2)。但是如果发生1.2节最开始的线性不可分的问题的时候，y1(wx1+b)&gt;=1就无法实现，所有我们需要加∆的容忍度，也就是变成了y1(wx1+b)&gt;=1-∆。既然加了∆，我们也需要对∆进行控制：∆=1-y1(wx1+b)，有更新后的目标函数： 这边的[]+记为神经网络中常用的ReLU函数。有了这个目标函数，接下来就是正常的梯度下降，偏导后求解的过程。 核函数下的感知机上面考虑的问题均是线性可分的问题，假设数据分布如下： 无论通过平面π1、π2、还是π3均无法做到线性的分割。而核函数的目的就是通过内积的形式，将低维度的数据映射到高维度，通常采取的方式是w=∑αx的形式，带回到原来的损失函数：比如普通感知机的： 比如线性感知机 K(xi,xj)常用的有：多项式核函数：(xi+xj+1)^p 径向基核函数：exp(-ρ||xi-xj||^2) 至于之后的计算，还是可以和之前一致，将上述选择的核函数代入损失函数后采取梯度下降的方法，高效计算方式SMO算法在第三模块会简单的梳理一遍。 以上我们就大概的了解了感知机，linear svm，kernel svm的损失函数的来源及构造细节等等，接下来我们来看下如何快速的使用。 如何利用python中的sklearn快速的实现svm分类在python的sklearn包中，有SVM的包，其中SVC是分类，SVR是回归，可以快速简单的上手，下面上code，并在注释中解释：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import pandas as pdimport numpy as npimport matplotlib.pyplot as pltfrom sklearn import svmfrom sklearn.cross_validation import train_test_split#data add,数据读取risk_data=pd.read_table('/Users/slade/Desktop/Python File/data/data_all.txt')#data check，删除无用的列risk_data = risk_data.drop('Iphone',axis=1)#data scale，数据归一化（必备的操作），上述理论中也体现归一化后的距离计算的原因risk_data_mm = risk_data.max()-risk_data.min()risk_data_scale = pd.DataFrame([])for i in range(len(risk_data.columns)):new_columns = (risk_data.iloc[:,i]-risk_data.iloc[:,i].min())/risk_data_mm[i]risk_data_scale = pd.concat([risk_data_scale,pd.DataFrame(new_columns)],axis=1)#split data（将数据分割成训练集和测试集）train_data,test_data = train_test_split(risk_data_scale,test_size = 0.3)#update_train,update_test（因为我的数据集是非常不平衡的，这边我采取了欠采样的方法）train_badcase = train_data[train_data['tag']==1]train_goodcase = train_data[train_data['tag']!=1]sample_value=(10*train_badcase.count()[0])train_goodcase_sample = train_goodcase.sample(n=sample_value)train_data_update = pd.concat([train_badcase,train_goodcase_sample],axis = 0)y=train_data_update['tag']x=train_data_update.iloc[:,1:len(train_data_update.columns)]#svm（linear、rbf、sigmoid为核的SVM）clf_linear = svm.SVC(kernel='linear').fit(x,y)clf_rbf = svm.SVC(kernel='rbf').fit(x,y)clf_sigmoid = svm.SVC(kernel='sigmoid').fit(x,y)#test，训练数据处理y_test = test_data[['tag']]x_test = test_data.iloc[:,1:len(test_data.columns)]#模型效果对比#lineartest_pred=clf_linear.predict(x_test)y_test.index = range(y_test.count())union_actual_pred = pd.concat([y_test,pd.DataFrame(test_pred)],axis = 1)#show the resultrecall = union_actual_pred[union_actual_pred.iloc[:,0]==1][union_actual_pred.iloc[:,1]==1].count()/union_actual_pred[union_actual_pred.iloc[:,0]==1].count()percison = union_actual_pred[union_actual_pred.iloc[:,0]==1][union_actual_pred.iloc[:,1]==1].count() / union_actual_pred[union_actual_pred.iloc[:,1]==1].count()correction = union_actual_pred[union_actual_pred.iloc[:,0]==union_actual_pred.iloc[:,1]].count()/union_actual_pred.iloc[:,0].count()print 'about the linear svm , the recall is %s' %recallprint 'about the linear svm , the percison is %s' %percisonprint 'about the linear svm , the correction is %s' %correction#rbftest_pred=clf_rbf.predict(x_test)y_test.index = range(y_test.count())union_actual_pred = pd.concat([y_test,pd.DataFrame(test_pred)],axis = 1)#show the resultrecall = union_actual_pred[union_actual_pred.iloc[:,0]==1][union_actual_pred.iloc[:,1]==1].count()/union_actual_pred[union_actual_pred.iloc[:,0]==1].count()percison = union_actual_pred[union_actual_pred.iloc[:,0]==1][union_actual_pred.iloc[:,1]==1].count() / union_actual_pred[union_actual_pred.iloc[:,1]==1].count()correction = union_actual_pred[union_actual_pred.iloc[:,0]==union_actual_pred.iloc[:,1]].count()/union_actual_pred.iloc[:,0].count()print 'about the linear svm , the recall is %s' %recallprint 'about the linear svm , the percison is %s' %percisonprint 'about the linear svm , the correction is %s' %correction#sigmoidtest_pred=clf_sigmoid.predict(x_test)y_test.index = range(y_test.count())union_actual_pred = pd.concat([y_test,pd.DataFrame(test_pred)],axis = 1)#show the resultrecall = union_actual_pred[union_actual_pred.iloc[:,0]==1][union_actual_pred.iloc[:,1]==1].count()/union_actual_pred[union_actual_pred.iloc[:,0]==1].count()percison = union_actual_pred[union_actual_pred.iloc[:,0]==1][union_actual_pred.iloc[:,1]==1].count() / union_actual_pred[union_actual_pred.iloc[:,1]==1].count()correction = union_actual_pred[union_actual_pred.iloc[:,0]==union_actual_pred.iloc[:,1]].count()/union_actual_pred.iloc[:,0].count()print 'about the linear svm , the recall is %s' %recallprint 'about the linear svm , the percison is %s' %percisonprint 'about the linear svm , the correction is %s' %correction 上述粗略的给出了如何快速的通过svm进行一次训练，现在就svc中的参数进行剖析：C:惩罚力度，C越大代表惩罚程度越大，越不能容忍有点集交错的问题kernel:核函数，常规的有‘linear’, ‘poly’, ‘rbf’, ‘sigmoid’, ‘precomputed’ ，默认的是rbfdegree:当poly为核函数时启动，默认是3gamma:当‘rbf’, ‘poly’ 和 ‘sigmoid’为核函数时的参数设置，默认的是特征个数的倒数probability：是否输出概率值shrinking:是否自启动tol:停止训练的容忍度max_iter：最大的训练次数class_weight:因变量的权重decision_function_shape:因变量的形式：ovo一对一, ovr一对多, 默认’ovr’根据自己的需求，对上述的参数进行grid_search即可完成快速训练任务。 3.SMO方法的核心功能实现首先，我们需要明确，SVM学习过程可以转化为以下问题： 至于什么是KKT条件，请参照总结：常见算法工程师面试题目整理(二)中的回答。求解的方式也是比较复杂，这主要以梳理流程为主，我们的目的就是找到一组αi满足上述的约束，然后再根据该组的αi求解到w和b即可。 求解αi的过程如下：12341.选择两个拉格朗日乘子αi和αj2.固定其他拉格朗日乘子αk(k不等于i和j)，只对αi和αj优化w(α)3.根据优化后的αi和αj，更新截距b的值4.充分1-3直到收敛 针对上面的过程存在2个问题a.为什么要选择两个乘子？而不是更加方便计算的一个？在原始的约束条件中，存在：如果只选择一个为变化乘子的化，根据其他确定的乘子，该变化乘子也无法变化。 b.如何选择两个乘子αi和αj？ 检验样本是否满足KKT条件也就是检验样本是否满足以下条件： 第一个参数αi优先检验0&lt;αj&lt;C也就是π3和π1平面上的点是否满足条件，如果全部满足条件，再检验全部数据集是否满足条件。 第二个参数αj则可以简单地随机选取，虽然这不是特别好，但效果已然不错。也可以通过最大化αi的误差与αj的误差之差的绝对值去判断，但是计算量会变大，因为又做了一次全量数据循环。 当αi和αj有了之后再去对b进行修正： 即可。 这边的代码比较复杂，我就不贴了，百度上很多实现了的版本。 总的来说，我们对svm的过程有了个浅尝辄止的了解，部分算法工程师需要要深入的了解其深刻完整的含义，仍需完整完善的学习，《统计学习方法 》一书讲的深入透彻，建议可以研读一下。 部分软件工程师在运用中可能需要各种版本的svm，这边也贴出地址，供参考Support Vector Machine for Complex Outputs 最后，谢谢大家的阅读。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>超平面分割</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[能够快速实现的协同推荐]]></title>
    <url>%2F2017%2F12%2F01%2F%E8%83%BD%E5%A4%9F%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8D%8F%E5%90%8C%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[对于中小型的公司，用户的数据量及公司产品的个数都是较小规模的，需要提供给用户的推荐系统实现的重心也从人性化变成了实现成本，协同推荐就是非常常见、有效且可以快速实现的方法，也是本文想介绍的。 常规的快速简单推荐系统实现方法不排除以下几种： 热门推荐所有人打开浏览的内容都一致，惊喜性会有所缺失，但是实现特别简单，稍加逻辑带给用户的体验感满足了基本需求。 SVD+推荐之前也讨论过实现方法了，附上链接：SVD及扩展的矩阵分解方法 基于模型推荐这个比较偏向业务场景，可以说是经典的场景化模型，之前写过一篇基于用户特征的偏好推荐，可以参考一下：苏宁易购的用户交叉推荐 协同推荐这个也是几乎每个公司都会用的，也是非常非常常见有效的算法之一 协同推荐介绍首先，我们先来了解一下什么叫做协同推荐。基于用户的协同过滤推荐算法是最早诞生的，1992年提出并用于邮件过滤系统，两年后1994年被 GroupLens 用于新闻过滤。一直到2000年左右，该算法都是推荐系统领域最著名的算法。算是非常古董级别的算法之一了，但是古董归古董，它的效果以及实现的成本却奠定了它在每个公司不可取代的地位。 基于用户的协同推荐123用户u1喜欢的电影是A，B，C用户u2喜欢的电影是A, C, E, F用户u3喜欢的电影是B，D 假设u1、u2、u3用户喜欢的电影分布如上，基于用户的协同推荐干了这么一件事情，它根据每个用户看的电影（A、B、C、…）相似程度，来计算用户之间的相似程度，将高相似的用户看过但是目标用户还没有看过的电影推荐给目标用户。 基于商品的协同推荐123456电影A被u1，u2看过电影B被u1，u3看过电影C被u1，u2看过电影D被u3看过电影E被u2看过电影F被u2看过 假设A～F电影被用户观影的分布如上，基于商品的协同推荐干了这么一件事情，它根据电影（A、B、C、…）被不同用户观看相似程度，来计算电影之间的相似程度，根据目标用户看过的电影的高相似度的电影推荐给目标用户。 看起来以上的逻辑是非常简单的，其实本来也是非常简单的，我看了下，网上关于以上的代码实现还是比较林散和有问题的，优化了python版本的code，并详细解释了每一步，希望，对初学者有所帮助。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#time 2017-09-17#author：shataowei#based-item#所要的基础包比较简单from collections import defaultdictimport mathimport timestartTime = time.time()#读取数据的过程#/Users/slade/Desktop/machine learning/data/recommender/u1.basedef readdata(location): list2item = &#123;&#125; #商品对应的用户列表(1:[[1,2],[2,3]]代表商品1对应用户1的行为程度为2,商品1对应的用户2的行为程度为3) list2user = &#123;&#125; #用户对应的商品列表(1:[[1,2],[2,3]]代表用户1对应商品1的行为程度为2,用户1对应的商品2的行为程度为3) f = open(location,'r') data = f.readlines() data = [x.split('\t') for x in data] f.close() for i in data: if int(i[1]) not in list2item.keys(): list2item[int(i[1])] = [[int(i[0]),int(i[2])]] else: list2item[int(i[1])].append([int(i[0]),int(i[2])]) if int(i[0]) not in list2user.keys(): list2user[int(i[0])] = [[int(i[1]),int(i[2])]] else: list2user[int(i[0])].append([int(i[1]),int(i[2])]) return list2item,list2user #list2item,list2user=readdata('/Users/slade/Desktop/machine learning/data/recommender/u1.base')## 基于item的协同推荐#0.将用户行为程度离散化：浏览：1，搜索：2，收藏：3，加车：4，下单未支付5#1.计算item之间的相似度：item共同观看次数/单item次数连乘#2.寻找目标用户观看过的item相关的其他item列表#3.计算其他item的得分：相似度*用户行为程度，求和#0 hive操作# 1.1统计各商品出现次数def itemcf_itemall(userlist = list2user): I=&#123;&#125; for key in userlist: for item in userlist[key]: if item[0] not in I.keys(): I[item[0]] = 0 I[item[0]] = I[item[0]] + 1 return I# 1.2计算相似矩阵def itemcf_matrix(userlist = list2user): C=defaultdict(defaultdict) W=defaultdict(defaultdict) #根据用户的已购商品来形成对应相似度矩阵 for key in userlist: for item1 in userlist[key]: for item2 in userlist[key]: if item1[0] == item2[0]: continue if item2 not in C[item1[0]].keys(): C[item1[0]][item2[0]] = 0 C[item1[0]][item2[0]] = C[item1[0]][item2[0]] + 1 #计算相似度，并填充上面对应的相似度矩阵 for i , j in C.items(): for z , k in j.items(): W[i][z] = k/math.sqrt(I[i]*I[z]) #k/math.sqrt(I[i]*I[z])计算相似度，其中k为不同商品交集，sqrt(I[i]*I[z])用来压缩那些热门商品必然有高交集的问题 return W#2.寻找用户观看的其他itemdef recommendation(userid,k): score_final = defaultdict(int) useriditem = [] for item,score in list2user[userid]: #3.计算用户的item得分，k来控制用多少个相似商品来计算最后的推荐商品 for i , smimilarity in sorted(W[item].items() , key = lambda x:x[1] ,reverse =True)[0:k]: for j in list2user[userid]: useriditem.append(j[0]) if i not in useriditem: score_final[i] = score_final[i] + smimilarity * score #累加每一个商品用户的评分与其它商品的相似度积的和作为衡量 #最后的10控制输出多少个推荐商品 l = sorted(score_final.items() , key = lambda x : x[1] , reverse = True)[0:10] return l#I = itemcf_itemall()#W = itemcf_matrix()#result_userid = recommendation(2,k=20)endTime = time.time()print endTime-startTime python来实现基于item的协同推荐就完成了，核心的相似度计算可以根据实际问题进行修改，整体流程同上即可，当然数据量大的时候分布式去写也是可以的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103#time 2017-09-17#author：shataowei#based-userfrom collections import defaultdictimport mathimport timestartTime = time.time()#读取数据#/Users/slade/Desktop/machine learning/data/recommender/u1.basedef readdata(location): list2item = &#123;&#125; #商品对应的用户列表 list2user = &#123;&#125; #用户对应的商品列表 f = open(location,'r') data = f.readlines() data = [x.split('\t') for x in data] f.close() for i in data: if int(i[1]) not in list2item.keys(): list2item[int(i[1])] = [[int(i[0]),int(i[2])]] else: list2item[int(i[1])].append([int(i[0]),int(i[2])]) if int(i[0]) not in list2user.keys(): list2user[int(i[0])] = [[int(i[1]),int(i[2])]] else: list2user[int(i[0])].append([int(i[1]),int(i[2])]) return list2item,list2user#list2item,list2user=readdata('/Users/slade/Desktop/machine learning/data/recommender/u1.base')#基于用户的协同推荐#0.先通过hive求出近一段时间（根据业务频率定义），用户商品的对应表#1.求出目标用户的邻居，并计算目标用户与邻居之间的相似度#2.列出邻居所以购买的商品列表#3.针对第二步求出了商品列表，累加所对应的用户相似度，并排序求top#0.hive操作#1.1求出目标用户的邻居，及对应的相关程度def neighbour(userid,user_group = list2user,item_group = list2item):neighbours = &#123;&#125; for item in list2user[userid]: for user in list2item[item[0]]: if user[0] not in neighbours.keys(): neighbours[user[0]] = 0 neighbours[user[0]] = neighbours[user[0]] + 1 return neighbors #通常来说，基于item的推荐对于商品量较大的业务会构成一个巨大的商品矩阵，这时候如果用户人均购买量较低的时候，可以考虑使用基于user的推荐，它在每次计算的时候会只考虑相关用户，也就是这边的neighbours(有点支持向量基的意思)，大大的降低了计算量。 #neighbours = neighbour(userid=2)#1.2就算用户直接的相似程度,这边用的余弦相似度：点积/模的连乘def similarity(user1,user2): x=0 y=0 z=0 for item1 in list2user[user1]: for item2 in list2user[user2]: if item1[0]==item2[0]: x1 = item1[1]*item1[1] y1 = item2[1]*item2[1] z1 = item1[1]*item2[1] x = x + x1 y = y + y1 z = z + z1 #避免分母为0 if x * y == 0: simi = 0 else: simi = z / math.sqrt(x * y) return simi#1.3计算目标用户与邻居之间的相似度：def N_neighbour(userid,neighbours,k): neighbour = neighbours.keys() M = [] for user in neighbour: simi = similarity(userid,user) M.append((user,simi)) M = sorted(M,key = lambda x:x[1] ,reverse = True)[0:k] return M#M = N_neighbour(userid,neighbours,k=200)#2.列出邻居所购买过的商品并计算商品对应的推荐指数def neighbour_item(M=M): R = &#123;&#125; M1 = dict(M) for neighbour in M1: for item in list2user[neighbour]: if item[0] not in R.keys(): R[item[0]] = M1[neighbour] * item[1] else: R[item[0]] = R[item[0]] + M1[neighbour] * item[1] #根据邻居买过什么及与邻居的相似度，计算邻居买过商品的推荐度 return R# R = neighbour_item(M)#3.排序得到推荐商品Rank = sorted(R.items(),key=lambda x:x[1],reverse = True)[0:50]endTime = time.time()print endTime-startTime python来实现基于user的协同推荐就完成了，核心的相似度计算可以根据实际问题进行修改，基于user的实现过程中，用了邻居这个概念，大大降低了计算量，我用了大概20万用户，2千的商品数，基于user的推荐实现速度大概为基于商品的10分之一，效果差异却相差不大。 协同推荐是非常简单的推荐入门算法之一，也是必须要手动快速代码实现的算法之一，希望能给大家一些帮助。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Tensorflow的神经网络解决用户流失概率问题]]></title>
    <url>%2F2017%2F12%2F01%2F%E5%9F%BA%E4%BA%8ETensorflow%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E8%A7%A3%E5%86%B3%E7%94%A8%E6%88%B7%E6%B5%81%E5%A4%B1%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前言：用户流失一直都是公司非常重视的一个问题，也是AAARR中的Retention的核心问题，所以各大算法竞赛都很关注。比如最近的：KKBOX的会员流失预测算法竞赛，如何能够搭建一个精准的模型成了大家探索的重要问题。本文主要讲解神经网络、TensorFlow的概述、如何利用python基于TensorFlow神经网络对流失用户进行分类预测，及可能存在的一些常见问题，作为深度学习的入门阅读比较适合。 行业做法：通常的行业预测用户流失大概分以下几种思路： 利用线性模型(比如Logistic)＋非线性模型Xgboost判断用户是否回流逝 这种方法有关是行业里面用的最多的，效果也被得意验证足够优秀且稳定的。核心点在于特征的预处理，Xgboost的参数挑优，拟合程度的控制，这个方法值得读者去仔细研究一边。问题也是很明显的，会有一个行业baseline，基本上达到上限之后，想有有提升会非常困难，对要求精准预测的需求会显得非常乏力。 规则触发 这种方法比较古老，但是任然有很多公司选择使用，实现成本较低而且非常快速。核心在于，先确定几条核心的流失指标(比如近7日登录时长)，然后动态的选择一个移动的窗口，不停根据已经流失的用户去更新流失指标的阈值。当新用户达到阈值的时候，触发流失预警。效果不如第一个方法，但是实现简单，老板也很容易懂。 场景模型的预测 这个方法比较依赖于公司业务的特征，如果公司业务有部分依赖于评论，可以做文本分析，比如我上次写的基于word2vec下的用户流失概率分析。如果业务有部分依赖于登录打卡，可以做时间线上的频次预估。这些都是比较偏奇门易巧，不属于通用类别的，不过当第一种方法达到上线的时候，这种方法补充收益会非常的大。 其实还有很多其它方法，我这边也不一一列出了，这个领域的方法论还是很多的。 神经网络 核心上面这张图片诠释了神经网络正向传播的流程，先通过线性变换(上图左侧)Σxw+b将线性可分的数据分离，再通过非线性变换(上图右侧)Sigmoid函数将非线性可分的数据分离，最后将输入空间投向另一个输出空间。 根据上面所说，我们可以知道，通过增加左侧线性节点的个数，我们可以强化线性变换的力度；而通过增加层数，多做N次激活函数(比如上面提到的Sigmoid)可以增强非线性变换的能力。 通过矩阵的线性变换+激活矩阵的非线性变换，将原始不可分的数据，先映射到高纬度，再进行分离。但是这边左侧节点的个数，网络的层数选择是非常困难的课题，需要反复尝试。 参数训练刚才我们了解了整个训练的流程，但是如何训练好包括线性变换的矩阵系数是一个还没有解决的问题。 我们来看下面的过程：input ==&gt; Σxw+b(线性变换) ==&gt; f(Σxw+b)(激活函数) ==&gt; …(多层的话重复前面过程) ==&gt; output(到此为止，正向传播结束，反向修正矩阵weights开始) ==&gt; error=actual_output-output(计算预测值与正式值误差)==&gt;output处的梯度==&gt;调整后矩阵weight=当前矩阵weight+errorx学习速率xoutput处的负梯度核心目的在于通过比较预测值和实际值来调整权重矩阵，将预测值与实际值的差值缩小。比如：梯度下降的方法，通过计算当前的损失值的方向的负方向，控制学习速率来降低预测值与实际值间的误差。 利用一行代码来解释就是 synaptic_weights += dot(inputs, (real_outputs - output) * output * (1 - output))*η这边output * (1 - output))是在output处的Sigmoid的倒数形式，η是学习速率。 神经网络流程小结123456789101数据集获取（有监督数据整理）2神经网络参数确定，有多少层，多少个节点，激活函数是什么，损失函数是什么3数据预处理，pca，标准化，中心化，特征压缩，异常值处理4初始化网络权重5网络训练5.1正向传播5.2计算loss5.3计算反向梯度5.4更新梯度5.5重新正向传播 这边只是简单介绍了神经网络的基础知识，针对有一定基础的朋友唤醒记忆，如果纯小白用户，建议从头开始认真阅读理解一遍过程，避免我讲的有偏颇的地方对你进行误导。 TensorFlow理论上讲，TensorFlow工具可以单独写一本书，用法很多而且技巧性的东西也非常的复杂，这边我们主要作为工具进行使用，遇到新技巧会在code中解释，但不做全书的梳理，建议去买一本《TensorFlow实战Google深度学习框架》，简单易懂。 TensorFlow是谷歌于2015年11月9日正式开源的计算框架，由Jeff Dean领导的谷歌大脑团队改编的DistBelief得到的，在ImageNet2014、YouTube视频学习，语言识别错误率优化，街景识别，广告，电商等等都有了非常优秀的产出，是我个人非常喜欢的工具。 除此之外，我在列出一些其他的框架工具供读者使用： 接下来看一下最基本的语法，方便之后我们直接贴代码的时候可以轻松阅读。 张量：可以理解为多维array 或者 list，time决定张量是什么tf.placeholder(time,shape,name) 变量：同一时刻下的不变的数据tf.Variable(value,name) 常量：永远不变的常值tf.constant(value) 执行环境开启与关闭，在环境中才能运行TensorFlow语法sess=tf.Session()sess.close()sess.run(op) 初始化所有权重：类似于变量申明tf.initialize_all_variables() 更新权重：tf.assign(variable_to_be_updated,new_value) 加值行为，利用feed_dict里面的值来训练[output]函数sess.run([output],feed_dict={input1:value1,input2:value2})利用input1，input2，来跑output的值 矩阵乘法，类似于dottf.matmul(input,layer1) 激活函数，relutf.nn.relu()，除此之外，还有tf.nn.sigmoid，tf.nn.tanh等等 用户流失分析说了那么多前置的铺垫，让我们来真实的面对我们需要解决的问题： 首先，我们拿到了用户是否流失的历史数据集20724条，流失与飞流失用户占比在1:4，这部分数据需要进行一下预处理，这边就不细讲预处理过程了，包含缺失值填充(分层填充)，异常值处理(isolation foest)，数据平衡(tomek link)，特征选择(xgboost importance)，特征变形(normalizing)，特征分布优化等等，工程技巧我之前的文章都有讲解过，不做本文重点。 taiking is cheap,show me the code. 12345678#author:shataowei#time:20170924#基础包加载import numpy as npimport pandas as pdimport tensorflow as tfimport mathfrom sklearn.cross_validation import train_test_split 12345678910111213141516171819202122232425262728#数据处理data = pd.read_table(&apos;/Users/slade/Desktop/machine learning/data/data_all.txt&apos;)data = data.iloc[:,1:len(data.columns)]data1 = (data - data.mean())/data.std()labels = data[&apos;tag&apos;]items = data1.iloc[:,1:len(data1.columns)]all_data = pd.concat([pd.DataFrame(labels),items],axis = 1)#数据集切分成训练集和测试集，占比为0.8：0.2train_X,test_X,train_y,test_y = train_test_split(items,labels,test_size = 0.2,random_state = 0)#pandas读取进来是dataframe，转换为ndarray的形式train_X = np.array(train_X)test_X = np.array(test_X)#我将0或者1的预测结果转换成了[0,1]或者[1,0]的对应形式，读者可以不转train_Y = []for i in train_y: if i ==0: train_Y.append([0,1]) else: train_Y.append([1,0])test_Y = []for i in test_y: if i ==0: test_Y.append([0,1]) else: test_Y.append([1,0]) 下面我们就要开始正式开始训练神经网络了，123456789101112131415161718192021222324252627input_node = 9 #输入的feature的个数，也就是input的维度output_node = 2 #输出的[0,1]或者[1,0]的维度layer1_node = 500 #隐藏层的节点个数，一般在255-1000之间，读者可以自行调整batch_size = 200 #批量训练的数据，batch_size越小训练时间越长，训练效果越准确（但会存在过拟合）learning_rate_base = 0.8 #训练weights的速率ηregularzation_rate = 0.0001 #正则力度training_steps = 10000 #训练次数，这个指标需要类似grid_search进行搜索优化#设定之后想要被训练的x及对应的正式结果y_x = tf.placeholder(tf.float32,[None,input_node])y_ = tf.placeholder(tf.float32,[None,output_node])#input到layer1之间的线性矩阵weightweight1 = tf.Variable(tf.truncated_normal([input_node,layer1_node],stddev=0.1))#layer1到output之间的线性矩阵weightweight2 = tf.Variable(tf.truncated_normal([layer1_node,output_node],stddev=0.1))#input到layer1之间的线性矩阵的偏置biases1 = tf.Variable(tf.constant(0.1,shape = [layer1_node]))#layer1到output之间的线性矩阵的偏置biases2 = tf.Variable(tf.constant(0.1,shape=[output_node]))#正向传播的流程，线性计算及激活函数relu的非线性计算得到resultdef interence(input_tensor,weight1,weight2,biases1,biases2): layer1 = tf.nn.relu(tf.matmul(input_tensor,weight1)+biases1) result = tf.matmul(layer1,weight2)+biases2 return resulty = interence(x,weight1,weight2,biases1,biases2) 正向传播完成后，我们要反向传播来修正weight1234567891011121314151617181920global_step = tf.Variable(0,trainable = False)#交叉熵，用来衡量两个分布之间的相似程度cross_entropy = tf.nn.softmax_cross_entropy_with_logits(labels = y_,logits=y)cross_entropy_mean = tf.reduce_mean(cross_entropy)#l2正则化，这部分的理论分析可以参考我之前写的：http://www.jianshu.com/p/4f91f0dcba95regularzer = tf.contrib.layers.l2_regularizer(regularzation_rate)regularzation = regularzer(weight1) + regularzer(weight2)#损失函数为交叉熵+正则化loss = cross_entropy_mean + regularzation#我们用learning_rate_base作为速率η，来训练梯度下降的loss函数解train_op = tf.train.GradientDescentOptimizer(learning_rate_base).minimize(loss,global_step = global_step)#y是我们的预测值，y_是真实值，我们来找到y_及y(比如[0.1，0.2])中最大值对应的index位置，判断y与y_是否一致correction = tf.equal(tf.argmax(y,1),tf.argmax(y_,1))#如果y与y_一致则为1，否则为0，mean正好为其准确率accurary = tf.reduce_mean(tf.cast(correction,tf.float32)) 模型训练结果1234567891011121314151617#初始化环境，设置输入值，检验值init = tf.global_variables_initializer()sess = tf.Session()sess.run(init)validate_feed = &#123;x:train_X,y_:train_Y&#125;test_feed = &#123;x:test_X,y_:test_Y&#125;#模型训练，每到1000次汇报一次训练效果for i in range(training_steps): start = (i*batch_size)%len(train_X) end = min(start+batch_size,16579) xs = train_X[start:end] ys = train_Y[start:end] if i%1000 ==0: validate_accuary = sess.run(accurary,feed_dict = validate_feed) print &apos;the times of training is %d, and the accurary is %s&apos; %(i,validate_accuary) sess.run(train_op,feed_dict = &#123;x:xs,y_:ys&#125;) 训练的结果如下：12345678910111213142017-09-24 12:11:28.409585: W tensorflow/core/platform/cpu_feature_guard.cc:45] The TensorFlow library wasn&apos;t compiled to use SSE4.2 instructions, but these are available on your machine and could speed up CPU computations.2017-09-24 12:11:28.409620: W tensorflow/core/platform/cpu_feature_guard.cc:45] The TensorFlow library wasn&apos;t compiled to use AVX instructions, but these are available on your machine and could speed up CPU computations.2017-09-24 12:11:28.409628: W tensorflow/core/platform/cpu_feature_guard.cc:45] The TensorFlow library wasn&apos;t compiled to use AVX2 instructions, but these are available on your machine and could speed up CPU computations.2017-09-24 12:11:28.409635: W tensorflow/core/platform/cpu_feature_guard.cc:45] The TensorFlow library wasn&apos;t compiled to use FMA instructions, but these are available on your machine and could speed up CPU computations.the times of training is 0, and the accurary is 0.736775the times of training is 1000, and the accurary is 0.99246the times of training is 2000, and the accurary is 0.993003the times of training is 3000, and the accurary is 0.992943the times of training is 4000, and the accurary is 0.992943the times of training is 5000, and the accurary is 0.99234the times of training is 6000, and the accurary is 0.993124the times of training is 7000, and the accurary is 0.992943the times of training is 8000, and the accurary is 0.993124the times of training is 9000, and the accurary is 0.992943 初步看出，在训练集合上，准确率在能够99%以上，让我们在看看测试集效果1test_accuary = sess.run(accurary,feed_dict = test_feed) Out[5]: 0.99034983,也是我们的测试数据集效果也是在99%附近，可以看出这个分类的效果还是比较高的。 初次之外，我们还可以得到每个值被预测出来的结果，也可以通过工程技巧转换为0-1的概率：1234567result_y = sess.run(y,feed_dict=&#123;x:train_X&#125;)result_y_update=[]for i in result_y: if i[0]&gt;=i[1]: result_y_update.append([1,0]) else: result_y_update.append([0,1]) ==&gt;12345678Out[7]:array([[-1.01412344, 1.21461654],[-3.66026735, 3.81834102],[-3.78952932, 3.79097509],...,[-3.71239662, 3.65721083],[-1.59250259, 1.89412308],[-3.35591984, 3.24001145]], dtype=float32) 以上就实现了如果用TensorFlow里面的神经网络技巧去做一个分类问题，其实这并不TensorFlow的全部，传统的Bp神经网络，SVM也可以到达近似的效果，在接下来的文章中，我们将继续看到比如CNN图像识别，LSTM进行文本分类，RNN训练不均衡数据等复杂问题上面的优势。 可能存在的问题在刚做神经网络的训练前，要注意一下是否会犯以下的错误。 数据是否规范化模型计算的过程时间长度及模型最后的效果，均依赖于input的形式。大部分的神经网络训练过程都是以input为1的标准差，0的均值为前提的；除此之外，在算梯度算反向传播的时候，过大的值有可能会导致梯度消失等意想不到的情况，非常值得大家注意 batch的选择在上面我也提了，过小的batch会增加模型过拟合的风险，且计算的时间大大增加。过大的batch会造成模型的拟合能力不足，可能会被局部最小值卡住等等，所以需要多次选择并计算尝试。 过拟合的问题是否在计算过程中只考虑了损失函数比如交叉熵，有没有考虑l2正则、l2正则，或者有没有进行dropout行为，是否有必要加入噪声，在什么地方加入噪声（weight？input？），需不需要结合Bagging或者bayes方法等 激活函数的选择是否正确比如relu只能产出&gt;=0的结果，是否符合最后的产出结果要求。比如Sigmoid的函数在数据离散且均大于+3的数据集合上会产生梯度消失的问题，等等 到这里，我觉得一篇用TensorFlow来训练分类模型来解决用户流失这个问题就基本上算是梳理完了。很多简单的知识点我没有提，上面这些算是比较重要的模块，希望对大家有所帮助，最后谢谢大家的阅读。]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>CRM预估</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于SSD下的图像内容识别（二）]]></title>
    <url>%2F2017%2F12%2F01%2F%E5%9F%BA%E4%BA%8ESSD%E4%B8%8B%E7%9A%84%E5%9B%BE%E5%83%8F%E5%86%85%E5%AE%B9%E8%AF%86%E5%88%AB%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[上一节粗略的描述了如何关于图像识别，抠图，分类的理论相关，本节主要用代码，来和大家一起分析每一步骤。看完本节，希望你也能独立完成自己的图片、视频的内容实时定位。 首先，我们需要安装TensorFlow环境，建议利用conda进行安装，配置，90%尝试单独安装的人最后都挂了。 其次，我们需要安装从git上下载训练好的模型，git clone https://github.com/balancap/SSD-Tensorflow如果没有安装git的朋友，请自行百度安装。 最后找到你下载的位置进行解压，unzip ./SSD-Tensorflow/checkpoints/ssd_300_vgg.ckpt.zip这边务必注意，网上90%的教程这边就结束了，其实你这样是最后跑不通代码的，你需要把解压的文件进行移动到checkpoint的文件夹下面，这个问题git上这个同学解释了，详细的去看下https://github.com/balancap/SSD-Tensorflow/issues/150 最后的最后，下载你需要检测的网路图片，就ok了 预处理步骤完成了，下面让我们看代码。加载相关的包：123456789101112import osimport mathimport randomimport sysimport numpy as npimport tensorflow as tfimport cv2import matplotlib.pyplot as pltimport matplotlib.cm as mpcmsys.path.append('./SSD-Tensorflow/')from nets import ssd_vgg_300, ssd_common, np_methodsfrom preprocessing import ssd_vgg_preprocessing 配置相关TensorFlow环境123gpu_options = tf.GPUOptions(allow_growth=True)config = tf.ConfigProto(log_device_placement=False, gpu_options=gpu_options)isess = tf.InteractiveSession(config=config) 做图片的格式的处理，使他满足input的条件123456789101112131415161718192021222324#我们用的TensorFlow下的一个集成包slim，比tensor要更加轻便slim = tf.contrib.slim#训练数据中包含了一下已知的类别，也就是我们可以识别出以下的东西，不过后续我们将自己自己训练自己的模型，来识别自己想识别的东西l_VOC_CLASS = [ 'aeroplane', 'bicycle', 'bird', 'boat', 'bottle', 'bus', 'car', 'cat', 'chair', 'cow', 'diningTable', 'dog', 'horse', 'motorbike', 'person', 'pottedPlant', 'sheep', 'sofa', 'train', 'TV']# 定义数据格式net_shape = (300, 300)data_format = 'NHWC' # [Number, height, width, color]，Tensorflow backend 的格式# 预处理将输入图片大小改成 300x300，作为下一步输入img_input = tf.placeholder(tf.uint8, shape=(None, None, 3))image_pre, labels_pre, bboxes_pre, bbox_img = ssd_vgg_preprocessing.preprocess_for_eval( img_input, None, None, net_shape, data_format, resize=ssd_vgg_preprocessing.Resize.WARP_RESIZE)image_4d = tf.expand_dims(image_pre, 0) 下面我们来载入SSD作者已经搞定的模型123456789101112# 定义 SSD 模型结构reuse = True if 'ssd_net' in locals() else Nonessd_net = ssd_vgg_300.SSDNet()with slim.arg_scope(ssd_net.arg_scope(data_format=data_format)): predictions, localisations, _, _ = ssd_net.net(image_4d, is_training=False, reuse=reuse)# 导入官方给出的 SSD 模型参数#这边修改成你自己的路径ckpt_filename = '/Users/slade/SSD-Tensorflow/checkpoints/ssd_300_vgg.ckpt'isess.run(tf.global_variables_initializer())saver = tf.train.Saver()saver.restore(isess, ckpt_filename)ssd_anchors = ssd_net.anchors(net_shape) 下面让我们把SSD识别出来的结果在图片中表示出来1234567891011121314151617181920212223242526#不同类别，我们以不同的颜色表示def colors_subselect(colors, num_classes=21): dt = len(colors) // num_classes sub_colors = [] for i in range(num_classes): color = colors[i*dt] if isinstance(color[0], float): sub_colors.append([int(c * 255) for c in color]) else: sub_colors.append([c for c in color]) return sub_colors#画出在图中的位置def bboxes_draw_on_img(img, classes, scores, bboxes, colors, thickness=5): shape = img.shape for i in range(bboxes.shape[0]): bbox = bboxes[i] color = colors[classes[i]] # Draw bounding box... p1 = (int(bbox[0] * shape[0]), int(bbox[1] * shape[1])) p2 = (int(bbox[2] * shape[0]), int(bbox[3] * shape[1])) cv2.rectangle(img, p1[::-1], p2[::-1], color, thickness) # Draw text... s = '%s:%.3f' % ( l_VOC_CLASS[int(classes[i])-1], scores[i]) p1 = (p1[0]-5, p1[1]) cv2.putText(img, s, p1[::-1], cv2.FONT_HERSHEY_SIMPLEX, 1, color, 2)colors_plasma = colors_subselect(mpcm.plasma.colors, num_classes=21) 让我们开始训练吧123456789101112131415def process_image(img, select_threshold=0.3, nms_threshold=.8, net_shape=(300, 300)): #先获取SSD网络的层相关的参数 rimg, rpredictions, rlocalisations, rbbox_img = isess.run([image_4d, predictions, localisations, bbox_img], feed_dict=&#123;img_input: img&#125;) #获取分类结果，位置 rclasses, rscores, rbboxes = np_methods.ssd_bboxes_select( rpredictions, rlocalisations, ssd_anchors, select_threshold=select_threshold, img_shape=net_shape, num_classes=21, decode=True) rbboxes = np_methods.bboxes_clip(rbbox_img, rbboxes) rclasses, rscores, rbboxes = np_methods.bboxes_sort(rclasses, rscores, rbboxes, top_k=400) rclasses, rscores, rbboxes = np_methods.bboxes_nms(rclasses, rscores, rbboxes, nms_threshold=nms_threshold) # 让我们在图中画出来就行了 rbboxes = np_methods.bboxes_resize(rbbox_img, rbboxes) bboxes_draw_on_img(img, rclasses, rscores, rbboxes, colors_plasma, thickness=2) return img 预处理的函数都写完了，我们就可以执行了。12345#读取数据img = cv2.imread("/Users/slade/Documents/Yoho/picture_recognize/test7.jpg")img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)plt.imshow(process_image(img))plt.show() img的数据形式如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950In [8]: imgOut[8]:array([[[ 35, 59, 43],[ 37, 60, 44],[ 38, 61, 45],...,[ 73, 99, 62],[ 74, 99, 60],[ 72, 97, 57]],[[ 37, 60, 44],[ 37, 60, 44],[ 37, 60, 44],...,[ 66, 92, 57],[ 67, 93, 56],[ 67, 92, 53]],[[ 37, 60, 44],[ 36, 59, 43],[ 37, 58, 43],...,[ 56, 83, 48],[ 60, 86, 51],[ 61, 87, 50]],...,[[ 96, 101, 95],[107, 109, 104],[ 98, 97, 95],...,[ 84, 126, 76],[ 72, 118, 72],[ 78, 126, 86]],[[ 98, 103, 96],[114, 116, 111],[112, 113, 108],...,[ 94, 137, 84],[ 87, 133, 86],[105, 153, 111]],[[ 99, 105, 95],[110, 113, 106],[134, 135, 129],...,[127, 170, 116],[121, 167, 118],[131, 180, 135]]], dtype=uint8) 处理后的结果如下： 是不是非常无脑，上面的代码直接复制就可以完成。 下面在拓展一下视频的处理方式，其实相关的内容是一致的。利用moviepy.editor包里面的VideoFileClip的切片的功能，然后对每一次切片的结果进行process_image过程就可以了，这边就不贴代码了，需要的朋友私密我。 最后感谢大家阅读。]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>图像识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于SSD下的图像内容识别（一）]]></title>
    <url>%2F2017%2F12%2F01%2F%E5%9F%BA%E4%BA%8ESSD%E4%B8%8B%E7%9A%84%E5%9B%BE%E5%83%8F%E5%86%85%E5%AE%B9%E8%AF%86%E5%88%AB%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[鸽了将近有一个月的时间没有更新东西，真的不是因为我懒，主要在忙一些工作上的事情，然后就是被安装caffe环境折磨的死去活来。我本来用的上mba来搭caffe环境的，一直在报一个框架问题，索性一怒之下换了mbp，下面就将我在SSD学习过程中遇到的问题和大家一起分享一下。 首先，先看一下我们能达到什么样的效果：比如,这样的： 再比如这样的： 甚至还可以这样：https://v.qq.com/x/page/a0567wd27jz.htmlhttps://v.qq.com/x/page/j05679xhryx.html这边吐槽一下，简书makedown不支持上传视频，简直差评！ 那问题来了，在真实的业务场景中，我们有哪些应用呢？比如天猫的拍照购： 有货的相似推荐：这些都是非常优秀的应用场景。 我们需要做哪些基本的步骤：抠出图片中关键的人或者物如果只需要抠出图片中的核心信息的话，其实只需要加载python里面的selectivesearch包就可以（这里多说一句，建议都是使用conda安装所有包和库，不然你会后悔的）。我们先来看下效果： 这个是怎么实现的呢？12345678910111213141516171819202122232425import cv2import selectivesearchimport matplotlib.pyplot as pltimport matplotlib.patches as mpatchesimport numpy as npimg = cv2.imread('/Users/slade/Documents/Yoho/picture_recognize/heshen.jpg')#图片识别分割img_lbl, regions =selectivesearch.selective_search( img, scale=500, sigma=0.9, min_size=20)#这边的regions里面就有一个个划分出来的boxregions[0]#Out[3]: &#123;'labels': [0.0], 'rect': (0, 0, 619, 620), 'size': 177325&#125;,其中‘rect’定位了box的位置，‘size’确定了box的大小# 接下来我们把窗口和图像打印出来，对它有个直观认识fig, ax = plt.subplots(ncols=1, nrows=1, figsize=(6, 6))ax.imshow(img)for reg in regions: x, y, w, h = reg['rect'] rect = mpatches.Rectangle( (x, y), w, h, fill=False, edgecolor='red', linewidth=1) ax.add_patch(rect)plt.show() 搜索完成后展示图：很明显，这里面的方框太多了，所以我们需要把一些过小的，过大的，不规则的全部去掉：12345678910111213141516171819202122232425262728293031323334353637383940candidates = []for r in regions: # 重复的不要 if r['rect'] in candidates: continue # 太小和太大的不要 if r['size'] &lt; 200 or r['size']&gt;20000: continue x, y, w, h = r['rect'] # 太不方的不要 if w / h &gt; 1.8 or h / w &gt; 1.8: continue candidates.append((x,y,w,h))#剔除大box内的小boxcandidates_sec = []for i in candidates: if len(candidates_sec)==0: candidates_sec.append(i) else: Flag=False replace=-1 index=0 for j in candidates_sec: ##新box在小圈 则删除 if i[0]&gt;=j[0] and i[0]+i[2]&lt;=j[0]+j[2] and i[1]&gt;=j[1] and i[1]+i[3]&lt;=j[1]+j[3]: Flag=True break ##新box不在小圈 而在老box外部 替换老box elif i[0]&lt;=j[0] and i[0]+i[2]&gt;=j[0]+j[2] and i[1]&lt;=j[1] and i[1]+i[3]&gt;=j[1]+j[3]: replace=index break index+=1 if not Flag: if replace&gt;=0: candidates_sec[replace]=i else: candidates_sec.append(i) 然后我们看看更新完后的图片效果：1234567fig, ax = plt.subplots(ncols=1, nrows=1, figsize=(6, 6))ax.imshow(img)for x, y, w, h in candidates_sec: rect = mpatches.Rectangle( (x, y), w, h, fill=False, edgecolor=&apos;red&apos;, linewidth=1) ax.add_patch(rect)plt.show() 在根据重复优化一下，就可以得到最初的那张图片，基本上来说，就可以完成抠图这个事情了。 相关理论概述：上面这样的识别从数学角度上是怎么样实现的呢？这边先引入一篇文章：2014年CVPR上的经典paper：《Rich feature hierarchies for Accurate Object Detection and Segmentation》，这篇文章的算法思想又被称之为：R-CNN（Regions with Convolutional Neural Network Features），是物体检测领域曾经获得state-of-art精度的经典文献。论文较为复杂冗长，我这边主要先看一下我们关系的抠图模块： 抠若干个box过程：先切分图片到若干子区域的集合S1.在计算集合S中找出相似性最大的区域max_similarity{ri,rj}2.合并S_new=ri∪rj3.从S集合中，移走所有与ri,rj的子集4.将新集合S_new与相邻区域的相似度5.repeat step2直到S集合为空这边相似度的计算考虑了三个方面：颜色相似，纹理相似，空间交错相似，分别解释如下：颜色相似：其中对每个区域，我们都可以得到一个一维的颜色分布直方图：假设两个直方图波峰和波谷高度重合，那么计算下来的值比较大；反之如果波峰和波谷错开的，那么累加的值一定比较小。 纹理相似：这边会用到SIFI算法，也是一个比较经典的算法。selectivesearch论文采用方差为1的高斯分布在8个方向做梯度统计，然后将统计结果（尺寸与区域大小一致）以bins=10计算直方图。（这个我也没有仔细去看，只是skip learn了一下） 空间相似：这个最简单，代码呈现了：123456789def sim_fill(r1, r2, imsize): """ calculate the fill_similarity over the image """ bbsize = ( (max(r1["max_x"], r2["max_x"]) - min(r1["min_x"], r2["min_x"])) * (max(r1["max_y"], r2["max_y"]) - min(r1["min_y"], r2["min_y"])) ) return 1.0 - (bbsize - r1["size"] - r2["size"]) / imsize 若干个box筛选的过程：首先，我们定义：IOU为两个bounding box的重叠度，如下图所示：矩形框A、B的一个重合度IOU计算公式为：IOU=(A∩B)/(A∪B)就是矩形框A、B的重叠面积占A、B并集的面积比例:IOU=SI/(SA+SB-SI) 再引入非极大值抑制（NMS）概念：抑制不是极大值的元素，搜索局部的极大值。翻译一下就是：比如之前看的这张图片：很明显还是很多box是相互inner的，虽然没有被相互包含进去，我们可以先选择最大的box，看其他box与这个最大的box的IOU值，删除IOU值大于预先设定的阈值的box，重复这个过程就是一个方框删除的过程。真实的NMS还会涉及到canny detection等等的细节问题，这边只是让大家快速入门使用起来，如需详细了解，请自行百度。 若干个box内容对应：我们虽然识别出了方框内存在物体，但是我们仍需要将物体与标签对应起来，这边的方法就是很多了，RCNN里面的方法：SVM，还有现在非常热门的CNN都可以对识别出来的子图片进行识别分类：VOC物体检测任务是一个非常入门的分类问题。你可以通过任何一种你觉得可以的分类方法进行识别训练。 简单的流程化的识别拆分讲解这边就结束了，主要讲了candidates_boxs的产生，candidates_boxs通过基本属性的初筛，candidates_boxs根据IOU原则下的NMS进行复选，再将复选出来的box根据你已经训练好的分类模型确定到底是啥？可以用下面这个图概述一下： To-do:我们还有很多没讲完的，后面会持续更新：主要包括：1.如何配置一个快速训练的环境？2.如何实现（输入图片，产出结果）整套识别流程？3.如何自己训练一个图片分类器？4.如何做快速迁移一个自己需要的及时图片识别流？]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>图像识别</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态最优化经典面试题]]></title>
    <url>%2F2017%2F12%2F01%2F%E5%8A%A8%E6%80%81%E6%9C%80%E4%BC%98%E5%8C%96%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近看到了一条史前的算法面试题，觉得挺有意思的，虽然网上已经有了很多完善的答案，但是我还是想自己整理一遍，强化印象，同时也和大家分享一下这道12年的Google题目： 一幢 200 层的大楼，给你两个鸡蛋。如果在第 n 层扔下鸡蛋，鸡蛋不碎，那么从第 n-1 层扔鸡蛋，都不碎。这两只鸡蛋一模一样，不碎的话可以扔无数次。最高从哪层楼扔下时鸡蛋不会碎？ 先形象的理解一下这道题目，假设第一个蛋我们放在了i层，有两种case，碎或者不碎。先看简单的结果，case1:如果碎了，为了求出层数，那么我接下来的那颗蛋需要从第1层开始尝试i-1次，因为我们不允许冒第二次碎的风险了，这很好理解。case2:如果没碎，我们得知一条新的信息，那就是我们要求的目标层在i层之上，但是我们依旧不知道是哪一层，假设是m层（m&gt;i）,那么同样的，和第i层一样，面临2个case，碎或者不碎。 这时候，我们的前提是在最恶劣的情况下，保证我们的每次的风险都尽可能的小，至少要少于上一次的风险。 我们可以让新的m的高度为i+i-1,其中，i是第一次我们放的层数，i-1是我们选择的风险若于第一次风险的层数高度，类推下去：i+i-1+i-2+i-3+…+1=200，得到i=20，就是我们第一次应该放的位置，同理第二次如果没有碎应该放的就是39… 我个人对这道题目的理解中，其实就为了平分风险，让每次碎的高度都相等，也就是i-1 = m-i-1+1==&gt;m=2i-1 这边的python代码网上也有很多，这边我罗列一个我写的，可能和别人的不一样，实现效率也可能较慢，建议大家在网上搜完善版本的，仅供大家熟悉上述的描述：12345678910111213#n为层数，m为蛋数，f函数为求最优层数def f(n, m):#如果是0层的，返回最优层数为0 if n == 0: return 0#如果只有一个鸡蛋，必须要从最低层开始试，所以为当前最安全层n if m == 1: return n#这边我们来看，f(i - 1, m - 1)是如果i层碎了，我们需要计算i-1层下的情况，同时减少一颗蛋；#f(n - i, m)是i层没碎，那相当于安全层从0变成了n，要计算的就是相当于有 f(n, m)变成了 f(n - i, m)#最后在最大化风险下找出其中风险最小的层数即可 best_floor = min([max([f(i - 1, m - 1), f(n - i, m)]) for i in range(1, n + 1)] + 1) return best_floor 结果：12In [74]:print(f(100, 2))14 这边f(200,2)实在没跑出来，时间太久了，所以跑了100，2的结果，迭代次数超多，具体我没有算过，建议优化一下计算的代码再执行。 最后谢谢大家阅读。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用户生命周期]]></title>
    <url>%2F2017%2F11%2F02%2F%E7%94%A8%E6%88%B7%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[摘要：设计一套完整的用户生命周期策略，极大程度上会提高用户活跃，降低用户流失，反应用户留存，为平台运营的不可或缺的一环 定义用户生命周期是指用户从加入平台开始，熟悉平台，参与平台，最终流失的整个过程。用户的生命周期相对于自身而言，是一种参与度的变化，参与度也可以称之为活跃度。 如何定义参与度？以电商平台而言，冒泡（打开app），浏览，点击，搜索，收藏，加购物车，下单，评论等都是用户参与平台的主要行为，综合考虑（但不限于此）这些因素， 活跃度：1θ = α1* pv + α2 * click + α3* search + α4 * clc + α5* cart + α6* order + α7* comment + bubble 其中，θ是活跃度，pv是用户浏览量，click是用户点击量，search是用户搜索量，clc是用户收藏量，cart是用户加购物车次，order为用户订单量，comment为用户评论量α1 为全部用户冒泡次数 与 全部用户浏览量之比；α2 为全部用户冒泡次数 与 全部用户点击量之比；… 这样保证了，所有平台参与行为与用户活跃情况成正相关，同时动态变化的降低了操作成本低的变量的权重，也满足奥卡姆剃刀原理后续再利用活跃度来直接衡量生命周期状态。 如何定义生命周期？ 以电商平台为例，考虑用户的行为，先来定义生命周期状态划分逻辑：1.计算用户连续N(N&gt;3)个周期内的参与度组成特征向量2.形成不同生命周期下的模式特征向量3.分类用户的特征向量如下： 生命周期状态 生命周期类型 描述 初生期 新增用户 处于新生用户没有用户记录 成长期 显性成长 最近三次生命周期状态都是成长期 成长期 隐性成长 最近三次生命周期状态不全是成长期 稳定期 低稳定 处于平稳期阶段，参与度低于1/4分位数 稳定期 中稳定 处于平稳期阶段，参与度介于1/4-3/4分位数 稳定期 高稳定 处于平稳期阶段，参与度高于3/4分位数 衰退期 轻微衰退 连续x个周期进入衰退期或流失期 衰退期 重度微衰退 连续x个周期进入衰退期或流失期 流失期 流失期 刚进入流失期 沉默期 沉默期 长期处于流失期 定义完整的用户生命周期状态后，再对用户的生命周期做session切分，根据聚类算法，将样本用户进行聚类，形成聚类中心，判断用户距离聚类中心距离，匹配用户所处的生命周期详细位置，反过来输出分位数，判断用户生命周期类型。 下面思考如何优化kmeans解决这个问题：考虑到业务开发的效率等原因，常规的聚类算法中，kmeans常常为优先考虑的算法，但实际运用过程中，需要根据不同的问题有差异化的优化。 1.考虑用户的特征偏移可能存在用户的活跃属性间断，比如用户外出出差一周，导致某个单位统计时间内平台参与度下降，用户的活跃属性下降，而实际用户为真实高活跃用户，只是出现异常间断点，影响用户活跃的最终判断，利用语义分析中的最佳路径计算方式解决这个问题。这三条线中，蓝色和青色线的分布走势类似，而红色线条的差异较大；计算蓝色—&gt;红色的欧式距离，蓝色—&gt;青色的欧式距离，发现蓝色—&gt;青色的欧式距离反而大于蓝色—&gt;红色的欧式距离，时间波动的情况下，欧式距离偏差较大。 所以，常规意义上的kmeans等基于欧式距离的算法这种情况下，使用较为局限。所以在整体思路不变的情况下，就距离计算，我们可以参考语音分析里面的DP（最佳路径规划算法），构造邻接矩阵，寻找最小最小路径和 实际在计算蓝色曲线到青色曲线的距离的时候，同时计算AB（蓝色曲线当前位置A点到前一个时间段青色曲线位置B）、AC（蓝色曲线当前位置A点到当前时间段青色曲线位置C），AD（蓝色曲线当前位置A点到后一个时间段青色曲线位置D）的距离，综合判断一个点最短路径；再根据曲线上的每一个点，会形成一个矩阵，判断矩阵的每个点的最佳路径即可 可以用如下的公式表述：其中，就是路径选择的过程 以上述的计算方式替换掉常规的kmeans中的欧式距离，提高了相似度的计算精度。 2.常规等距划分session不适用于生命周期 就用户平台活跃而言，不同用户可采用的用户时间窗口不同，新加入的用户可能可获取的时间长度较短；用户判断过程中的session与平台确定已知的生命周期session固定判断长度也是不相同的。同时，kmeans中的距离判断方法不能同时考虑到不同session下的距离计算问题 最简单常规的计算方式：是补全较短的session的时间窗口，在相同的时间窗口之下，再去计算较短的时间窗口与较长的时间窗口下的生命周期的均值，这样会人为干涉过多，数据质量较低，图b即为数据补齐 “STS距离”计算方式：在长时间窗口{r}集合中，寻找时间窗口长度子集，使得子集中的元长度与s曲线缺失的长度一致，在以s断点处开始向后寻找{r}子集合中的所有满足的元，再以均值时间序列替换原来的子集中的元作为r和s的拟合曲线，循环往复计算中心曲线2，如图c 有了补齐长度下的中心曲线，再便可采用kmeans的常规方式，计算各时间长度窗口下的生命周期的距离 3.附加限制属性再最后落地生命周期的长度的时候，考虑到商品平台的特殊属性，比如： 商品周期性（奶粉用户周期购买等） 用户偏好属性(酒店用户品质偏好等） 平台的时间依赖情况(夏季冬季季节偏好等） ……以上即为如何通过kmeans来确定一个用户所属的生命周期阶段 本文参考文献如下：1.不等长时间序列下的滑窗相似度2.kmeans距离计算方式剖析]]></content>
      <categories>
        <category>特征刻画</category>
      </categories>
      <tags>
        <tag>生命周期</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[交叉销售算法]]></title>
    <url>%2F2017%2F11%2F01%2F%E4%BA%A4%E5%8F%89%E9%94%80%E5%94%AE%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近做了一个交叉销售的项目，梳理了一些关键点，分享如下，希望对大家有所启发核心目标：在有限资源下，尽可能的提供高转化率的用户群，辅助业务增长初步效果：商家ROI值为50以上，用户日转化率提升10倍以上，用户日最低转化效果5pp以上以下为正文：数据准备：1.商品相关性存在商品A,B,C…，商品之间用户会存在行为信息的关联度，这边可以参考协调过滤算法中的Item-based，这边拓展为用户在不同商品之间的操作行为的差异性。 可以形成如下的特征矩阵： 这边相关的常见度量方式有以下几种：a.距离衡量包括浏览、点击、搜索等等各种行为的欧式、马氏、闵式、切比雪夫距离、汉明距离计算b.相似度衡量包括余弦相似度、杰卡德相似度衡量c.复杂衡量包括相关性衡量，熵值衡量，互信息量衡量，相关距离衡量2.商品行为信息探求商品及其对应行为信息的笛卡尔积的映射关系，得到一个商品+用户的行为魔方商品集合：{商品A、商品B、…}商品属性集合：{价格、是否打折、相比其他电商平台的比价、是否缺货…}用户行为集合：{浏览次数、浏览时长、末次浏览间隔、搜索次数、末次搜索间隔…}通过商品集合商品属性集合用户行为集合,形成高维的商品信息魔方，再通过探查算法，筛选优秀表现的特征，这里推荐的有pca，randomforest的importance，lasso变量压缩，相关性压缩，逐步回归压缩等方法，根据数据的属性特点可适当选取方法最后，我们会得到如下一个待选特征组： 3.商品购买周期针对每一件商品，都是有它自身的生命周期的，比如，在三个月内买过冰箱的用户，95%以上的用户是不会选择二次购买的；而在1个月的节点上，会有20%的用户会选择二次购买生活用纸。所以我们需要做的一件事情就是不断更新，平台上面每个类目下面的商品的自身生命周期。除此之外，考虑在过渡时间点，用户的需求变化情况，是否可以提前触发需求；这边利用，艾宾浩斯遗忘曲线和因子衰减规律拟合： 确定lamda和b，计算每个用户对应的每个类目，当前时间下的剩余价值：f(最高价值)lamdab 4.商品挖掘特征，用户挖掘特征业务运营过程中，通过数据常规可以得到1.基础结论，2.挖掘结论。基础结论就是统计结论，比如昨日订单量，昨日销售量 ，昨日用户量；挖掘结论就是深层结论，比如昨日活跃用户数，每日预估销售量，用户生命周期等存在如下的探索形式，这是一个漫长而又非常有价值的过程： 模型整合再确定以上四大类的数据特征之后，我们通过组合模型的方法，判断用户的交叉销售结果 1.cart regression确保非线性密度均匀数据拟合效果，针对存在非线性关系且数据可被网格切分的产业用户有高的预测能力2.ridge regression确保可线性拟合及特征繁多数据的效果，针对存在线性关系的产业用户有高的预测能力3.Svm-liner确保线性且存在不可忽视的异常点的数据拟合效果，针对存在异常用户较多的部分产业用户有高的预测能力4.xgboost确保数据复杂高维且无明显关系的数据拟合效果，针对存在维度高、数据杂乱、无模型规律的部分产业用户有高的预测能力以上的组合模型并非固定，也并非一定全部使用，在确定自身产业的特点后，择优选择，然后采取投票、加权、分组等组合方式产出结果即可。 附上推荐Rcode简述，cart regression：123456789101112fit &lt;- rpart(y~x, data=database, method=&quot;class&quot;,control=ct, parms = list(prior = c(0.7,0.3), split = &quot;information&quot;));# xval是n折交叉验证# minsplit是最小分支节点数，设置后达不到最小分支节点的话会继续分划下去# minbucket：叶子节点最小样本数# maxdepth：树的深度# cp全称为complexity parameter，指某个点的复杂度，对每一步拆分,模型的拟合优度必须提高的程度# kyphosis是rpart这个包自带的数据集# na.action：缺失数据的处理办法，默认为删除因变量缺失的观测而保留自变量缺失的观测。# method：树的末端数据类型选择相应的变量分割方法:# 连续性method=“anova”,离散型method=“class”,计数型method=“poisson”,生存分析型method=“exp”#parms用来设置三个参数:先验概率、损失矩阵、分类纯度的度量方法（gini和information）# cost我觉得是损失矩阵，在剪枝的时候，叶子节点的加权误差与父节点的误差进行比较，考虑损失矩阵的时候，从将“减少-误差”调整为“减少-损失” ridge regression：123456library（glmnet）glmmod&lt;-glmnet(x,y,family = &apos;guassian&apos;,alpha = 0)最小惩罚：glmmod.min&lt;-glmnet(x,y,family = &apos;gaussian&apos;,alpha = 0,lambda = glmmod.cv$lambda.min)1个标准差下的最小惩罚：glmmod.1se&lt;-glmnet(x,y,family = &apos;gaussian&apos;,alpha = 0,lambda = glmmod.cv$lambda.1se) Svm-liner ：123456789library(e1071)svm(x, y, scale = TRUE, type = NULL, kernel = &quot;&quot;,degree = 3, gamma = if (is.vector(x)) 1 else 1 / ncol(x),coef0 = 0, cost = 1, nu = 0.5, subset, na.action = na.omit)#type用于指定建立模型的类别:C-classification、nu-classification、one-classification、eps-regression和nu-regression#kernel是指在模型建立过程中使用的核函数#degree参数是指核函数多项式内积函数中的参数，其默认值为3#gamma参数给出了核函数中除线性内积函数以外的所有函数的参数，默认值为l#coef0参数是指核函数中多项式内积函数与sigmoid内积函数中的参数，默认值为0#参数cost就是软间隔模型中的离群点权重#参数nu是用于nu-regression、nu-classification和one-classification类型中的参数 xgboost:123456789library(xgboost)xgb &lt;- xgboost(data = data.matrix(x[,-1]), label = y, eta = 0.1,max_depth = 15, nround=25, subsample = 0.5,colsample_bytree = 0.5,seed = 1,eval_metric = &quot;merror&quot;,objective = &quot;multi:softprob&quot;,num_class = 12, nthread = 3)#eta：默认值设置为0.3。步长，控制速度及拟合程度#gamma:默认值设置为0。子树叶节点个数#max_depth:默认值设置为6。树的最大深度#min_child_weight:默认值设置为1。控制子树的权重和#max_delta_step：默认值设置为0。控制每棵树的权重#subsample： 默认值设置为1。抽样训练占比#lambda and alpha：正则化 最后通过组合算法的形式产出最终值： 典型算法代表：randomforest,adaboost,gbdt 之前写的没有用markdown，所以看起来很费力，还丢图，这次优化了一下视图，谢谢。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[随机森林-枝剪问题]]></title>
    <url>%2F2017%2F10%2F02%2F%E9%9A%8F%E6%9C%BA%E6%A3%AE%E6%9E%97%E6%9E%9D%E5%89%AA%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[通常情况下， 随机森林不需要后剪枝。 剪枝的意义是：防止决策树生成过于庞大的子叶，避免实验预测结果过拟合，在实际生产中效果很差 剪枝通常有两种： PrePrune：预剪枝，及早的停止树增长，在每个父节点分支的时候计算是否达到了限制值 PostPrune：后剪枝，基于完全生长（过拟合）的树上进行剪枝，砍掉一些对衡量函数影响不大的枝叶 剪枝的依据： 常见的有错误率校验（判断枝剪是降低了模型预测的正确率），统计学检验，熵值，代价复杂度等等 总结看来，枝剪的目的是担心全量数据在某棵树上的拟合过程中，过度判断了每个点及其对应类别的关系，有如以下这张图（以rule1&amp;rule2代替了rule3）： 随机森林： 定义：它是一种模型组合（常见的Boosting，Bagging等，衍生的有gbdt），这些算法最终的结果是生成N(可能会有几百棵以上）棵树，组合判断最终结果。 如何组合判断？ 1.通常我们会规定随机森林里面的每棵树的选参个数，常见的有log，sqrt等等，这样的选取是随机选则的，这样有一个好处，让每一棵树上都有了尽可能多的变量组合，降低过拟合程度 2.树的个数及树的节点的变量个数，通常的来说，最快捷的方式是先确定节点的变量个数为sqrt（变量的个数），然后在根据oob的准确率反过来看多个棵树时最优，确定了树的个数的时候再反过来确定mtry的个数，虽然有局限，但是也并不存在盲目性 3.我个人理解，随机森林中的每一棵树我们需要它在某一片的数据中有非常好的拟合性，它并不是一个全数据拟合，只需要在它负责那块上有最佳的拟合效果。每次遇到这些数据(特征)的时候，我们在最后汇总N棵树的结果的时候，给这些数据对应的那块模型以最高权重即可 最后总结一下，就是随机森林里面的每棵树的产生通过选特征参数选数据结构，都已经考虑了避免共线性避免过拟合，剩下的每棵树需要做的就是尽可能的在自己所对应的数据(特征)集情况下尽可能的做到最好的预测结果；如同，公司已经拆分好部门，你不需要考虑这样拆分是不是公司运营最好的一个组合方式，你需要做的就是当公司需要你的时候，尽可能的做好自己的事情，就酱。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树枝剪问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试之常见决策树异同]]></title>
    <url>%2F2017%2F09%2F01%2F%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%86%B3%E7%AD%96%E6%A0%91%E5%BC%82%E5%90%8C%2F</url>
    <content type="text"><![CDATA[历史回顾：1984年提出的cart，1986年提出的ID3，1993年提出的c4.5 理论上总的来说，C4.5是基于ID3优化后产出的算法，主要优化了关于节点分支的计算方式，优化后解决了ID3分支过程中总喜欢偏向取值较多的属性ID3是信息增益分支： 而CART一般是GINI系数分支： C4.5一般是信息增益率分支： 工程上总的来说：CART和C4.5之间主要差异在于分类结果上，CART可以回归分析也可以分类，C4.5只能做分类；C4.5子节点是可以多分的，而CART是无数个二叉子节点；以此拓展出以CART为基础的“树群”random forest ， 以回归树为基础的“树群”GBDT 样本数据的差异：ID3只能对分类变量进行处理，C4.5和CART可以处理连续和分类两种自变量ID3对缺失值敏感，而C4.5和CART对缺失值可以进行多种方式的处理只从样本量考虑，小样本建议考虑c4.5、大样本建议考虑cart。c4.5处理过程中需对数据集进行多次排序，处理成本耗时较高，而cart本身是一种大样本的统计方法，小样本处理下泛化误差较大 目标因变量的差异：ID3和C4.5只能做分类，CART（分类回归树）不仅可以做分类（0/1）还可以做回归（0-1）ID3和C4.5节点上可以产出多叉（低、中、高），而CART节点上永远是二叉（低、非低） 样本特征上的差异：特征变量的使用中，多分的分类变量ID3和C4.5层级之间只单次使用，CART可多次重复使用 决策树产生过程中的优化差异：C4.5是通过枝剪来修正树的准确性，而CART是直接利用全部数据发现所有树的结构进行对比]]></content>
      <categories>
        <category>基础</category>
      </categories>
      <tags>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SVD及扩展的矩阵分解方法]]></title>
    <url>%2F2017%2F08%2F27%2FSVD%E5%8F%8A%E6%89%A9%E5%B1%95%E7%9A%84%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[svd是现在比较常见的算法之一，也是数据挖掘工程师、算法工程师必备的技能之一，这边就来看一下svd的思想，svd的重写，svd的应用。这边着重的看一下推荐算法中的使用，其实在图片压缩，特征压缩的工程中，svd也有着非常不凡的作用。 svd的思想矩阵因子模型（潜在因子模型）假设，我们现在有一个用户u对商品i的程度矩阵，浏览是1，搜索是2，加车是3，下单是4，付款是5:实际情况下，用户不可能什么商品都买，所以，该矩阵必然是一个稀疏矩阵，任意一个矩阵必然可以被分解成2个矩阵的乘积： k就是潜在因子的个数，举个例子，你去买衣服，你可能买了裙子，露背装，我去买衣服，我买了牛仔裤，潮牌T恤，影响我们购买商品的差异的原因可能有很多点，但是必然有些原因占比重要些，比如性别，收入，有一些可能不那么重要比如天气，心情。而拆分成的Pu矩阵表示了这些潜在因子对我或者你的影响程度，Qi矩阵表示了各种商品对这些潜在因子的影响程度。当我们尽可能的通过拆分矩阵的形式，目标使得拆分后的两个矩阵的乘积最匹配最上方的用户商品矩阵的已知的数据值，从而可以通过这两个矩阵的乘积填补掉空缺的值。 Baseline Predictors这个是08年的，Koren在NetFlix大赛的一个思路，后续也延伸了svd多种变种，比如Asvd，有偏的Rsvd，对偶算法下的Svd++，这些算法的核心在于解决了Svd上面我们提到的那个矩阵庞大稀疏的问题，后续我们再看。 Baseline Predictors使用向量bi表示电影i的评分相对于平均评分的偏差，向量bu表示用户u做出的评分相对于平均评分的偏差，将平均评分记做μ。 新的得分计算方式如下：Rui＝μ+bi+bu准备引入了商品及用户的实际分布的情况，有效的降低在测试数据上面的效果。 svd数学原理首先，线代或者高等代数里面告诉我们：一个向量可以通过左乘一个矩阵的方式来进行拉伸，旋转，或者同时拉伸旋转。所以，无论什么矩阵M，我们都可以找到一组正交基v1、v2，使得Mv1、Mv2也是正交的，不妨记其方向为为μ1、μ2。Mv1=δ1u1；Mv2=δ2u2；存在向量x，在v1、v2空间里的表示为：x=（x·v1）v1+（x·v2）v2，所以有，Mx有：Mx=（x·v1）Mv1+（x·v2）Mv2Mx=（x·v1）δ1u1+（x·v2）δ2u2Mx=δ1u1(v1.T)x+δ2u2(v2.T)xM=δ1u1(v1.T)+δ2u2(v2.T)所以就有了那个非常有名的公式：M=UΣV.TU是有一组正交基构成的，V也是有一组正交基构成的，Σ是由δ1、δ2构成的，几何意义上来说，M的作用就是把一个向量由V的正交空间变换到U的正交空间上，而通过Σ的大小来控制缩放的力度。 我们还需要知道一些简单的推论， 通过MM.T，我们知道，δ的平方是MM.T的特征值 奇异值δ的数量决定了M=UΣV.T的复杂度，而奇异值的大小变化差异程度很大，通常前几个奇异值的平方就能占到全部奇异值的平方的90%，所以，我们可以通过控制奇异值的数量来优化原始矩阵乘积，去除掉一下噪声数据 svd重写基础的svd首先，我们在刚开始就知道，评分矩阵R可以用两个矩阵P和Q的乘积来表示： 其中，U表示用户数，I表示商品数，K=就是潜在因子个数。首先通过那些已知的数据比如下方红色区域内的数据去训练这两个乘积矩阵： 那么未知的评分也就可以用P的某一行乘上Q的某一列得到了： 这是预测用户u对商品i的评分，它等于P矩阵的第u行乘上Q矩阵的第i列。这个是最基本的SVD算法，下面我们们来看如何确定Pu、Qi： 假设已知的评分为：rui则真实值与预测值的误差为： 继而可以计算出总的误差平方和： 只要通过训练把SSE降到最小那么P、Q就能最好地拟合R了。常规的来讲，梯度下降是非常好的求解方式，常见的包括随机梯度下降，批量梯度下降。随机梯度下降一定程度会避免局部最小但是计算量大，批量梯度计算量小但是会存在鞍点计算误区的问题。 先求得SSE在Puk变量（也就是P矩阵的第u行第k列的值）处的梯度： 现在得到了目标函数在Puk处的梯度了，那么按照梯度下降法，将Puk往负梯度方向变化。令更新的步长（也就是学习速率）为 则Puk的更新式为 同样的方式可得到Qik的更新式为 Rsvd很明显，上述这样去求的矩阵QP必然会存在过度拟合的问题，导致对实际数据预测的时候，效果远差于训练数据，仿造elastic net的思维： 对所有的变量就加入正则惩罚项，重新计算上面的梯度如下： 这就是正则svd，也叫做Rsvd，也是我们用的比较多的svd的方法。 偏移Rsvd在最开始讲了，Koren在NetFlix大赛里面除了考虑了对原始数据的拟合情况，也考虑了用户的评分、商品的平均得分相对于整体数据的偏移情况，有了新的得分公式：Rui＝μ+bi+bu，影响的只有eui，后面的Pu、qi的正则不受影响，但是新增了bi、bu的正则项，重新计算每一项的偏导数：bu、bi的更新式子：其余的都不发生改变，这就叫做有偏移下的Rsvd 无论是Rsvd还是有偏移的Rsvd，当原始的用户对商品的评分矩阵过大，比如有3亿用户，3亿商品，形成9亿商品集合的时候，这就是一个比较不可能完成的存储任务，而且里面绝大多数都是0的稀疏矩阵。 Asvd及Svd++这边，我们引入两个集合：R(u)表示用户u评过分的商品集合，N(u)表示用户u浏览过但没有评过分的商品集合，Xj和Yj是商品的属性。Asvd的rui的评分方式： Svd++的rui的评分方式： 无论是Asvd还是Svd++，都干掉了原来庞大的P矩阵，取而代之的是两个用户浏览评分矩阵大大缩小了存储的空间，但是随着而来的是一大把更多的未知参数及迭代的复杂程度，所有在训练时间上而言，会大大的增加。 我这边只重写了一下Rsvd的python版本，网上挺多版本的迭代条件有一定问题，稍作处理了一下，并写成了函数，大家可以参考一下：1234567891011121314151617181920212223242526272829303132333435def svd(mat, feature, steps=2000, gama=0.02, lamda=0.3): #feature是潜在因子的数量，mat为评分矩阵 slowRate = 0.99 preRmse = 0.0000000000001 nowRmse = 0.0 user_feature = matrix(numpy.random.rand(mat.shape[0], feature)) item_feature = matrix(numpy.random.rand(mat.shape[1], feature)) for step in range(steps): rmse = 0.0 n = 0 for u in range(mat.shape[0]): for i in range(mat.shape[1]): if not numpy.isnan(mat[u,i]): #这边是判断是否为空，也可以改为是否为0:if mat[u,i]&gt;0: pui = float(numpy.dot(user_feature[u,:], item_feature[i,:].T)) eui = mat[u,i] - pui rmse += pow(eui, 2) n += 1 for k in range(feature): #Rsvd的更新迭代公式 user_feature[u,k] += gama*(eui*item_feature[i,k] - lamda*user_feature[u,k]) item_feature[i,k] += gama*(eui*user_feature[u,k] - lamda*item_feature[i,k])#n次迭代平均误差程度 nowRmse = sqrt(rmse * 1.0 / n) print 'step: %d Rmse: %s' % ((step+1), nowRmse) if (nowRmse &gt; preRmse): pass else: break #降低迭代的步长 gama *= slowRate step += 1 return user_feature, item_feature 直接调用的结果如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768step: 1956 Rmse: 0.782449675844step: 1957 Rmse: 0.782449675843step: 1958 Rmse: 0.782449675843step: 1959 Rmse: 0.782449675843step: 1960 Rmse: 0.782449675842step: 1961 Rmse: 0.782449675842step: 1962 Rmse: 0.782449675842step: 1963 Rmse: 0.782449675841step: 1964 Rmse: 0.782449675841step: 1965 Rmse: 0.78244967584step: 1966 Rmse: 0.78244967584step: 1967 Rmse: 0.78244967584step: 1968 Rmse: 0.782449675839step: 1969 Rmse: 0.782449675839step: 1970 Rmse: 0.782449675839step: 1971 Rmse: 0.782449675838step: 1972 Rmse: 0.782449675838step: 1973 Rmse: 0.782449675838step: 1974 Rmse: 0.782449675837step: 1975 Rmse: 0.782449675837step: 1976 Rmse: 0.782449675837step: 1977 Rmse: 0.782449675836step: 1978 Rmse: 0.782449675836step: 1979 Rmse: 0.782449675836step: 1980 Rmse: 0.782449675835step: 1981 Rmse: 0.782449675835step: 1982 Rmse: 0.782449675835step: 1983 Rmse: 0.782449675835step: 1984 Rmse: 0.782449675834step: 1985 Rmse: 0.782449675834step: 1986 Rmse: 0.782449675834step: 1987 Rmse: 0.782449675833step: 1988 Rmse: 0.782449675833step: 1989 Rmse: 0.782449675833step: 1990 Rmse: 0.782449675833step: 1991 Rmse: 0.782449675832step: 1992 Rmse: 0.782449675832step: 1993 Rmse: 0.782449675832step: 1994 Rmse: 0.782449675831step: 1995 Rmse: 0.782449675831step: 1996 Rmse: 0.782449675831step: 1997 Rmse: 0.782449675831step: 1998 Rmse: 0.78244967583step: 1999 Rmse: 0.78244967583step: 2000 Rmse: 0.78244967583Out[15]:(matrix([[-0.72426432, 0.40007415, 1.16887518],[-0.73130968, 0.40240702, 1.14708432],[ 0.34759923, 1.35065656, -0.29573789],[ 1.17462156, -0.04964694, 0.73881335],[ 2.04035441, -0.06798676, 1.28078727],[ 0.30446306, 1.71648612, -0.4109819 ],[ 1.71963828, -0.00833196, 1.25983483],[-0.86341514, 0.47750529, 1.36135332],[-0.48881234, 0.57942923, 0.77110915],[ 0.29282908, 1.5164249 , -0.39811768],[ 0.35369432, -0.00964055, 0.22328158]]),matrix([[ 1.3381854 , -0.05425608, 0.87036818],[ 1.07547853, -0.04515239, 0.69607952],[ 1.39038494, -0.05799558, 0.90186332],[-0.60218508, 0.36233309, 0.92136536],[ 0.39117217, 1.9272062 , -0.50710187],[-0.93202395, 0.52982297, 1.43309143],[-0.19393338, 0.40429152, 0.29994372],[ 1.40108031, 0.06915628, 0.87647945],[ 1.39446638, -0.05197355, 0.920216 ],[ 0.31981929, 1.84114505, -0.40108819],[-0.82317832, 0.52798144, 1.51619052]])) svd在推荐算法中的使用数据集中行代表用户user，列代表物品item，其中的值代表用户对物品的打分。基于SVD的优势在于：用户的评分数据是稀疏矩阵，可以用SVD将原始数据映射到低维空间中，然后计算物品item之间的相似度，更加高效快速。 整体思路：用户未知得分的商品评分计算方式：1.用户的评分矩阵==》用户已经评分过得商品的得分2.商品的用户评分==》用户已经评分过得商品和其他每个商品的相关性3.“用户已经评分过得商品的得分”*“用户已经评分过得商品和某个未知评分商品的相关系数”=某个未知商品该用户的评分 计算上面三个步骤，我们需要：1.考虑采取上面相关性的计算方式2.考虑潜在因子的个数 依旧python代码，我会在代码中注释讲解：1.首先相关性1234567891011121314151617181920212223242526272829# 欧拉距离相似度，评分可用，程度不建议def oulasim(A, B): distince = la.norm(A - B) # 第二范式：平方的和后求根号 similarity = 1 / (1 + distince) return similarity# 余弦相似度，评分、1/0、程度都可以用def cossim(A, B): ABDOT = float(dot(A, B)) ABlen = la.norm(A) * la.norm(B) if ABlen == 0: similarity = '异常' else: similarity = ABDOT / float(ABlen) return similarity# 皮尔逊相关系数def pearsonsim(A, B): A = A - mean(A) B = B - mean(B) ABDOT = float(dot(A, B)) ABlen = la.norm(A) * la.norm(B) if ABlen == 0: similarity = '异常' else: similarity = ABDOT / float(ABlen) return similarity 2.指定用户及对应商品的相似度123456789101112131415161718192021222324252627282930# svddef recommender(datamat,user,index,function): n = shape(datamat)[1] # 商品数目 U, sigma, VT = la.svd(datamat) # 规约最小维数 sigma2 = sigma ** 2 k = len(sigma2) n_sum2 = sum(sigma2) nsum = 0 max_sigma_index = 0#奇异值的平方占比总数的90%，确定潜在因子数 for i in sigma: nsum = nsum + i ** 2 max_sigma_index = max_sigma_index + 1 if nsum &gt;= n_sum2 * 0.9: break # item new matrix item = datamat.T * U[:, 0:max_sigma_index] * matrix(diag(sigma[0:max_sigma_index])).I key=item[index,:] total_similarity=0 rank_similarity=0 for i in range(k):#如果用户没有评分或者与用户选择想知道的商品一致则跳过，不跳过计算出来前者是得分0，后者直接是用户已评分的结果，没有意义 if datamat[user,i]==0 or i==index:continue similarity=function(key,item[i,:].T) total_similarity=total_similarity+similarity#用户的评分*相关系数 rank_similarity=rank_similarity+similarity*datamat[user,i]*similarity score = rank_similarity/total_similarity return score 比如：用户1在商品1的得分为3.99分12In [18]: recommender(data,1,1,cossim)Out[18]: 3.98921610058786 3.指定商品，与所有其它商品的相似度123456789101112def recommender(datamat, item_set, method): col = shape(datamat)[1] # 物品数量 item = datamat[:, item_set] similarity_matrix = zeros([col, 1]) for i in range(col): index = nonzero(logical_and(item &gt; 0, datamat[:, i] &gt; 0))[0] if sum(index) &gt; 0: similarity = method(datamat[index, item_set].T, datamat[index, i]) else: similarity = '-1' similarity_matrix[i] = similarity return similarity_matrix 比如：商品0，对其它所有商品的相似度：12345678910111213In [24]: recommender(data,0,cossim)Out[24]:array([[ 1. ],[ 0.99439606],[ 0.99278096],[-1. ],[-1. ],[-1. ],[-1. ],[ 0.98183139],[ 0.97448865],[-1. ],[ 1. ]]) 4.直接算出所有商品间的相似度：1234567def similarity(datamat, method): item_sum = shape(datamat)[1] similarity = pd.DataFrame([]) for i in range(item_sum): res = recommender(datamat, i, method) similarity = pd.concat([similarity, pd.DataFrame(res)], axis=1) return similarity_matrix 比如商品的相似矩阵：123456789101112131415161718192021222324252627In [25]: similarity(data,cossim)Out[25]:0 0 0 0 0 0 0 \0 1.000000 0.994396 0.992781 -1.000000 -1.000000 -1.000000 -1.0000001 0.994396 1.000000 0.999484 -1.000000 -1.000000 -1.000000 -1.0000002 0.992781 0.999484 1.000000 -1.000000 -1.000000 -1.000000 -1.0000003 -1.000000 -1.000000 -1.000000 1.000000 -1.000000 0.990375 1.0000004 -1.000000 -1.000000 -1.000000 -1.000000 1.000000 -1.000000 1.0000005 -1.000000 -1.000000 -1.000000 0.990375 -1.000000 1.000000 1.0000006 -1.000000 -1.000000 -1.000000 1.000000 1.000000 1.000000 1.0000007 0.981831 0.956858 0.955304 -1.000000 1.000000 -1.000000 -1.0000008 0.974489 0.956858 0.955304 -1.000000 -1.000000 -1.000000 -1.0000009 -1.000000 -1.000000 -1.000000 1.000000 0.994536 1.000000 0.38461510 1.000000 1.000000 1.000000 1.000000 -1.000000 0.981307 1.0000000 0 0 00 0.981831 0.974489 -1.000000 1.0000001 0.956858 0.956858 -1.000000 1.0000002 0.955304 0.955304 -1.000000 1.0000003 -1.000000 -1.000000 1.000000 1.0000004 1.000000 -1.000000 0.994536 -1.0000005 -1.000000 -1.000000 1.000000 0.9813076 -1.000000 -1.000000 0.384615 1.0000007 1.000000 0.991500 1.000000 1.0000008 0.991500 1.000000 -1.000000 1.0000009 1.000000 -1.000000 1.000000 1.00000010 1.000000 1.000000 1.000000 1.000000 5.指定用户下的top5商品推荐123456789def fianl_recommender(datamat,user,function): unratedItems=nonzero(datamat[user,:].A==0)[1] if len(unratedItems)==0: print &apos;ok&apos; score=[] for i in unratedItems: i_score=recommender(datamat,user,i,function) score.append((i,i_score)) score=sorted(score,key=lambda x:x[1],reverse=True) return score[:5] 比如指定用户1，最适合推荐的商品如下：1234567In [31]: fianl_recommender(data,1,pearsonsim)Out[31]:[(7, 3.3356853252871588),(8, 3.3349455396520296),(0, 3.33492840157654),(2, 3.334920725716121),(1, 3.334919898261294)] 最后，谢谢大家阅读。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>矩阵分解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深度学习下的电商商品推荐]]></title>
    <url>%2F2017%2F08%2F19%2F%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E4%B8%8B%E7%9A%84%E7%94%B5%E5%95%86%E5%95%86%E5%93%81%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[常见算法套路电商行业中，对于用户的商品推荐一直是一个非常热门而且重要的话题，有很多比较成熟的方法，但是也各有利弊，大致如下： 基于商品内容：比如食物A和食物B，对于它们价格、味道、保质期、品牌等维度，可以计算它们的相似程度，可以想象，我买了包子，很有可能顺路带一盒水饺回家。优点：冷启动，其实只要你有商品的数据，在业务初期用户数据不多的情况下，也可以做推荐缺点：预处理复杂，任何一件商品，维度可以说至少可以上百，如何选取合适的维度进行计算，设计到工程经验，这些也是花钱买不到的典型：亚马逊早期的推荐系统 基于关联规则：最常见的就是通过用户购买的习惯，经典的就是“啤酒尿布”的案例，但是实际运营中这种方法运用的也是最少的，首先要做关联规则，数据量一定要充足，否则置信度太低，当数据量上升了，我们有更多优秀的方法，可以说没有什么亮点，业内的算法有apriori、ftgrowth之类的优点：简单易操作，上手速度快，部署起来也非常方便缺点：需要有较多的数据，精度效果一般典型：早期运营商的套餐推荐 基于物品的协同推荐：假设物品A被小张、小明、小董买过，物品B被小红、小丽、小晨买过，物品C被小张、小明、小李买过；直观的看来，物品A和物品C的购买人群相似度更高（相对于物品B），现在我们可以对小董推荐物品C，小李推荐物品A，这个推荐算法比较成熟，运用的公司也比较多优点：相对精准，结果可解释性强，副产物可以得出商品热门排序缺点：计算复杂，数据存储瓶颈，冷门物品推荐效果差典型：早期一号店商品推荐 基于用户的协同推荐：假设用户A买过可乐、雪碧、火锅底料，用户B买过卫生纸、衣服、鞋，用户C买过火锅、果汁、七喜；直观上来看，用户A和用户C相似度更高（相对于用户B），现在我们可以对用户A推荐用户C买过的其他东西，对用户C推荐用户A买过买过的其他东西，优缺点与基于物品的协同推荐类似，不重复了。 基于模型的推荐：svd++、特征值分解、概率图、聚分类等等。比如潜在因子分解模型，将用户的购买行为的矩阵拆分成两组权重矩阵的乘积，一组矩阵代表用户的行为特征，一组矩阵代表商品的重要性，在用户推荐过程中，计算该用户在历史训练矩阵下的各商品的可能性进行推荐。优点：精准，对于冷门的商品也有很不错的推荐效果缺点：计算量非常大，矩阵拆分的效能及能力瓶颈一直是受约束的典型：惠普的电脑推荐 基于时序的推荐：这个比较特别，在电商运用的少，在Twitter，Facebook，豆瓣运用的比较多，就是只有赞同和反对的情况下，怎么进行评论排序，详细的可以参见我之前写的一篇文章：应用：推荐系统-威尔逊区间法 基于深度学习的推荐：现在比较火的CNN(卷积神经网络)、RNN(循环神经网络)、DNN(深度神经网络)都有运用在推荐上面的例子，但是都还是试验阶段，但是有个基于word2vec的方法已经相对比较成熟，也是我们今天介绍的重点。优点：推荐效果非常精准，所需要的基础存储资源较少缺点：工程运用不成熟，模型训练调参技巧难典型：当前电商的会员商品推荐 item2vec的工程引入现在某电商的商品有约3亿个，商品的类目有10000多组，大的品类也有近40个，如果通过传统的协同推荐，实时计算的话，服务器成本，计算能力都是非常大的局限，之前已经有过几篇应用介绍：基于推荐的交叉销售、基于用户行为的推荐预估。会员研发部门因为不是主要推荐的应用部门，所以在选择上，我们期望的是更加高效高速且相对准确的简约版模型方式，所以我们这边基于了word2vec的原始算法，仿造了itemNvec的方式。 首先，让我们对itemNvec进行理论拆分： part one：n-gram目标商品的前后商品对目标商品的影响程度这是两个用户userA，userB在易购上面的消费time line，灰色方框内为我们观察对象，试问一下，如果换一下灰色方框内的userA、userB的购买物品，直观的可能性有多大？ 直观的体验告诉我们，这是不可能出现，或者绝对不是常出现的，所以，我们就有一个初始的假设，对于某些用户在特定的类目下，用户的消费行为是连续影响的，换句话说，就是我买了什么东西是依赖我之前买过什么东西。如何通过算法语言解释上面说的这件事呢？大家回想一下，naive bayes做垃圾邮件分类的时候是怎么做的？假设“我公司可以提供发票、军火出售、航母维修”这句话是不是垃圾邮件？ P1(“垃圾邮件”|“我公司可以提供发票、军火出售、航母维修”)=p(“垃圾邮件”)p(“我公司可以提供发票、军火出售、航母维修”/“垃圾邮件”)/p(“我公司可以提供发票、军火出售、航母维修”)=p(“垃圾邮件”)p(“发票”，“军火”，“航母”/“垃圾邮件”)/p(“发票”，“军火”，“航母”) 同理P2(“正常邮件”|“我公司可以提供发票、军火出售、航母维修”)=p(“正常邮件”)p(“发票”，“军火”，“航母”/“正常邮件”)/p(“发票”，“军火”，“航母”) 我们只需要比较p1和p2的大小即可，在条件独立的情况下可以直接写成：P1(“垃圾邮件”|“我公司可以提供发票、军火出售、航母维修”)=p(“垃圾邮件”)p(“发票”/“垃圾邮件”)p(“军火”/“垃圾邮件”)p(“航母”/“垃圾邮件”)P2(“正常邮件”|“我公司可以提供发票、军火出售、航母维修”)=p(“正常邮件”)p(“发票”/“正常邮件”)p(“军火”/“正常邮件”)p(“航母”/“正常邮件”) 但是，我们看到，无论“我公司可以提供发票、军火出售、航母维修”词语的顺序怎么变化，不影响它最后的结果判定，但是我们这边的需求里面前面买的东西对后项的影响会更大。冰箱=&gt;洗衣机=&gt;衣柜=&gt;电视=&gt;汽水，这样的下单流程合理冰箱=&gt;洗衣机=&gt;汽水=&gt;电视=&gt;衣柜，这样的下单流程相对来讲可能性会更低但是对于naive bayes，它们是一致的。所以，我们这边考虑顺序，还是上面那个垃圾邮件的问题。P1(“垃圾邮件”|“我公司可以提供发票、军火出售、航母维修”)=p(“垃圾邮件”)p(“发票”)p(“军火”/“发票”)p(“军火”/“航母”)P1(“正常邮件”|“我公司可以提供发票、军火出售、航母维修”)=p(“正常邮件”)p(“发票”)p(“军火”/“发票”)p(“军火”/“航母”)这边我们每个词只依赖前一个词，理论上讲依赖1-3个词通常都是可接受的。以上的考虑顺序的bayes就是基于著名的马尔科夫假设（Markov Assumption）：下一个词的出现仅依赖于它前面的一个或几个词下的联合概率问题，相关详细的理论数学公式就不给出了，这边这涉及一个思想。 part two：Huffman Coding更大的数据存储形式我们常用的user到item的映射是通过one hot encoding的形式去实现的，这有一个非常大的弊端就是数据存储系数且维度灾难可能性极大。回到最初的那组数据：现在商品有约4亿个，商品的类目有10000多组，大的品类也有近40个，同时现在会员数目达到5亿，要是需要建造一个用户商品对应的购买关系矩阵做基于用户的协同推荐的话，我们需要做一个4亿X6亿的1/0矩阵，这个是几乎不可能的，Huffman采取了一个近似二叉树的形式进行存储：我们以商品购买量为例，讲解一下如何以二叉树的形式替换one hot encoding存储方式：假设，促销期间，经过统计，有冰箱=&gt;洗衣机=&gt;烘干机=&gt;电视=&gt;衣柜=&gt;钻石的用户下单链条（及购买物品顺序如上），其中冰箱总售出15万台，洗衣机总售出8万台，烘干机总售出6万台，电视总售出5万台，衣柜总售出3万台，钻石总售出1万颗 12341.给定&#123;15,8,6,5,3,1&#125;为二叉树的节点，每个树仅有一个节点，那就存在6颗单独的树2.选择节点权重值最小的两颗树进行合并也就是&#123;3&#125;、&#123;1&#125;，合并后计算新权重3+1=43.将&#123;3&#125;，&#123;1&#125;树从节点列表删除，将3+1=4的新组合树放回原节点列表4.重新进行2-3，直到只剩一棵树为止 针对每层每次分支过程，我们可以将所有权重大的节点看做是1，权重小的节点看做是0，相反亦可。现在，我们比如需要知道钻石的code，就是1000，也就是灰色方框的位置，洗衣机的code就是111；这样的存储利用了0/1的存储方式，也同时考虑了组合位置的排列长度，节省了数据的存储空间。 part three：node probility最大化当前数据出现可能的概率密度函数对于钻石的位置而言，它的Huffman code是1000，那就意味着在每一次二叉选择的时候，它需要一次被分到1，三次被分到0，而且每次分的过程中，只有1/0可以选择，这是不是和logistic regression里面的0/1分类相似，所以这边我们也直接使用了lr里面的交叉熵来作为loss function。 其实对于很多机器学习的算法而言，都是按照先假定一个模型，再构造一个损失函数，通过数据来训练损失函数求argmin(损失函数)的参数，放回到原模型。 让我们详细的看这个钻石这个例子： p(1|No.1层未知参数)=sigmoid(No.1层未知参数) p(0|No.2层未知参数)=sigmoid(No.2层未知参数)同理，第三第四层：p(0|No.3层未知参数)=sigmoid(No.3层未知参数)p(0|No.4层未知参数)=sigmoid(No.4层未知参数)然后求p(1|No.1层未知参数)xp(0|No.2层未知参数)xp(0|No.3层未知参数)xp(0|No.4层未知参数)最大下对应的每层的未知参数即可，求解方式与logistic求解方式近似，未知参数分布偏导，后续采用梯度下降的方式（极大、批量、牛顿按需使用） part four：approximate nerual network商品的相似度刚才在part three里面有个p(1|No.1层未知参数)这个逻辑，这个NO.1层未知参数里面有一个就是商品向量。举个例子：存在1000万个用户有过：“啤酒=&gt;西瓜=&gt;剃须刀=&gt;百事可乐”的商品购买顺序10万个用户有过：“啤酒=&gt;苹果=&gt;剃须刀=&gt;百事可乐”的商品购买顺序，如果按照传统的概率模型比如navie bayes 或者n-gram来看，P（啤酒=&gt;西瓜=&gt;剃须刀=&gt;百事可乐）&gt;&gt;p（啤酒=&gt;苹果=&gt;剃须刀=&gt;百事可乐），但是实际上这两者的人群应该是同一波人，他们的属性特征一定会是一样的才对。 我们这边通过了随机初始化每个商品的特征向量，然后通过part three的概率模型去训练，最后确定了词向量的大小。除此之外，还可以通过神经网络算法去做这样的事情。 Bengio 等人在 2001 年发表在 NIPS 上的文章《A Neural Probabilistic Language Model》介绍了详细的方法。我们这边需要知道的就是，对于最小维度商品，我们以商品向量（0.8213，0.8232，0.6613，0.1234，…）的形式替代了0-1点（0，0，0，0，0，1，0，0，0，0…），单个的商品向量无意义，但是成对的商品向量我们就可以比较他们间的余弦相似度，就可以比较类目的相似度，甚至品类的相似度。 python代码实现1.数据读取12345678910# -*- coding:utf-8 -*-import pandas as pdimport numpy as npimport matplotlib as mtfrom gensim.models import word2vecfrom sklearn.model_selection import train_test_splitorder_data = pd.read_table(&apos;C:/Users/17031877/Desktop/SuNing/cross_sell_data_tmp1.txt&apos;)dealed_data = order_data.drop(&apos;member_id&apos;, axis=1)dealed_data = pd.DataFrame(dealed_data).fillna(value=&apos;&apos;) 2.简单的数据合并整理12345678910# 数据合并dealed_data = dealed_data[&apos;top10&apos;] + [&quot; &quot;] + dealed_data[&apos;top9&apos;] + [&quot; &quot;] + dealed_data[&apos;top8&apos;] + [&quot; &quot;] + \dealed_data[&apos;top7&apos;] + [&quot; &quot;] + dealed_data[&apos;top6&apos;] + [&quot; &quot;] + dealed_data[&apos;top5&apos;] + [&quot; &quot;] + dealed_data[&apos;top4&apos;] + [&quot; &quot;] + dealed_data[&apos;top3&apos;] + [&quot; &quot;] + dealed_data[&apos;top2&apos;] + [&quot; &quot;] + dealed_data[&apos;top1&apos;]# 数据分列dealed_data = [s.encode(&apos;utf-8&apos;).split() for s in dealed_data]# 数据拆分train_data, test_data = train_test_split(dealed_data, test_size=0.3, random_state=42) 3.模型训练12345# 原始数据训练# sg=1,skipgram;sg=0,SBOW# hs=1:hierarchical softmax,huffmantree# nagative = 0 非负采样model = word2vec.Word2Vec(train_data, sg=1, min_count=10, window=2, hs=1, negative=0) 接下来就是用model来训练得到我们的推荐商品，这边有三个思路，可以根据具体的业务需求和实际数据量来选择：3.1 相似商品映射表12345678910111213# 最后一次浏览商品最相似的商品组top3x = 1000result = []result = pd.DataFrame(result)for i in range(x): test_data_split = [s.encode(&apos;utf-8&apos;).split() for s in test_data[i]] k = len(test_data_split) last_one = test_data_split[k - 1] last_one_recommended = model.most_similar(last_one, topn=3) tmp = last_one_recommended[0] + last_one_recommended[1] + last_one_recommended[2] last_one_recommended = pd.concat([pd.DataFrame(last_one), pd.DataFrame(np.array(tmp))], axis=0) last_one_recommended = last_one_recommended.T result = pd.concat([pd.DataFrame(last_one_recommended), result], axis=0) 考虑用户最后一次操作的关注物品x，干掉那些已经被用户购买的商品，剩下的商品表示用户依旧有兴趣但是因为没找到合适的或者便宜的商品，通过商品向量之间的相似度，可以直接计算出，与其高度相似的商品推荐给用户。 3.2 最大可能购买商品根据历史上用户依旧购买的商品顺序，判断根据当前这个目标用户近期买的商品，接下来他最有可能买什么？比如历史数据告诉我们，购买了手机+电脑的用户，后一周内最大可能会购买背包，那我们就针对那些近期购买了电脑+手机的用户去推送电脑包的商品给他，刺激他的潜在规律需求。123456789101112131415161718192021222324252627282930# 向量库rbind_data = pd.concat([order_data[&apos;top1&apos;], order_data[&apos;top2&apos;], order_data[&apos;top3&apos;], order_data[&apos;top4&apos;], order_data[&apos;top5&apos;],order_data[&apos;top6&apos;], order_data[&apos;top7&apos;], order_data[&apos;top8&apos;], order_data[&apos;top9&apos;], order_data[&apos;top10&apos;]], axis=0)x = 50start = []output = []score_final = []for i in range(x): score = np.array(-100000000000000) name = np.array(-100000000000000) newscore = np.array(-100000000000000) tmp = test_data[i] k = len(tmp) last_one = tmp[k - 2] tmp = tmp[0:(k - 1)]for j in range(number): tmp1 = tmp[:] target = rbind_data_level[j] tmp1.append(target) test_data_split = [tmp1] newscore = model.score(test_data_split) if newscore &gt; score: score = newscore name = tmp1[len(tmp1) - 1] else: pass start.append(last_one) output.append(name) score_final.append(score) 3.3 联想记忆推荐在3.2中，我们根据了这个用户近期购买行为，从历史已购用户的购买行为数据发现规律，提供推荐的商品。还有一个近似的逻辑，就是通过目标用户最近一次的购买商品进行推测，参考的是历史用户的单次购买附近的数据，详细如下： 这个实现也非常的简单，这边代码我自己也没有写，就不贴了，采用的还是word2vec里面的predict_output_word(context_words_list, topn=10)，Report the probability distribution of the center word given the context words as input to the trained model 其实，这边详细做起来还是比较复杂的，我这边也是简单的贴了一些思路，如果有不明白的可以私信我，就这样，最后，谢谢阅读。]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于自然语言识别下的流失用户预警]]></title>
    <url>%2F2017%2F08%2F15%2F%E5%9F%BA%E4%BA%8E%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E8%AF%86%E5%88%AB%E4%B8%8B%E7%9A%84%E6%B5%81%E5%A4%B1%E7%94%A8%E6%88%B7%E9%A2%84%E8%AD%A6%2F</url>
    <content type="text"><![CDATA[update:17.12.20 : 关于IDF处描述，经@余海跃同学提醒，细化了解释内容，感谢！ 在电商运营过程中，会有大量的用户反馈留言，包括吐槽的差评，商品不满的地方等等，在用户运营生态中，这部分用户是最有可能流失也是最影响nps的人群，通过对其评价的语义分析，每日找出潜在的流失人群进行包括”电话回访”,”补券安慰”，”特权享受”等行为，有效的降低了用户的流失。根据实际的业务营销效果，在模型上线后，abtest检验下模型识别用户人群进行营销后的流失率比随意营销下降9.2%，效果显著。 当前文本文义识别存在一些问题：（1）准确率而言，很多线上数据对特征分解的过程比较粗糙，很多直接基于df或者idf结果进行排序，在算法设计过程中，也是直接套用模型，只是工程上的实现，缺乏统计意义上的分析； （2）文本越多，特征矩阵越稀疏，计算过程越复杂。常规的文本处理过程中只会对文本对应的特征值进行排序，其实在文本选择中，可以先剔除相似度较高的文本，这个课题比较大，后续会单独开一章进行研究； （3）扩展性较差。比如我们这次做的流失用户预警是基于电商数据，你拿去做通信商的用户流失衡量的话，其质量会大大下降，所以重复开发的成本较高，这个属于非增强学习的硬伤，目前也在攻克这方面的问题。 首先，我们来看下，整个算法设计的思路：1234567891.通过hive将近期的用户评价hadoop文件下载为若干个text文件2.通过R语言将若干个text整合读取为一个R内的dataframe3.利用R里面的正则函数将文本中的异常符号‘#！@￥%%’，英文，标点等去除（这边可以在hive里面提前处理好，也可以在后续的分词过程中利用停顿词去除）4.文本分词，这边可以利用R中的Rwordseg，jiebaR等，我写这篇文章之前看到很多现有的语义分析的文章中，Rwordseg用的挺多，所以这边我采用了jiebaR5.文本分词特征值提取,常见的包括互信息熵，信息增益，tf-idf，本文采取了tf-idf，剩余方法会在后续文章中更新6.模型训练这边我采取的方式是利用概率模型naive bayes+非线性模型random forest先做标签训练，最后用nerual network对结果进行重估（原本我以为这样去做会导致很严重的过拟合，但是在实际操作之后发现，过拟合并不是很严重，至于原因我也不算很清楚，后续抽空可以研究一下） 下面，我们来剖析文本分类识别的每一步 定义用户属性首先，我们定义了已经存在的流失用户及非流失用户，易购的用户某品类下的购买周期为27天，针对前60天-前30天下单购物的用户，观察近30天是否有下单行为，如果有则为非流失用户，如果没有则为流失用户。提取每一个用户最近一次商品评价作为msg。 文本合成通过hive -e的方式下载到本地，会形成text01，text02…等若干个文本，通过R进行文本整合：12345678910111213141516171819#先设置文本路径path &lt;- &quot;C:/Users/17031877/Desktop/Nlp/answer/Cmsg&quot;completepath &lt;- list.files(path, pattern = &quot;*.txt$&quot;, full.names = TRUE)#批量读入文本readtxt &lt;- function(x) &#123; ret &lt;- readLines(x) #每行读取 return(paste(ret, collapse = &quot;&quot;)) #通过paste将每一行连接起来 &#125; #lappy批量操作，形成list，个人感觉对非关系数据，list处理更加便捷msg &lt;- lapply(completepath, readtxt)#用户属性user_status &lt;- list.files(path, pattern = &quot;*.txt$&quot;)#stringsAsFactors=F，避免很多文本被读成因子类型comment &lt;- as.data.frame(cbind(user_status, unlist(msg)),stringsAsFactors = F)colnames(comment) &lt;- c(&quot;user_status&quot;, &quot;msg&quot;) 基础的数据整合就完成了。 数据整理也可以看到，基础数据读取完成后，还是很多评论会有一些不规则的数据，包括‘#￥%……&amp;’，英文，数字，下面通过正则、停顿词的方式进行处理： 正则化处理123456789101112131415161718192021222324252627282930#直接处理comment$msg &lt;- gsub(pattern = &quot; &quot;, replacement =&quot;&quot;, comment$msg) #gsub是字符替换函数，去空格comment$msg&lt;- gsub(&quot;[[:digit:]]*&quot;, &quot;&quot;, comment$msg) #清除数字[a-zA-Z]comment$msg&lt;- gsub(&quot;[a-zA-Z]&quot;, &quot;&quot;, comment$msg) #清除英文字符comment$msg&lt;- gsub(&quot;\\.&quot;, &quot;&quot;, comment$msg) #清除全英文的dot符号--------------------------------------------------------------------------------------------------#如果是常做nlp处理，可以写成函数打包，后期直接library就可以了#数值删除removeNumbers = function(x)&#123; ret = gsub(&quot;[0-9]&quot;,&quot;&quot;,x) return(ret) &#125; #字符删除removeLiters = function(x)&#123; ret = gsub(&quot;[a-z|A-Z]&quot;,&quot;&quot;,x) return(ret) &#125; #各种操作符处理,\s表示空格,\r表示回车,\n表示换行removeActions = function(x)&#123; ret = gsub(&quot;\\s|\\r|\\n&quot;, &quot;&quot;, x) return(ret) &#125; comment$msg=removeNumbers(comment$msg)comment$msg=removeLiters(comment$msg)comment$msg=removeActions (comment$msg) 这边需要对正则化里面的一些表示有所了解，详细可以百度，一般我都是具体需求具体去看，因为太多，自己又懒，所以没记 停顿词12345#加载jiebaR包library(jiebaR)#找jiebaR存停顿词的地方，自行将需要处理掉的符号存进去，我这边是C:/Program Files/R/R-3.3.3/library/jiebaRD/dict/stop_words.utf8tagger&lt;-worker(stop_word=&quot;C:/Program Files/R/R-3.3.3/library/jiebaRD/dict/stop_words.utf8&quot;) 至于位置可以通过直接输入worker()查看， 当前的是没有stop_word的，所有词存储的位置在：C:/Program Files/R/R-3.3.3/library/jiebaRD/dict/下 文本分词12345678#jieba 分词,去除停顿词library(jiebaR)tagger&lt;-worker(stop_word=&quot;C:/Program Files/R/R-3.3.3/library/jiebaRD/dict/stop_words.utf8&quot;)words=list()for (i in 1:nrow(comment))&#123; tmp=tagger[comment[i,2]] words=c(words,list(tmp))&#125; 直接先分词，但是分词结果会存在很多只有一个字比如‘的’、‘你’、‘我’等或者很多无意义的长句‘中华人民共和国’、‘长使英雄泪满襟’等，需要把这些词长异常明显无意义的词句去掉。1234567891011121314151617181920212223242526#词长统计whole_words_set=unlist(words)whole_words_set_rank=data.frame(table(whole_words_set))whole_words_set_dealed=c()for (i in 1:nrow(whole_words_set_rank))&#123; tmp=nchar(as.character(whole_words_set_rank[i,1])) whole_words_set_dealed=c(whole_words_set_dealed,tmp)&#125;whole_words_set_dealed=cbind(whole_words_set_rank,whole_words_set_dealed)whole_words_set_dealed=whole_words_set_dealed[whole_words_set_dealed$whole_words_set_dealed&gt;1&amp;whole_words_set_dealed$whole_words_set_dealed&lt;5,]whole_words_set_dealed=whole_words_set_dealed[order(whole_words_set_dealed$Freq,decreasing=T),]#words的删除异常值,排序whole_words_set_sequence=wordskey_word=nrow(words)for (i in 1:key_word)&#123; for (j in 1:length(words[[i]]))&#123; tmp=ifelse(nchar(words[[i]][j])&gt;1 &amp; nchar(words[[i]][j])&lt;5,words[[i]][j],&apos;&apos;) whole_words_set_sequence[[i]][j]=tmp &#125;&#125;for (i in 1:key_word)&#123; whole_words_set_sequence[[i]]=whole_words_set_sequence[[i]][whole_words_set_sequence[[i]]!=&apos;&apos;]&#125; tf-idf词特征值重要性排序首先，我们大致看一下排序的数据依旧： TF = 某词在文章中出现的次数/文章包含的总词数（或者文章有价值词次数）DF = （包含某词的文档数）/（语料库的文档总数）IDF = log（（语料库的文档总数）/（包含某词的文档数+1））这边的+1是为了避免（语料库的文档总数）/（包含某词的文档数）=1，log(1)=0，使得最后的重要性中出现0的情况，与有意义的前提相互驳斥。TF-IDF = TF*IDF 分别看下，里面的每一项的意义：TF，我们可以看出，在同一个评论中，词数出现的越多，代表这个词越能成为这篇文章的代表，当然前提是非无意义的助词等。 IDF，我们可以看出，所以评论中，包含目标词的评论的占比，占比数越高，目标词的意义越大，假设1000条评论中，“丧心病狂”在一条评论里面重复了10次，但是其他999条里面一次也没有出现，那就算“丧心病狂”非常能代表这条评论，但是在做文本集特征考虑的情况下，它的价值也是不大的。 注意，经@余海跃同学提醒，这边的IDF解释不清晰，详细剖析如下：首先idf的定义是如下这样的：（D为所有文章，d为单篇文章）通常，会考虑类似近拉普拉斯平滑（+1）这样的方法修正idf值，在NLP领域，真正的意思如你所理解的：随着single word出现在的doc数量的增加，idf值应该是下降的，我们认为，一个词在越多文档中出现，该词代表文章的概述的能力越弱。其实，我在《应用：基于自然语言识别下的流失用户预警》实际R代码编写过程中也是这么去做的，但是当时我考虑了另一个方面：电商的评论与传统的文学文本差异还是很大的，单条评论中独特的词（只出现过一次的词或者短句）非常之多。这意味着：如果原封不动的按照idf去计算的话，最后识别出来的判别标签，也就是’文本分词特征值’会变得非常多，而且对泛化情况的识别能力非常的差。体现在对做后续的有监督分类的时候，如果不做处理会造成异常过拟合的问题。所以，我这边表述的想法是将idf值过大的一些词，也就是single word出现的doc过少的一些词剔除，再根据剩余的其他特征词计算idf提取关键特征词，我这边设定的阈值范围是：特征词至少在3.5%以上的评论中出现过。当然，你完全可以选择另外一种方法，完全按照idf计算，在最后做特分类之前，做特征筛选，去除掉一些冗余特征词变量。 下面，我们来看代码：123456789101112131415161718192021222324252627282930313233343536373839#tfidf_partone 为对应的tftdidf_partone=whole_words_set_sequencefor (i in 1:key_word)&#123;tmp1=as.data.frame(prop.table(table(whole_words_set_sequence[[i]])))tdidf_partone[[i]]=tmp1 &#125;#tdidf_partfour 为对应的idftdidf_parttwo=unique(unlist(whole_words_set_sequence))tdidf_max=length(tdidf_parttwo)tdidf_partthree=tdidf_parttwofor (i in 1:tdidf_max)&#123;tmp=0aimed_word=tdidf_parttwo[i] for (j in 1:key_word)&#123; tmp=tmp+sum(tdidf_parttwo[i] %in% whole_words_set_sequence[[j]]) &#125;tdidf_partthree[i]=log(as.numeric(key_word)/(tmp+1))&#125;tdidf_partfour=cbind(tdidf_parttwo,tdidf_partthree)tdidf_partfive=tdidf_partonecolnames(tdidf_partfour)&lt;-c(&apos;Var1&apos;,&apos;Freq1&apos;)for (i in 1:key_word)&#123;tdidf_partfive[[i]]=merge(tdidf_partone[[i]],tdidf_partfour,by=c(&quot;Var1&quot;))&#125;#计算tf-idf结果，并排序key_wordtdidf_partsix=tdidf_partfivefor (i in 1:key_word)&#123;tmp=tdidf_partfive[[i]][,2:3]tdidf_partsix[[i]][,2]=as.numeric(tmp[,1])*as.numeric(tmp[,2])tdidf_partsix[[i]]=tdidf_partsix[[i]][order(tdidf_partsix[[i]][,2],decreasing=T),][]&#125;key_word=c()for (i in 1:key_word)&#123;tmp=tdidf_partsix[[i]][1:5,1]key_word=rbind(key_word,as.character(tmp))&#125; 理论上讲，如果这边数据存储方式用的是data.frame的话，可以利用spply、apply等批量处理函数，这边用得是list的方式，对lpply不是很熟悉的我，选择了for的循环，后续这边会优化一下，这样太消耗资源了。 模型训练这边，我最后采取的是概率模型naive bayes+非线性模型random forest先做标签训练，最后用nerual network对结果进行重估方式，但是在训练过程中，我还有几种模型的尝试，这边也一并贴出来给大家做参考。 数据因子化的预处理这边得到了近400维度的有效词，现在将每一维度的词遍做一维的feature，同时，此处的feature的意义为要么评论存在该词，要么评论中不存在该词的0-1问题，需要因子化一下。12345678910111213141516171819202122232425262728#整合数据well_dealed_data=cbind(as.character(comment[,1]),key_word)names=as.data.frame(table(key_word))[,1]names_count=length(names)names=as.matrix(names,names_count,1)feature_matrix=matrix(rep(0,names_count*key_word),key_word,names_count)for (i in 1:names_count)&#123; for(j in 1:key_word)&#123; feature_matrix[j,i]=ifelse(names[i] %in% key_word[j,],1,0) &#125;&#125;#art=1,literature=-1,标签0-1化feature_matrix=cbind(well_dealed_data[,1],feature_matrix)feature_matrix[feature_matrix[,1]==&apos;aimed&apos;,1]=&apos;1&apos;feature_matrix[feature_matrix[,1]==&apos;unaimed&apos;,1]=&apos;-1&apos;feature_matrix=as.data.frame(feature_matrix)num=1:(ncol(feature_matrix)-1)value_name=paste(&quot;feature&quot;,num) value_name=c(&apos;label&apos;,value_name)colnames(feature_matrix)=value_name#feature0-1化for (i in 1:ncol(feature_matrix))&#123;feature_matrix[,i]=as.factor(as.numeric(as.character(feature_matrix[,i])))&#125; 数据切分训练测试这边就不适用切分函数了，自己写了一个更加快速。123n_index=sample(1:nrow(feature_matrix),round(0.7*nrow(feature_matrix)))train_feature_matrix=feature_matrix[n_index,]test_feature_matrix=feature_matrix[-n_index,] 模型训练backpropagation neural network这边需要用网格算法对size和decay进行交叉检验，这边不贴细节，可以百度搜索详细过程。123456789101112library(nnet)nn &lt;- nnet(label~., data=train_feature_matrix, size=2, decay=0.01, maxit=1000, linout=F, trace=F)#train数据集效果nn.predict_train = predict(nn,train_feature_matrix,type = &quot;class&quot;)result_combind_train=cbind(as.numeric(as.character(train_feature_matrix$label)),nn.predict_train)correction_train=nrow(result_combind_train[result_combind_train[,1]==result_combind_train[,2],])/nrow(result_combind_train)#test数据集效果nn.predict_test = predict(nn,test_feature_matrix,type = &quot;class&quot;)result_combind_test=cbind(as.numeric(as.character(test_feature_matrix$label)),nn.predict_test)correction_test=nrow(result_combind_test[result_combind_test[,1]==result_combind_test[,2],])/nrow(result_combind_test) Linear Support Vector Machine这边需要用网格算法对cost进行交叉检验，这边不贴细节，可以百度搜索详细过程。123456789101112library(e1071)svmfit &lt;- svm(label~., data=train_feature_matrix, kernel = &quot;linear&quot;, cost = 10, scale = FALSE) # linear svm, scaling turned OFF#train数据集效果svmfit.predict_train=predict(svmfit, train_feature_matrix, type = &quot;probabilities&quot;)result_combind_train=cbind(as.numeric(as.character(train_feature_matrix$label)),as.numeric(as.character(svmfit.predict_train)))correction_train=nrow(result_combind_train[result_combind_train[,1]==result_combind_train[,2],])/nrow(result_combind_train)#test数据集效果svmfit.predict_test = predict(svmfit,test_feature_matrix,type = &quot;class&quot;)result_combind_test=cbind(as.numeric(as.character(test_feature_matrix$label)),as.numeric(as.character(svmfit.predict_test)))correction_test=nrow(result_combind_test[result_combind_test[,1]==result_combind_test[,2],])/nrow(result_combind_test) 贝叶斯分类器这边我没调参，我觉得这边做的好坏在于数据预处理中剩下来的特征词123456789101112library(e1071)sms_classifier &lt;- naiveBayes(train_feature_matrix[,-1], train_feature_matrix$label)#train数据集效果sms.predict_train=predict(sms_classifier, train_feature_matrix)result_combind_train=cbind(as.numeric(as.character(train_feature_matrix$label)),as.numeric(as.character(sms.predict_train)))correction_train=nrow(result_combind_train[result_combind_train[,1]==result_combind_train[,2],])/nrow(result_combind_train)#test数据集效果sms.predict_test = predict(sms_classifier,test_feature_matrix)result_combind_test=cbind(as.numeric(as.character(test_feature_matrix$label)),as.numeric(as.character(sms.predict_test)))correction_test=nrow(result_combind_test[result_combind_test[,1]==result_combind_test[,2],])/nrow(result_combind_test) 随机森林这边因为是最后的整合模型，需要调参的地方比较多，首先根据oob确定在mtry=log（feature）下的最优trees数量，在根据确定的trees的数量，反过来去确定mtry的确定值。除此之外，还需要对树的最大深度，子节点的停止条件做交叉模拟，是整体模型训练过程中最耗时的地方123456789101112library(randomForest)randomForest=randomForest(train_feature_matrix[,-1], train_feature_matrix$label)#train数据集效果rf.predict_train=predict(randomForest, train_feature_matrix)result_combind_train=cbind(as.numeric(as.character(train_feature_matrix$label)),as.numeric(as.character(rf.predict_train)))correction_train=nrow(result_combind_train[result_combind_train[,1]==result_combind_train[,2],])/nrow(result_combind_train)#test数据集效果rf.predict_test = predict(randomForest,test_feature_matrix)result_combind_test=cbind(as.numeric(as.character(test_feature_matrix$label)),as.numeric(as.character(rf.predict_test)))correction_test=nrow(result_combind_test[result_combind_test[,1]==result_combind_test[,2],])/nrow(result_combind_test) 就单模型下的test集合的准确率如下： 整体上看，nnet是过拟合的，所以在测试集上的效果折扣程度最大；naive bayes模型的拟合效果应该是最弱的，但是好在它的开发成本低，逻辑简单，有统计意义；svm和randomforest这边的效果不相上下。本次训练的数据量在20w条左右，理论上讲再扩大数据集的话，randomforest的效果应该会稳定，svm会下降，nnet会上升。 模型集成 这边的train_data的准确率在92.1%，test_data的准确率在84.3%，与理想的test_data90%以上的准确率还是有差距，所以后续准备：1.细化流失用户的定义方式，当前定义过于笼统粗糙2.以RNN的模型去替代BpNN去做整合训练，探索特征到特征本身的激活会对结果的影响3.重新定义词重要性，考虑互信息熵及isolation forest的判别方式 最后谢谢大家的阅读。]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>NLP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据预处理-异常值识别]]></title>
    <url>%2F2017%2F08%2F09%2F%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86-%E5%BC%82%E5%B8%B8%E5%80%BC%E8%AF%86%E5%88%AB%2F</url>
    <content type="text"><![CDATA[系统总结了常用的异常值识别思路，整理如下： 空间识别分位数识别代表的执行方法为箱式图： 上四分位数Q3，又叫做升序数列的75%位点下四分位数Q1，又叫做升序数列的25%位点箱式图检验就是摘除大于Q3+3/2*（Q3-Q1），小于Q1-3/2*（Q3-Q1）外的数据，并认定其为异常值；针对全量样本已知的问题比较好，缺点在于数据量庞大的时候的排序消耗R语言中的quantile函数，python中的percentile函数可以直接实现。 距离识别最常用的就是欧式距离，比如：两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的欧氏距离： 可以直观感受的到，图中，距离蓝色B点距离为基准衡量的话，红色A1，红色A2，红色A3为距离较近点，A4为距离较远的异常点。 但是这样看问题会有一个隐患，我们犯了“就点论点”的错误没有考虑到全局的问题，让我在看下面这张图： ! 还是刚才那张图，橙色背景为原始数据集分布，这样看来A4的位置反而比A1、A3相对更靠近基准点B，所以在存在纲量不一致且数据分布异常的情况下，可以使用马氏距离代替欧式距离判断数据是否离群。 其中，μ为feature的均值，X为观察值，Σ为feature的协方差矩阵 马氏距离除了用来判断点是否异常，也可以用来判断两个数据集相识度，在图像识别，反欺诈识别中应用的也是非常普遍；问题在于太过于依赖Σ，不同的base case对应的Σ都是不一致的，不是很稳定 密度识别 密度识别的方式方法比较多，这边就提供其中比较经典的，首先我们可以通过密度聚类中大名鼎鼎的dbscan入手，这边只讲思路，详细的算法过程另行介绍。 简单的来讲，下面这张图可以协助理解 我们可以通过随机选择联通点，人为设置联通点附近最小半径a，半径内最小容忍点个数b，再考虑密度可达，形成蓝色方框内的正常数据区域，剩下的黄色区域内的点即为异常点。 除此之外，密度识别里面还有一种方式，是参考单点附近的点密度判断，伪代码如下： 1234567 1.从特征集合中任选历史上没有被选择过的两维 2.将原始点集映射到该两维平面上，刻画点集中心a 3.以点集中心a，x为半径画圆，不断扩大x的值，直到被覆盖的点集数/原始点集数的最低阈值 4.没有被覆盖到的点集打上outlier_label 5.repeat 1-4 6.统计点对应的outlier_label个数 7.排序高则优先为异常点 这边参考了Clique的映射+Denclue的密度分布函数的思路，注意问题就是计算量大，所以对小样本的适用程度更高一些，针对大样本多特征的数据可以考虑对样本进行子集抽样，再根据子集进行1-5，汇总后整体进行6-7步骤，实际检验效果仍然可以达到不抽样的85%以上 拉依达准则 这个方法更加偏统计一些，设计到一些距离的计算，勉强放在空间识别里面 这种判别处理原理及方法仅局限于对正态或近似正态分布的样本数据处理，它是以数据充分大为前提的，当数据较少的情况下，最好不要选用该准则。 正态分布（高斯分布）是最常用的一种概率分布，通常正态分布有两个参数μ和σ为标准差。N(0,1)即为标准正态分布。 从上面这张图可以看出，当数据对象值偏离均值3倍标准差的时候，该数据合理的出现可能性小于3‰，所以可以直接认定，数据偏离均值±3倍标准差时，为异常点。但是最后再次强调一遍：它是以数据充分大为前提的，当数据较少的情况下，最好不要选用该准则。 计量识别G-test或者说是likelihood Ratio方法 G-test这类方法运用在医学方面较多，常用于检验观测变量值是否符合理论期望的比值。现在也用在电商、出行、搜索领域检验一些无监督模型的质量、数据质量。 当我们新上一个模型，部分用户的反馈特别异常，我们不知道是不是异常数据，在接下来的分析中需不需要剔除，我们可以用统计学方法予以取舍。 其中O为观测值，E为期望值，假如我们的网站每天24个小时的订单量分布稳定，分时段计算出一个均值，E1，E2，..E24，新模型产出后，我们问题用户群对应的24个小时的订单分布值O1,O2,…..O24,套用上面的公式，我们就可以计算出一个G值出来。 然后在根据G-test的base值，观察目标用户可信的最大置信度，判断置信度是否符合我们的最低要求；likelihood Ratio方法类似，相关论文可以直接搜索。 模型拟合 这类方法属于简单有监督识别，常见的包括贝叶斯识别，决策树识别，线性回归识别等等。 需要提前知道两组数据：正常数据及非正常类数据，再根据它们所对应的特征，去拟合一条尽可能符合的曲线，后续直接用该条曲线去判断新增的数据是否正常。 举个例子： 金融借贷中，我们事先活动一批正常借贷用户，和逾期不还用户，我们通过打分卡模型去识别已知用户的特征，假设得到芝麻分、手机使用时长、是否为男性为关键特征。接下来判断未知标签的新增数据是否为正常用户的话，直接根据之前判断出来的拟合打分卡曲线去做0-1概率预估就行了。 但是模型拟合的方式使用情况较为局限，绝大多数异常识别问题是无法拿到前置的历史区分数据，或者已分好的数据不能够覆盖全量可能，导致时间判断误差较大，顾一般只做emsemble model的其中一种组合模块，不建议做主要依赖标注。 明尼苏达州大学有过一篇异常论文识别的总结，里面关于有监督模型、半监督模型、无监督模型等模型拟合讲的非常细致，如果感兴趣可以研究一下，附上论文Survey：http://cucis.ece.northwestern.edu/projects/DMS/publications/AnomalyDetection.pdf 变维识别 首先，我们来看一下PCA的伪代码 12345 1.去除平均值,方便后续协方差，方差矩阵的计算 2.计算协方差矩阵及其特征值和特征向量 3.将特征值从大到小排序，特征值可以反映方差贡献度，特征值越大，方差贡献度越大 4.保留最大的N个特征值以及它们的所对应的特征向量 5.将数据映射到上述 N 个特征向量构造的新空间中 pca的核心思路在于尽可能通过feature的组合代替原始feature，使得原始数据的方差最大化。 通过pca可以得到第一主成分、第二主成分…。 对于正常数据集来说，正常数据量远远大于异常数据，所以正常数据所贡献的方差远远大于异常数据；通过pca得到的排名靠前的主成分解释了原始数据较大的方差占比，所以理论上讲，第一主成分反映了正常值的方差，最后一个主成分反映了异常点的方差。通过第一主成分对原始数据进行映射后，原始数据中的正常样本和异常样本的属性不会随之改变。 存在一个p个维度的数据集orgin_data，X为其协方差矩阵，通过奇异值分解可以得到： 其中，D为对角阵，其每一个值为X所对应的特征值；P的每一列为X的所对应的特征向量，并将D中的特征值从大到小排列，相应的改变P所对应的列向量。 我们选取top(j)个D中的特征值，及其P所对应的特征向量构成(p,j) 维的矩阵 pj ，再将目标数据集orgin_data进行映射：new_data = orgin_data*pj；new_data是一个 (N,j) 维的矩阵。如果考虑拉回映射的话（也就是从主成分空间映射到原始空间），重构之后的数据集合是:back_data=transpose(pj*transpose(new_data))=new_data*transpose(pj),是使用 top-j 的主成分进行重构之后形成的数据集，是一个 (N,p) 维的矩阵。 所以，我们有如下的outlier socres的定义： ev(j) subject to. 解释一下上面两个公式，先计算score中orgindata的列减去前j个主成分映射回原空间的newdata下的欧式范数值；再考虑不同主成分所需乘以的权重，这边，我们认为，第一主成分所代表的数据中正常数据更多，所以权重越小；当j取到最后一维的主成分下，我们认为权重最高，达到1。 对于outlier socres过高的点，即为异常点。 神经网络识别 之前比较火的神经网络分析，同样可以用来做有监督的异常点识别，这边介绍一下Replicator Neural Networks (RNNs)。 这边我们通过图像可以看出： 1.输入层中，输入变量个数与输出层中，输出变量一致 2.中间层的节点数小于输入输出层节点 3.整个训练过程是一个先压缩后解压的过程 常规的，我们通过mse来看模型的误差 我们来大致了解一下RNN的运行逻辑，首先，最左边的为输入层即为原始数据，最右层的为输出层即为输出数据。中间各层的激活函数不同，入参经过激活函数所得到的出参的值也不一致，但是在同一层激活函数都是一致的。 对于我们异常识别而言，第二层和第四层 (k=2,4)，激活函数选择为 tanh图像如下，可以将原始数据压缩在-1到1之间，使得原始数据有界。 对于中间层 (k=3) 而言，激活函数是一个类阶梯 (step-like) 函数。 其中，N为阶梯分层数，a3为提升的效率。N的个数越多，层次分的更多。 比如N=5的形式下： 比如N=3的形式下： 这样做的好处就是，随着N的增加可以将异常点或者异常点群集中在某一个离散阶梯范围内。 通过对RNN的有监督训练，构造异常样本分类器，进行异常值识别。 isolation forest 2010年南大的周志华教授提出了一个基于二叉树的异常值识别算法，在工业界来说，效果是非常不错的，最近我也做了一个流失用户模型，实测效果优秀。 和random forest一样，isolation forest是由isolation tree构成，先看一下isolation tree的逻辑： 1234567 method: 1.从原始数据中随机选择一个属性feature； 2.从原始数据中随机选择该属性的下的一个样本值value； 3.根据feature下的value对每条记录进行分类，把小于value的记录放在左子集，把大于等于value的记录放在右子集； 4.repeat 1-3 until：4.1.传入的数据集只有一条记录或者多条一样的记录； 4.2.树的高度达到了限定高度； 大致的思路如下图： 理论上，异常数据一般都是离群数据，非常容易在早期就被划分到最终子节点。所以，通过计算每个子节点的深度h(x)，来判断数据为异常数据的可能性。论文中，以s(x,n)为判断数据是否异常的衡量指标。 其中，h(x)为x对应的节点深度，c(n)为样本可信度，s(x,n)~[0,1]，正常数据来讲s(x,n)小于0.8，s(x,n)越靠近1，数据异常的可能性越大。 单棵树的可信性不足，所以我们通过用emsemble model的思路，去构造一个forest的树群来提高准确性。 但是作为isolation forest的时候，需要对原s(x,n)的公式有所更改，通过E(h(x))来替代h(x),其中E(h(x))为数据x在各棵树上的h(x)的平均。 同时， 1.因为树的个数大大增加，所以需要控制计算的开销，所以每个棵树我们可以采取数据抽样的方式，使得抽样数据集远远小于原始数据集，且根据周志华老师的论文，采样大小超过256效果就提升不大了。 2.我们可以控制深度，使得没棵树的最大深度limit length=ceiling(log2(样本大小))，当树深度大于最大深度时，其产生的子节点绝大多数均为正常数据节点，失去异常检验的意义。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>数据处理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何校验用户画像的准确性？]]></title>
    <url>%2F2017%2F07%2F20%2F%E5%A6%82%E4%BD%95%E6%A0%A1%E9%AA%8C%E7%94%A8%E6%88%B7%E7%94%BB%E5%83%8F%E7%9A%84%E5%87%86%E7%A1%AE%E6%80%A7%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[在用户研究的课题中，用户画像是几乎每个公司都会去做的，浅层的包括统计类的：上月购买量，上周活跃天数等；深层的包括洞察类的：潜在需求偏好，生命周期阶段等；前者的校验简单，后者的校验需要通过一些特别的方式。本文就洞察类画像校验做一系列的梳理。 省略掉预处理设计的过程，画像校验的步骤主要集中在画像开发，画像上线，画像更新中，并且三个阶段中，每个阶段的校验方式完全不同 用户画像开发中当我们所开发的用户画像是类似于用户的下单需求、用户的购车意愿、用户是否有注册意愿这一类存在历史的正负样本的有监督的问题，我们可以利用历史确定的数据来校验我们的画像准确性。比如，银行在设计用户征信的画像前，会有一批外部购买的坏样本和好样本，其实画像问题就转化为分类问题去解决评估了。1.1 Recall、Pecision、K-S、F1曲线、Roc曲线、Confusion Matrix、AUC针对这类问题，已经有较为成熟的理论基础，直接利用测试样本判断的准确程度判断画像是否准确 这张图是一张非常常见也是有效的来总结Recall、Pecision、Lift曲线、Roc曲线、Confusion Matrix的图。FPR = FP/(FP + TN)Recall=TPR=TP/(TP+FN)Precision=TP/(TP+FP)F1曲线:2*Precision*Recall/(Precision+Recall)Roc曲线：TPR vs FPR，也就是Precision vs RecallAuc：area under the roc curve ，也就是roc曲线下面的面积，积分或者投点法均可求解。这边不详细讲细节，需要的可以参考精确率、召回率、F1 值、ROC、AUC 各自的优缺点是什么？ 1.2 交叉验证并不是所有画像都是有监督训练的画像，举个例子，用户的性别画像，是一个无监督的刻画，当你无法通过app端资料填写直接获取到的时候，你只能够通过其他数据特征的对用户进行分群。 1234567891011121314input :Data Set：测试数据集output :model：画像模型label：0(无效)，1（有效）methods：1.从原始数据集中确定画像模型关键features2.关键features分层，分为train features、test features3.train featrues训练画像4.test freatrues校验画像5.输出值对（model，label）6.重复2~5 首先，我们在总的数据集中筛选出所有关键影响特征，每次将筛选出的特征分为两块，测试特征训练特征，利用训练特征建立模型，再利用测试特征去判断模型是否合理（比如女鞋用户群的女鞋购买次数小于男性用户群，则次模型异常，删除），最后集成所有合理模型。这样的逻辑中，我们将所有异常不合理的模型全部剔除，训练过程中就校验了用户画像的准确性 用户画像上线后ABTest不得不说，abtest是用户画像校验最为直观有效的校验方式。 用户分流模块： 123456789101112methods:1. 全量用户流量为Users，切分流量为三块Users：A1、Users：A2、Users：B，且满足Users：A1+Users：A2=Users：B2. 对流量Users：A1、Users：A2不做任何动作3. 对流量Users：B做相应的模型预测，保存结果4. 以用户活跃度为例子，选取观察日期周下平均登陆次数y为代价函数，if y（Users：A1）=y（Users：A2）thenif y（Users：B）&gt; y（Users：A1+Users：A2）then 模型有效（差值越大代表准确越高）else 模型无效（差值越小代表准确越差）else 模型无效5.准确程度量化：K=(p*exp(-(dist(y(Users:B),y(Users:A1+Users:A2)))^2/(2*最小容忍度^2)))^(-1) 一句话解释，就是A1=A2保证分配随机，A3好于A1+A2的效果检验画像是否准确？多准确？ 用户画像更新用户回访在画像刻画完成后，必然会存在画像优化迭代的过程，客服回访是非常常见且有效的方式。比如，我们定义了一波潜在流失用户10万人，随机抽取1000人，进行回访，根据回访结果做文本挖掘，提取关键词，看消极词用户的占比； 机制检测再比如，我们定义了一波忠诚用户10万人，随机抽取100人，后台随机获取用户安装app的列表，看用户同类app的下载量数目的分布； 横轴为用户手机中同类竞品安装量的个数，纵轴为对应的随机抽样的100人中的个数人群1分布为忠诚用户画像最准确的，同类app下载量集中在1附近，定义的用户极为准确人群2分布杂乱，人群3分布在下降量异常高的数值附近，定义人群不准确用户画像是数据运营运营的基础，也是做深度挖掘的一个不可或缺的模块，只有先打好画像基础，确保画像质量，后续的深挖行为才有突破的可能，最后，谢谢大家阅读。]]></content>
      <categories>
        <category>特征刻画</category>
      </categories>
      <tags>
        <tag>用户画像</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大数据量下的划分聚类方法]]></title>
    <url>%2F2017%2F07%2F19%2F%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%87%8F%E4%B8%8B%E7%9A%84%E5%88%92%E5%88%86%E8%81%9A%E7%B1%BB%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在常规聚类案例中，数据一般都是以iris集或者不足GB级的数据作为测试案例，实际商业运用中，数据量级要远远大于这些。比如滴滴出行15年日均单量就达到1000万单，出行轨迹的数据存储达到上百TB，常规的k均值聚类，二分聚类等无法完成如此量级的数据聚类，这边就提供一个以CLARANS为基础的算法思路。 什么是聚类?定义是这样的，把一个数据对象，划分成子集的过程，使得子集内相似度大，子集外相似度小。这样的一个过程叫做聚类。 大学课程老师以一个公式概括过这样的过程：max(子集内相似度/子集间相似度)，我觉得也很形象便于理解。 什么是划分聚类？聚类方法有很多种，包括基于划分、基于密度、基于网格、基于层次、基于模型等等，这边主要介绍基于划分的聚类方法，剩余的方法会在后续的文章中持续更新[如果不鸽的话]。划分聚类一般是：采取互斥族（子集）划分，说的更直白一点就是每个点属于且仅属于一个族（子集）。 常见的划分聚类有哪些？k均值划分：12345678910input：- k：族的个数- D：输入数据集合output：k个族（子集）的数据集合methods：1.在D中任选（常用的包库中都是这样做，但是建议自己写的同学以密度先分块，在密度块中任选）k个对象作为初始中心2.计算剩余对象到k对象的聚类，聚类远近分配到对应的族3.更新族均值作为新的族中心4.重复2-4直到中心不变化 如图过程： 以上为最简单的k均值，很容易看出，它存在几个问题，首先计算量非常的大，假设有m条数据，k个中心点，那距离计算的次数就是o(mkt)=k*(m-k)*迭代次数t，重复t次直到收敛的过程是非常大的计算过程；再而，如果数据均为‘男、女’，‘高、中、低’等，那距离定义就是非常不合理的，此外，初始k难确定，非凸数据，离群点等等都存在问题 围绕中心划分（PAM）：刚才说到了异常点会影响k均值，那么我们看看为什么？假设与点1、2、3、8、9、10、25，一眼就知道(1、2、3)，(8，9，10)为族，但如果由k均值的话，以k=2为例，((1，2，3)，(8，9，10，25))，mse=196；((1，2，3，8)，(9，10，25))，mse=189.7；它重复以mse为损失函数，而不去考虑数据是否合理，所以针对的，我们有绝对误差标准： 这样做，通过全局距离最小化，可以一定程度上避免异常点的问题，但是，思考一下计算量是什么？是o(n**2)，这意味着对数据量大的问题，这就是一个典型的NP问题（一定有解，但是不一定在有限时间资源内可以被解出来）。1234567891011121314input:- k：族的个数- D：输入数据集合output：k个族（子集）的数据集合methods:1.D中任选k个对象最为初始种子2.仿照k均值分配剩余对象3.随机选取非种子对象O4.计算若是以O为中心下的总损失函数代价S=原始种子下的绝对误差E-新的对象O下的绝对误差E5.如果S&gt;0,则以新对象O替换旧的种子对象，否则不变化6.重复2-5，直到收敛 我们看这个图好理解一点，就是存在族（集合）中任一点p，当前的初始种子为Q1，随机选取剩余其他对象为族中心Qrandom1，计算PQ1的距离与PQrandom1的距离，图中dist(PQ1)dist(PQrandom2)，则更新族中心为Qrandom2,此时绝对误差E会变化，计算是否降低了绝对误差E以确定是否更好族中心。如何解决大数据量下的聚类问题？其实看了以上两个算法，大同小异，但是都不可避免有一个弱点，就是计算量上都是随着初始数据量的增大而几何增长的，所以这边需要对数据量进行控制。 大家回想一下，同样的对数据量进行控制的算法有哪些给我们有启发？数据平衡算法这种方法好像可以减少数据量，哪有没有历史成功案例支持呢？基于决策树引申出的集成算法貌似存在一个叫做adaboost、randomforest这类的算法，好像就用了数据平衡的算法。 那么，我们是否可以用在聚类里面呢？答案是可以的，我们现在看一个由上述思路得到的CLARANS算法，实际开发中，我们team对其进行了优化，内部称之为’CLARANS+’在理解CLARANS+之前，我们先理解CLARA: 从这张图上，我们可以很清晰的看出，CLARA首先通过类似randomforest里面的随机抽样的方法，将原始数据集随机抽样成若干个子数据集sample data，理论上采样的子集分布应该与原分布近似，所以样本中心点必然与原分布中心近似。 在数据量较少的子集上，我们可以重复确定每个子集的中心Medoid，这边计算中心的方法有很多，包括上述讲到的K均值，PAM，也可以参考相似度比如常见的余弦相似，likelihood rate，高斯核相似等等 最后采取随机抽取，或者投票加权等方法确定原始样本的中心即可。 CLARA的有效性依赖于样本的大小，分布及质量，所以该算法一定程度上会依赖于初始抽样的质量。除此之外，每一个随机样本的计算负责度为O（ks*s+k（n-k）），s为样本的大小，k为族数，n为总对象数，若抽取样本子集过少，其简化计算的程度也越低。 说到这里，CLARA的算法是确定了中心后不在改变，这就有一定的运气成分，假设确定的k个钟均离最佳中心很远的情况下，CLARA最后无论如何去选已知中心，都得不到最优秀的聚类中心。 所以，我们来看看可以提高CLARA的聚类质量及可伸缩性的CLARANS算法 上述思路不变，但在CLARA确定中心之后，我们新增了一步，就是按照PAM中的方法一样，我们在子集上选取一个与当前中心x(Medoid)不一样的对象y(New Medoid)，计算用y(New Medoid)替换x(Medoid)后绝对误差是否下降，下降则替换否则不变，重复l次之后，我们可以认为此时的中心点为局部中心最优解；整体数据集所有子集均重复m次后，得出的中心点为全局局部最优解。如下图： 实际上，我们可以做的还很多理论上讲，以上的算法结果已经尽可能的保证了数据的合理压缩，压缩后的数据集内的中心点足够鲁棒，但是实际运用过程中，我们没有尽可能的考虑到开头说的那句：什么是聚类?定义是这样的，把一个数据对象，划分成子集的过程，使得子集内相似度大，子集外相似度小。这样的一个过程叫做聚类。 所以，我们尝试性的做了CLARANS+，我们把CLARANS里面确定出来的每个sample data子集里面最优秀的top k个New Medoids映射回同一个空间：以绿色和天蓝色数据集为例子： 橘色方框内为CLARANS最后确定中心后做的随机或者加权投票后采纳的被橘黄色框框住的天蓝色数据与绿色数据的中心点，很明显可以看出，这样导致的结果违背了“子集外相似度最小的原则”。 我们，仿照Lasso对应lambda.1se的方式，考虑除了最优点外，在其可接受的范围附近，认为他们同样属于最优点，也就是top k个New Medoids重新选择距离最远的点作为最优中心，也就是如下图中的紫色方框中的点： 通过实际的业务测试，我们建议top k个点中的个默认为2-3比较好（数据分布差异大选择2，否则选择3）,如果不能确定，就默认为3。 以上理论方法就解释了如何在大量数据量下，简单快速的寻找到最优中心点的过程，谢谢大家。 参考文献：[1] Jiawei Han.[数据挖掘概念与技术]2001，8[2] 毛国君等.数据挖掘原理与算法[M].北京:清华大学出版社,2005.[3] 数据平衡算法[4] 基于决策树引申出的集成算法[5] http://scikit-learn.org/stable/modules/clustering.html#clustering[6] https://en.wikipedia.org/wiki/Clustering]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>理论解析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据抽样平衡方法重写]]></title>
    <url>%2F2017%2F07%2F13%2F%E6%95%B0%E6%8D%AE%E6%8A%BD%E6%A0%B7%E5%B9%B3%E8%A1%A1%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%2F</url>
    <content type="text"><![CDATA[之前在R里面可以通过调用Rose这个package调用数据平衡函数，这边用python改写了一下，也算是自我学习了。 R：12345678910# 设定工作目录setwd(path)# 安装包install.packages("ROSE")library(ROSE)# 检查数据data(hacide)table(hacide.train$cls)0 1980 20 过抽样实现：1234data_balanced_over &lt;- ovun.sample(cls ~ ., data = hacide.train, method = &quot;over&quot;,N = 1960)$datatable(data_balanced_over$cls)0 1980 980 这边需要注意是ovun不是over 欠采样实现：1234data_balanced_under &lt;- ovun.sample(cls ~ ., data = hacide.train, method = &quot;under&quot;, N = 40, seed = 1)$datatable(data_balanced_under$cls)0 120 20 这边需要注意的是欠采样是不放回采样，同时对数据信息的损失也是极大的 组合采样实现：1234data_balanced_both &lt;- ovun.sample(cls ~ ., data = hacide.train, method = &quot;both&quot;, p=0.5, N=1000, seed = 1)$datatable(data_balanced_both$cls)0 1520 480 method的不同值代表着不同的采样方法，p这边是控制正类的占比，seed保证抽取样本的固定，也就是种子值。 在python上，我也没有发现有现成的package可以import，所以就参考了R的实现逻辑重写了一遍，新增了一个分层抽样group_sample,删除了过采样，重写了组合抽样combine_sample,欠抽样under_sample:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101# -*- coding:utf-8 -*-import pandas as pdimport random as rdimport numpy as npimport math as maclass sample_s(object): def __init__(self): ''''this is my pleasure''' def group_sample(self, data_set, label, percent=0.1): # 分层抽样 # data_set:数据集 # label:分层变量 # percent:抽样占比 # q:每次抽取是否随机,null为随机 # 抽样根据目标列分层，自动将样本数较多的样本分层按percent抽样，得到目标列样本较多的特征欠抽样数据 x = data_set y = label z = percent diff_case = pd.DataFrame(x[y]).drop_duplicates([y]) result = [] result = pd.DataFrame(result) for i in range(len(diff_case)): k = np.array(diff_case)[i] data_set = x[x[y] == k[0]] nrow_nb = data_set.iloc[:, 0].count() data_set.index = range(nrow_nb) index_id = rd.sample(range(nrow_nb), int(nrow_nb * z)) result = pd.concat([result, data_set.iloc[index_id, :]], axis=0) new_data = pd.Series(result['label']).value_counts() new_data = pd.DataFrame(new_data) new_data.columns = ['cnt'] k1 = pd.DataFrame(new_data.index) k2 = new_data['cnt'] new_data = pd.concat([k1, k2], axis=1) new_data.columns = ['id', 'cnt'] max_cnt = max(new_data['cnt']) k3 = new_data[new_data['cnt'] == max_cnt]['id'] result = result[result[y] == k3[0]] return result def under_sample(self, data_set, label, percent=0.1, q=1): # 欠抽样 # data_set:数据集 # label:抽样标签 # percent:抽样占比 # q:每次抽取是否随机 # 抽样根据目标列分层，自动将样本数较多的样本按percent抽样，得到目标列样本较多特征的欠抽样数据 x = data_set y = label z = percent diff_case = pd.DataFrame(pd.Series(x[y]).value_counts()) diff_case.columns = ['cnt'] k1 = pd.DataFrame(diff_case.index) k2 = diff_case['cnt'] diff_case = pd.concat([k1, k2], axis=1) diff_case.columns = ['id', 'cnt'] max_cnt = max(diff_case['cnt']) k3 = diff_case[diff_case['cnt'] == max_cnt]['id'] new_data = x[x[y] == k3[0]].sample(frac=z, random_state=q, axis=0) return new_data def combine_sample(self, data_set, label, number, percent=0.35, q=1): # 组合抽样 # data_set:数据集 # label:目标列 # number:计划抽取多类及少类样本和 # percent：少类样本占比 # q:每次抽取是否随机 # 设定总的期待样本数量，及少类样本占比，采取多类样本欠抽样，少类样本过抽样的组合形式 x = data_set y = label n = number p = percent diff_case = pd.DataFrame(pd.Series(x[y]).value_counts()) diff_case.columns = ['cnt'] k1 = pd.DataFrame(diff_case.index) k2 = diff_case['cnt'] diff_case = pd.concat([k1, k2], axis=1) diff_case.columns = ['id', 'cnt'] max_cnt = max(diff_case['cnt']) k3 = diff_case[diff_case['cnt'] == max_cnt]['id'] k4 = diff_case[diff_case['cnt'] != max_cnt]['id'] n1 = p * n n2 = n - n1 fre1 = n2 / float(x[x[y] == k3[0]]['label'].count()) fre2 = n1 / float(x[x[y] == k4[1]]['label'].count()) fre3 = ma.modf(fre2) new_data1 = x[x[y] == k3[0]].sample(frac=fre1, random_state=q, axis=0) new_data2 = x[x[y] == k4[1]].sample(frac=fre3[0], random_state=q, axis=0) test_data = pd.DataFrame([]) if int(fre3[1]) &gt; 0: i = 0 while i &lt; (int(fre3[1])): data = x[x[y] == k4[1]] test_data = pd.concat([test_data, data], axis=0) i += 1 result = pd.concat([new_data1, new_data2, test_data], axis=0) return result 后续使用，只需要复制上述code，存成.py的文件，后续使用的时候：1234567#加载函数import sample_s as sa#这边可以选择你需要的分层抽样、欠抽样、组合抽样的函数sample = sa.group_sample()#直接调用函数即可new_data3 = sample.combine_sample(data_train, 'label', 60000, 0.4)#将data_train里面的label保持正样本（少类样本）达到0.4的占比下，总数抽取到60000个样本 其实不是很难的一个过程，只是强化自己对python及R语言的书写方式的记忆，谢谢。]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>数据平衡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[订单需求预估]]></title>
    <url>%2F2017%2F07%2F12%2F%E8%AE%A2%E5%8D%95%E9%9C%80%E6%B1%82%E9%A2%84%E4%BC%B0%2F</url>
    <content type="text"><![CDATA[之前写了一篇以基于elastic的需求预估的文章，只不过用的是R语言开发的，最近在学python，就仿照逻辑写了一篇python的，主要修改点如下： 用决策树替换了elastic算法 用分层抽样替换了组合抽样 需要看详细理论及思考过程参考链接：商品需求预估 python code如下：123456789# -*- coding:utf-8 -*-import pandas as pdimport numpy as npimport random as rdfrom sklearn import tree# 读取数据data_orgin = pd.read_table(&quot;C:/Users/17031877/Desktop/supermarket_second_hair_washing_train.txt&quot;)data_deal_1 = data_orgin.drop([&apos;aimed_date&apos;, &apos;member_id&apos;, &apos;age&apos;, &apos;gender&apos;, &apos;diff_rgst&apos;], axis=1) 这边是常规的数据读取，删除了不必要的列 12345678910111213141516171819202122232425#因变量单列label = data_deal_1[&apos;label&apos;]# 用户分量级value00 = [&apos;max_date_diff&apos;, &apos;aimed_max_date_diff&apos;]data00 = data_deal_1[value00]value01 = [&apos;max_pay&apos;, &apos;per_pay&apos;, &apos;six_month_max_pay&apos;, &apos;six_month_per_pay&apos;, &apos;three_month_max_pay&apos;, &apos;three_month_per_pay&apos;, &apos;one_month_max_pay&apos;, &apos;one_month_per_pay&apos;, &apos;fifteen_day_max_pay&apos;, &apos;fifteen_day_per_pay&apos;, &apos;aimed_max_pay&apos;, &apos;aimed_per_pay&apos;, &apos;aimed_six_month_max_pay&apos;, &apos;aimed_six_month_per_pay&apos;, &apos;aimed_three_month_max_pay&apos;, &apos;aimed_three_month_per_pay&apos;, &apos;aimed_one_month_max_pay&apos;, &apos;aimed_one_month_per_pay&apos;, &apos;aimed_fifteen_day_max_pay&apos;, &apos;aimed_fifteen_day_per_pay&apos;, &apos;qty_drtn_seven&apos;, &apos;qty_drtn_fourteen&apos;]data01 = data_deal_1[value01]value02 = [&apos;cnt_time&apos;, &apos;six_month_cnt_time&apos;, &apos;three_month_cnt_time&apos;, &apos;one_month_cnt_time&apos;, &apos;fifteen_day_cnt_time&apos;, &apos;aimed_cnt_time&apos;, &apos;aimed_six_month_cnt_time&apos;, &apos;aimed_three_month_cnt_time&apos;, &apos;aimed_one_month_cnt_time&apos;, &apos;aimed_fifteen_day_cnt_time&apos;, &apos;pv_times_seven&apos;, &apos;pv_times_fourteen&apos;, &apos;search_times_seven&apos;, &apos;search_times_fourteen&apos;, &apos;clc_times_seven&apos;, &apos;clc_times_fourteen&apos;, &apos;cart2_times_seven&apos;, &apos;cart2_times_fourteen&apos;, &apos;cart1_times_seven&apos;, &apos;cart1_times_fourteen&apos;, &apos;unpay_times_seven&apos;, &apos;unpay_times_fourteen&apos;]data02 = data_deal_1[value02]value03 = [&apos;pv_visit_last_period&apos;, &apos;search_last_period&apos;, &apos;clc_last_period&apos;, &apos;cart2_last_period&apos;, &apos;cart1_last_period&apos;, &apos;unpay_last_period&apos;]data03 = data_deal_1[value03] 因为不同量级的数据之后做异常点处理的时候截断位置不同，所有需要分割数据处理 12345678910111213141516171819202122232425262728293031def test_function_one(x, l): k = x.dropna(how=&apos;any&apos;) y = k.quantile(l) z = k.max() x[x &gt; y] = y x = x.fillna(value=z) return xfor i in range(len(data00.columns)): data00.iloc[:, i] = test_function_one(data00.iloc[:, i], 0.98)def test_function_two(x, l): k = x.dropna(how=&apos;any&apos;) y = k.quantile(l) z = 0 x[x &gt; y] = y x = x.fillna(value=z) return xfor i in range(len(data01.columns)): data01.iloc[:, i] = test_function_two(data01.iloc[:, i], 0.95)for i in range(len(data02.columns)): data02.iloc[:, i] = test_function_two(data02.iloc[:, i], 0.99)def test_function_three(x): z = 14 x[x &gt; z] = z x = x.fillna(value=z) return xfor i in range(len(data03.columns)): data03.iloc[:, i] = test_function_three(data03.iloc[:, i])# 数据合并data_train = pd.concat([label, data00, data01, data02, data03], axis=1) 根据数据量的不同做数据分割，跑上面写完的code函数就可以 123456789#数量级对比zero_case = data_train[data_train[&apos;label&apos;] == 0][&apos;label&apos;].count()print &apos;负样本数：%d&apos; % zero_caseone_case = data_train[data_train[&apos;label&apos;] == 1][&apos;label&apos;].count()print &apos;正样本数: %d&apos; % (one_case)负样本数：292936正样本数: 3973Backend TkAgg is interactive backend. Turning interactive mode on. 实际看下来，正负样本的差异的确还是很大，这个其实做多了就有经验，常规的来看，潜在的浏览、搜索到最后的成单，普遍自然转化不到1%，也正是这么低的转化，才需要一些算法来做信息抓去。 12345678910111213141516171819202122def case_sample(x, y, z): diff_case = pd.DataFrame(x[y]).drop_duplicates([y]) result = [] result = pd.DataFrame(result) for i in range(len(diff_case)): k = np.array(diff_case)[i] data_set = x[x[y] == k[0]] nrow_nb = data_set.iloc[:, 0].count() data_set.index = range(nrow_nb) index_id = rd.sample(range(nrow_nb), int(nrow_nb * z)) result = pd.concat([result, data_set.iloc[index_id, :]], axis=0) return resultzero_case = data_train[data_train[&apos;label&apos;] == 0]one_case = data_train[data_train[&apos;label&apos;] == 1]# 开始分层抽样new_zero_case = case_sample(zero_case, &apos;unpay_last_period&apos;, 0.1)# 新数量级对比new_zero_case_count = new_zero_case[new_zero_case[&apos;label&apos;] == 0][&apos;label&apos;].count()# 数据集合并new_data_train = pd.concat([new_zero_case, one_case], axis=0) case_sample是一个简单的分层抽样的小函数，x是数据集，y是分层变量，z是抽样占比；新的样本new_data_train中正负样本比例在1:10左右，这边的样本比是我自己设置的，不一定是最合理的；且此处也不一定要求一定用分层抽样，只是我用来练练手的；推荐还是遵从奥卡姆原理，在未知的情况下，尽可能简单的解决问题，比如组合抽样就是很不错的方法。 123456789101112131415#函数设置clf = tree.DecisionTreeRegressor(criterion=&apos;mse&apos;, max_features=&apos;log2&apos;, random_state=1)#函数拟合y = new_data_train[&apos;label&apos;]x = new_data_train.drop(&apos;label&apos;, 1)clf.fit(x, y)#数据预测y_predict = clf.predict(x)# 结果对比y.index = range(len(y))combined_date = pd.concat([y, pd.DataFrame(y_predict)], axis=1)combined_date.columns = [&apos;actual&apos;, &apos;predict&apos;] 这边稍微讲解一下，我认为的sklearn中DecisionTreeRegressor中比较终于的参数设置，criterion这边为模型优化的标准，常规的有mse和mae，建议在数据量差异不大的时候多考虑mse；max_features是每次训练用的特征个数，综合特征量级考虑，一般有log2，sqrt，尽可能是抽取比例在70%；max_depth刚开始可以默认，第一类模型出来后，可在结果附近迭代，寻找out of bag最小的error下的值；另外，我没有发现有weight设置，可能是我不熟悉，但是如果sklearn这边不提供weight的化，我们在做数据预处理的时候一定要平衡数据，不然当数据集过偏的时候最后的结果会以“牺牲”少类的判断正确率去完善整体正确率。 1234567891011121314# case 1x = []y = []for i in range(1, 10): test_data = combined_date i = i / float(10) for j in range(combined_date[&apos;actual&apos;].count()): if test_data.iloc[j, 1] &gt; i: test_data.iloc[j, 1] = 1 else: continue z = test_data[test_data[&apos;actual&apos;] == test_data[&apos;predict&apos;]][&apos;actual&apos;].count() / float(test_data[&apos;actual&apos;].count()) x.append(i) y.append(z) 这边写了检查函数，检查了分别0.1~1，以0.1为间隔的情况下的分割点，每个分割点下预测正确的数量/所有统计的样本数，也就是下面的accuracy. 12345678# case 2test_data = combined_dateaimed_data = test_data[test_data[&apos;predict&apos;]&gt;0]k1=aimed_data[aimed_data[&apos;actual&apos;]==1][&apos;predict&apos;].count()k2=float(aimed_data[&apos;predict&apos;].count())print &apos;所有预测可能下单用户中真实下单用户数：%d&apos; %(k1)print &apos;所有预测可能下单用户数：%d&apos; %(k2) 因为这边需要对用户营销，所以更关系topN的转化率，需要看一下实际正样本被覆盖了多数，以上即为code，这边的效果值为98.7%，还是比较高的，但是应该是过拟合了，所有一般不建议单纯使用决策树模型 所有的python code到这里就结束了，后续我做项目的同时会同时更新R及python两种code的思考，和大家讨论分享学习，谢谢。 参考文献： sklearn.tree.DecisionTreeRegressor 维基百科中对ROC的介绍 决策树常见问题及面试关键点介绍]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>预测</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐系统-威尔逊区间法]]></title>
    <url>%2F2017%2F06%2F21%2F%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%A8%81%E5%B0%94%E9%80%8A%E5%8C%BA%E9%97%B4%E6%B3%95%2F</url>
    <content type="text"><![CDATA[我推荐一种之前在惠普做过一种排序方法：威尔逊区间法 我们先做如下设定： （1）每个用户的打分都是独立事件。 （2）用户只有两个选择，要么投喜欢’1’，要么投不喜欢’0’。 （3）如果总人数为n，其中喜欢的为k，那么喜欢的比例p就等于k/n。 这是一种统计分布，叫做”二项分布”（binomial distribution） 理论上讲，p越大应该越好，但是n的不同，导致p的可信性有差异。100个人投票，50个人投喜欢；10个人投票，6个人喜欢，我们不能说后者比前者要好。 所以这边同时要考虑（p，n） 刚才说满足二项分布，这里p可以看作”二项分布”中某个事件的发生概率，因此我们可以计算出p的置信区间。 所谓”置信区间”，就是说，以某个概率而言，p会落在的那个区间。 置信区间展现的是这个参数的真实值有一定概率落在测量结果的周围的程度。置信区间给出的是被测量参数的测量值的可信程度，即前面所要求的“一个概率”，也就是结论的可信程度。 二项分布的置信区间有多种计算公式，最常见的是”正态区间”（Normal approximation interval）。但是，它只适用于样本较多的情况（np &gt; 5 且 n(1 − p) &gt; 5），对于小样本，它的准确性很差。 这边，我推荐用t检验来衡量小样本的数据，可以解决数据过少准确率不高的问题。 这样一来，排名算法就比较清晰了： 第一步，计算每个case的p（好评率）。 第二步，计算每个”好评率”的置信区间（参考z Test或者t Test，以95%的概率来处理）。 第三步，根据置信区间的下限值，进行排名。这个值越大，排名就越高。 解释一下，n为评价数，p为好评率，z为对应检验对应概率区间下的统计量 比如t-分布： 可以看到，当n的值足够大时，这个下限值会趋向p，如果n非常小，这个下限值会大大小于p，更加符合实际。 Reddit的评论排名，目前就使用这个算法。国内的化，滴滴也有部分业务涉及，效果也不错。 更新一下，没想到这个话题还是有高达9个人关注，所以这边我再说一些更细化的过程吧 在计算排名的时候，我们通常会考虑三个事情 1.上文讲到的，次数+好评率的分布，次数越多好评率越可靠，好评率越高该项越值得推荐 2.时间因素，如果一个项目是10天前推送的，一个项目是昨天推送的，很明显前者的次数远大于后者 3.影响权重，你这边只考虑了喜欢和不喜欢，其实所有的排序不可能只以1个维度考虑，通常会考虑多个维度，比如浏览次数，搜索次数等，你需要考虑每个的重要性或者说权重大小 1这里就不讲了，其他方法也有很多，比如贝叶斯平均的优化版本、再比如经典的Hacker公式： 2.时间因素： 时间越久，代表之前的投票结果对当前的影响越小，这边有很多不同的影响方式，举几个例子： 比如艾宾浩斯遗忘规律： 这里的c、k决定下降速度，业务运用过程中，c值一般在[1,2],k值一般在[1.5,2.5] 比如时效衰减： 这里就是比较常见的移动窗口式的，永远只看近期某一段时间，而且时间内呈线性下降，不过可以改变变化方式 3.不同种的属性对于结果的影响自然不同 举个例子，用户主动搜索和用户浏览相比，用户主动搜索的情况下，用户的需求更为强烈 通常需要判断这些强烈程度都是通过： 相关性：看因变量与自变量之间的相关系数，如：cor函数 importance：看删除或者修改自变量，对应变量的判断影响大小，如：randomForest的重要性 离散程度：看自变量的数据分布是否足够分散，是否具有判断依据，如：变异系数或者pca 等等]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[协同过滤推荐]]></title>
    <url>%2F2017%2F06%2F21%2F%E5%8D%8F%E5%90%8C%E8%BF%87%E6%BB%A4%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[set.seed ( 1234 ) 加载数据包library ( “recommenderlab” ) 构造数据运用recommenderlab包实现协同过滤推荐，其数据类型采用S4类构造，需通过as()函数转为raringMatrix类型。val1&lt;- matrix ( sample ( c ( as.numeric ( 0 : 5 ) ,NA ) ,50 ,replace = TRUE ,prob = c ( rep ( .4 / 6 , 6 ) , .6 ) ) ,ncol = 10 , dimnames = list ( user = paste ( “u” ,1 : 5 ,sep = ‘’ ) ,item = paste ( “i” ,1 : 10 ,sep = ‘’ ) ) ) val2 &lt;- as ( val1, “realRatingMatrix” ) 数据转换 val3&lt;- normalize ( val2 ) 二元分类转换，normalize()函数进行标准化处理，标准化的目的是为了去除用户评分的偏差val4 &lt;- binarize ( val3 , minRating = 4 ) val5 &lt;- as ( val4 , “matrix” ) 数据可视化 接下来，我们采用MovieLense数据集， data ( MovieLense ) key1 &lt;- sample ( MovieLense , 943 , replace = F )image ( MovieLense ) hist ( getRatings ( normalize ( MovieLense ) ) , breaks = 100 ) hist ( rowCounts ( key1 ) , breaks = 50 ) 建立模型 对于realRatingMatrix有六种方法：IBCF(基于物品的推荐)、UBCF（基于用户的推荐）、PCA（主成分分析）、RANDOM（随机推荐）、SVD（矩阵因子化）、POPULAR（基于流行度的推荐） 建立协同过滤推荐算法模型，主要运用recommender(data=ratingMatrix,method,parameter=NULL)函数，getModel()可查看模型参数 key1_recom &lt;- Recommender (key1 , method = “IBCF” ) key1_popul &lt;- Recommender ( key1, method = “POPULAR” ) 查看模型方法names ( getModel ( key1_recom ) ) 模型预测 TOP-N预测 对模型预测可运用predict()函数，在此分别以TOP-N预测及评分预测为例，预测第940-943位观影者的评分情况。n表示最终为TOP-N的列表推荐，参数type = “ratings”表示运用评分预测观影者对电影评分，模型结果均需转为list或矩阵表示 pred &lt;- predict ( key1_popul ,key1 [ 940 : 943,] , n = 5 ) as ( pred , “list” ) top-N为有序列表，抽取最优推荐子集pred3 &lt;- bestN ( pred , n = 3 ) as ( pred3 , “list” ) 评分预测rate &lt;- predict ( key1_popul , key1 [ 940 : 943 ] , type = “ratings” ) as ( rate , “matrix” ) [ , 1 : 5 ] 预测模型评价 评分预测模型评价 eva &lt;- evaluationScheme (key1 [ 1 : 800 ] , method = “split” , train = 0.9,given = 15)method=”split”&amp;train=0.9为按90%划分训练测试集合,given为评价的类目数 r_eva1&lt;- Recommender ( getData ( eva , “train” ) , “UBCF” ) p_eva1&lt;- predict ( r_eva1 , getData ( eva, “known” ) , type = “ratings” ) r_eva2 &lt;- Recommender ( getData ( eva, “train” ) , “IBCF” ) p_eva2 &lt;- predict ( r_eva2 , getData ( eva, “known” ) , type = “ratings” )c_eva1 &lt;- calcPredictionAccuracy ( p_eva1 , getData ( eva , “unknown” ) ) c_eva2 &lt;- calcPredictionAccuracy ( p_eva2 , getData ( eva , “unknown” ) ) error &lt;- rbind ( c_eva1 , c_eva2 ) rownames ( error ) &lt;- c ( “UBCF” , “IBCF” )计算预测模型的准确度 TOP-N预测模型评价 通过4-fold交叉验证方法分割数据集，运用evaluate()进行TOP-N预测模型评价,评价结果可通过ROC曲线及准确率-召回率曲线展示: 4-fold交叉验证tops &lt;- evaluationScheme ( key1 [ 1 : 800 ] , method = “cross” , k = 4 , given = 3 ,goodRating = 5 ) results &lt;- evaluate ( tops , method = “POPULAR” , type = “topNList” ,n = c ( 1 , 3 , 5 , 10 ) ) 获得混淆矩阵getConfusionMatrix ( results ) [ [ 1 ] ] avg ( results ) 推荐算法的比较 除了对预测模型进行评价，还可以对不同推荐算法进行比较。可首先构建一个推荐算法列表，通过ROC曲线、、准确率-召回率曲线或RMSE直方图进行比较 TOP-N算法比较 set.seed ( 2016 ) scheme &lt;- evaluationScheme ( key1 , method = “split” , train = 0.9 , k = 1 , given = 10 , goodRating = 5 ) 构建不同算法模型results &lt;- evaluate ( scheme ,test_data ,n = c ( 1 ,3 ,5 ,10 ,15 ,20 ) ) 模型比较#ROC曲线plot ( results , annotate = c ( 1 , 3 ) , legend = “bottomright” ) 准确率-召回率曲线plot ( results , “prec/rec” , annotate = c ( 2 , 3 , 4 ) , legend = “topleft” ) 预测评分算法比较 results2 &lt;- evaluate ( scheme , algorithms , type = “ratings” ) plot ( results2 , ylim = c ( 0 , 20 ) )]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>推荐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[聚类算法思路总结]]></title>
    <url>%2F2017%2F06%2F20%2F%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95%E6%80%9D%E8%B7%AF%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1.cost function 1.1 距离 常见的为欧式距离（L1 norm）&amp;&amp;p=2，拓展的可以有闵可夫斯基距离（L2 norm）&amp;&amp;p=1： 当p趋向于无穷的时候，切比雪夫距离（Chebyshev distance）： 红色的时候为切比雪夫距离，蓝色为闵可夫斯基距离，绿色为欧式距离。 1.2相似系数 夹角余弦及相关系数，相关系数不受线性变换的影响，但是计算速度远慢于距离计算。 1.3dynamic time warping动态时间规整 举例子： 序列A：1,1,1,10,2,3，序列B：1,1,1,2,10,3 欧式距离：distance[i][j]=(b[j]-a[i])*(b[j]-a[i])来计算的话，总的距离和应该是128 应该说这个距离是非常大的，而实际上这个序列的图像是十分相似的。因为序列A中的10对应得是B中的2，A中的2对应的B中的10，导致计算膨胀，现在将A中的10对应B中的10，A中的1对应B中的2再计算，膨胀因素会小很多（时间前推一步）。 2.聚类算法 2.1分层聚类： 自上而下：所有点先聚为一类，然后分层次的一步一步筛出与当前类别差异最大的点 自下而上：所有点先各自为一类，组合成n个类的集合，然后寻找出最靠近的两者聚为新的一类，循环往复 数值类分类：（适用于计算量巨大或者数据量巨大的时候） BIRCH算法，层次平衡迭代规约和聚类， 主要参数包含：聚类特征和聚类特征树： 聚类特征： 给定N个d维的数据点{x1,x2,….,xn}，CF定义如下：CF=（N，LS，SS）,其中，N为子类中的节点的个数，LS是子类中的N个节点的线性和，SS是N个节点的平方和 存在计算定义：CF1+CF2=（n1+n2, LS1+LS2, SS1+SS2） 假设簇C1中有三个数据点：（2,3），（4,5），（5,6），则CF1={3，（2+4+5,3+5+6），（2^2+4^2+5^2,3^2+5^2+6^2）}={3，（11,14），（45,70）} 假设一个簇中，存在质心C和半径R，若有xi，i=1…n个点属于该簇，质心为：C=(X1+X2+…+Xn)/n，R=(|X1-C|^2+|X2-C|^2+…+|Xn-C|^2)/n 其中，簇半径表示簇中所有点到簇质心的平均距离。当有一个新点加入的时候，属性会变成CF=（N，LS，SS）的统计值，会压缩数据。 聚类特征树： 内节点的平衡因子B，子节点的平衡因子L，簇半径T。 B=6，深度为3，T为每个子节点中簇的范围最大不能超过的值，T越大簇越少，T越小簇越多。 名义分类： ROCK算法：凝聚型的层次聚类算法 1.如果两个样本点的相似度达到了阈值（θ），这两个样本点就是邻居。阈值（θ）有用户指定，相似度也是通过用户指定的相似度函数计算。常用的分类属性的相似度计算方法有：Jaccard系数，余弦相似度 Jaccard系数：J=|A∩B|/|A∪B|，一般用于分类变量之间的相似度 余弦相似度：【-1，1】之间，越趋近于0的时候，方向越一致，越趋向同一。 2.目标函数（criterion function）：最终簇之间的链接总数最小，而簇内的链接总数最大 3.相似度合并：遵循最终簇之间的链接总数最小，而簇内的链接总数最大的规则计算所有对象的两两相似度，将相似性最高的两个对象合并。通过该相似性度量不断的凝聚对象至k个簇，最终计算上面目标函数值必然是最大的。 load(‘country.RData’) d&lt;-dist(countries[,-1]) x&lt;-as.matrix(d) library(cba) rc &lt;-rockCluster(x, n=4, theta=0.2, debug=TRUE) KNN算法： 先确定K的大小，计算出每个点之外的所有点到这个目标点的距离，选出K个最近的作为一类。一般类别之间的归类的话，投票和加权为常用的，投票及少数服从多数，投票的及越靠近的点赋予越大的权重值。 2.2分隔聚类： 需要先确定分成的类数，在根据类内的点都足够近，类间的点都足够远的目标去做迭代。 常用的有K-means，K-medoids，K-modes等，只能针对数值类的分类，且只能对中等量级数据划分，只能对凸函数进行聚类，凹函数效果很差。 2.3密度聚类： 有效的避免了对分隔聚类下对凹函数聚类效果不好的情况，有效的判别入参主要有1:单点外的半径2：单点外半径内包含的点的个数 DBSCAN为主要常见的算法，可优化的角度是现在密度较高的地方进行聚类，再往密度较低的地方衍生，优化算法：OPTICS。 2.4网格聚类： 将n个点映射到n维上，在不同的网格中，计算点的密度，将点更加密集的网格归为一类。 优点是：超快，超级快，不论多少数据，计算速度只和维度相关。 缺点：n维的n难取，受分布影响较大（部分行业数据分布及其不规则） 2.5模型聚类： 基于概率和神经网络聚类，常见的为GMM，高斯混合模型。缺点为，计算量较大，效率较低。 GMM：每个点出现的概率：将k个高斯模型混合在一起，每个点出现的概率是几个高斯混合的结果 假设有K个高斯分布，每个高斯对data points的影响因子为πk，数据点为x，高斯参数为theta，则： 利用极大似然的方法去求解均值Uk，协方差矩阵（Σk），影响因子πk，但是普通的梯度下降的方法在这里求解会很麻烦，这边就以EM算法代替估计求解。 3.优化数据结构： 1.数据变换： logit处理，对所有数据进行log变换 傅里叶变换 小波变换 2.降维： PCA： 利用降维（线性变换)的思想，整体方差最大的情况下（在损失很少信息的前提下），把多个指标转化为几个不相关的综合指标（主成分),将变量线性组合代替原变量，保持代替后的数据信息量最大（方差最大）。 LLE： (1) 寻找每个样本点的k个近邻点； (2)由每个样本点的近邻点计算出该样本点的局部重建权值矩阵； (3)由该样本点的局部重建权值矩阵和其近邻点计算出该样本点的输出值。 (换句话说，就是由周围N个点构成改点的一个向量矩阵表示）]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>聚类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用R语言包介绍]]></title>
    <url>%2F2017%2F06%2F19%2F%E5%B8%B8%E7%94%A8R%E8%AF%AD%E8%A8%80%E5%8C%85%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[r与python差异比较大的一个地方就是，python的机器学习算法集中程度比较高，比如sklearn，就集成了很多的算法，而R语言更多时候需要一个包一个包去了解，比较费时费力，对于python转过来的朋友非常不友好，抽空整理了工作中常用的R包如下： 常用检验函数： 基本上分布中常见的都罗列了： 常用作图函数包： ggplot2：万能，基本上excel能画的图它都能画 rattle：fancyRpartPlot函数，决策树画图函数 基础包函数：barplot、pie、dotchart、hist、densityplot、boxplot、contour等等 正态检验：qqplot、qqline、qqnorm 连续分类回归模型： stats包 lm函数，实现多元线性回归；glm函数，实现广义线性回归；nls函数，实现非线性最小二乘回归；knn函数，k最近邻算法 rpart包 rpart函数，基于CART算法的分类回归树模型 randomForest包 randomForest函数，基于rpart算法的集成算法 e1071包 svm函数，支持向量机算法 kernlab包 ksvm函数，基于核函数的支持向量机 nnet包 nnet函数，单隐藏层的神经网络算法 neuralnet包 neuralnet函数，多隐藏层多节点的神经网络算法 RSNNS包 mlp函数，多层感知器神经网络；rbf函数，基于径向基函数的神经网络 离散分类回归模型： stats包 glm函数，实现Logistic回归，选择logit连接函数 kknn包 kknn函数，加权的k最近邻算法 rpart包 rpart函数，基于CART算法的分类回归树模型 adabag包bagging函数，基于rpart算法的集成算法；boosting函数，基于rpart算法的集成算法 party包ctree函数，条件分类树算法 RWeka包OneR函数，一维的学习规则算法；JPip函数，多维的学习规则算法；J48函数，基于C4.5算法的决策树 C50包C5.0函数，基于C5.0算法的决策树 e1071包naiveBayes函数，贝叶斯分类器算法 klaR包NaiveBayes函数，贝叶斯分类器算分 MASS包lda函数，线性判别分析；qda函数，二次判别分析 聚类：Nbclust包Nbclust函数可以确定应该聚为几类 stats包kmeans函数，k均值聚类算法；hclust函数，层次聚类算法 cluster包pam函数，k中心点聚类算法 fpc包dbscan函数，密度聚类算法；kmeansruns函数，相比于kmeans函数更加稳定，而且还可以估计聚为几类；pamk函数，相比于pam函数，可以给出参考的聚类个数 mclust包Mclust函数，期望最大（EM）算法 关联规则：arules包apriori函数 Apriori关联规则算法 recommenderlab协调过滤 DRM：重复关联 ECLAT算法： 采用等价类，RST深度搜索和集合的交集： eclat 降维算法： psych包prcomp函数、factanal函数 时序分析： ts时序构建函数 timsac包时序分析 holtwinter包时序分析 decomp、tsr、stl成分分解 zoo 时间序列数据的预处理 统计及预处理： 常用的包 Base R, nlme aov, anova 方差分析 density 密度分析 t.test, prop.test, anova, aov:假设检验 rootSolve非线性求根 reshape2数据预处理 plyr及dplyr数据预处理大杀器 最后剩下常用的就是读入和写出了： RODBC 连接ODBC数据库接口 jsonlite 读写json文件 yaml 读写yaml文件 rmakdown写文档 knitr自动文档生成 一般业务中使用比较多的就是上面这些了，当然R里面有很多冷门的包，也很好用滴~]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>R语言工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[决策树及衍射指标]]></title>
    <url>%2F2017%2F06%2F02%2F%E5%86%B3%E7%AD%96%E6%A0%91%E5%8F%8A%E8%A1%8D%E5%B0%84%E6%8C%87%E6%A0%87%2F</url>
    <content type="text"><![CDATA[一、常用的决策树节点枝剪的衡量指标： 熵： 如果一件事有k种可的结果，每种结果的概率为 pi（i＝1…k） 该事情的信息量： 熵越大，随机变量的不确定性越大。 信息增益： 特征A对训练数据集D的信息增益g(D,A)，定义为集合D的经验熵H(D)与特征A给定条件下的经验条件熵H(D|A)之差 换句话说，就是原信息集下的信息量－在A特征条件下的信息集的信息量 信息增益越大，信息增多，不确定性减小 信息增益率： 信息增益率定义:特征A对训练数据集D的信息增益比定义为其信息增益与训练数据D关于特征A的值的熵HA(D)之比 注：p：每个唯独上，每个变量的个数／总变量个数 二、常用的决策树介绍： ID3算法： ID3算法的核心是在决策树各个子节点上应用信息增益准则选择特征，递归的构建决策树，具体方法是:从根节点开始，对节点计算所有可能的特征的信息增益，选择信息增益最大的特征作为节点的特征，由该特征的不同取值建立子节点；再对子节点递归调用以上方法，构建决策树。 解释：在做每次选择差分枝的时候，以不确定性最小点作为loss fuction，直到无法细分 缺点： 1.ID3算法只有树的生成，所以该算法生成的树容易产生过拟合，分得太细，考虑条件太多。 2.不能处理连续属性 3.选择具有较多分枝的属性，而分枝多的属性不一定是最优的选择。 4.局部最优化，整体熵值最小，贪心算法算子节点的分支 C4.5算法： 基于ID3算法，用信息增益比来选择属性，对非离散数据也能处理，能够对不完整数据进行处理。 采用增益率（GainRate）来选择分裂属性。计算方式如下： CART算法： CART算法选择分裂属性的方式是比较有意思的，首先计算不纯度，然后利用不纯度计算Gini指标。 计算每个子集最小的Gini指标作为分裂指标。 不纯度的计算方式为： pi表示按某个变量划分中，目标变量不同类别的概率。 某个自变量的Gini指标的计算方式如下： 计算出每个每个子集的Gini指标，选取其中最小的Gini指标作为树的分支（Gini（D）越小，则数据集D的纯度越高）。连续型变量的离散方式与信息增益中的离散方式相同。 三、基于决策树的一些集成算法： 随机森林： 随机生成n颗树，树之间不存在关联，取结果的时候，以众数衡量分类结果；除了分类，变量分析，无监督学习，离群点分析也可以。 生成过程： 1.n个样本，随机选择n个样本（有放回），训练一颗树 从原始训练数据集中,应用bootstrap方法有放回地随机抽取 K个新的自助样本集,并由此构建 K棵分类回归树,每次未被抽到的样本组成了 K个袋外数据(Out-of-bag,OOB) 2.每个样本有M个属性，随机选m个，采取校验函数（比如信息增益、熵啊之类的），选择最佳分类点 3.注意，每个树不存在枝剪 4.将生成的多棵树组成随机森林,用随机森林对新的数据进行分类,分类结果按树分类器的投票多少而定 树的个数随机选取，一般500，看三个误差函数是否收敛；变量的个数一般取均方作为mtry GBDT： DT步骤： GBDT里面的树是回归树！ GBDT做每个节点上的分支的时候，都会以最小均方误差作为衡量（真实值－预测值）的平方和／N，换句话说，就是存在真实线l1，预测线l2，两条线之间的间距越小越好。 BT步骤： GBDT的核心就在于，每一棵树学的是之前所有树结论和的残差，这个残差就是一个加预测值后能得真实值的累加量。 换句话说，就是第一次预测的差值记为下一次预测的初始值，一直到某一次计算出的差值为0，把前n次的结果相加，就是一个真实预测。 Adaboost： 步骤： 1.初始化所有训练样例的权重为1 / N,其中N是样本数 2.对其中第1~m个样本: a.训练m个弱分类器，使其最小化bias： b.接下来计算该弱分类器的权重α，降低错判的分类器的权重，： c.更新权重： 3.最后得到组合分类器： 核心的思想如下图： 全量数据集在若干次训练后，降低训练正确的样本的权重，提高训练错误样本的权重，得到若干个Y对应的分类器，在组合投票得到最终的分类器 四、惠普实验室-集成并行化的随机森林：]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>树划分问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[因子分析原理剖析]]></title>
    <url>%2F2017%2F06%2F02%2F%E5%9B%A0%E5%AD%90%E5%88%86%E6%9E%90%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90%2F</url>
    <content type="text"><![CDATA[因子分析概述： 因子分析分为Q型和R型，我们对R型进行如下研究： 一.因子分析步骤： 1.确认是是否适合做因子分析 2.构造因子变量 3.旋转方法解释 4.计算因子变量得分 二.因子分析的计算过程： 1.将原始数据标准化 目的：消除数量级量纲不同 2.求标准化数据的相关矩阵 3.求相关矩阵的特征值和特征向量 4.计算方差贡献率和累计方差贡献率 5.确定因子 F1,F2,F3…为前m个因子包含数据总量（累计贡献率）不低于80%。可取前m各因子来反映原评价 6.因子旋转 当所得因子不足以明显确定或不易理解时选择此方法 7.原指标的线性组合求各因子的得分 两种方法：回归估计和barlett估计法 8.综合得分：以各因子的方差贡献率为权，各因子的线性组合得到各综合评价指标函数 F=（λ1F1+…λmFm）/(λ1+…λm) =W1F1+…WmFm 9.得分排序 因子分析详解： 因子分析模型，又名正交因子模型 X=AF+ɛ 其中： X=[X1,X2,X3…XP]‘ A= F=[F1,F2…Fm]’ ɛ=[ɛ1,ɛ2…ɛp]’ 以上满足： （1）m小于等于p （2）cov(F,ɛ)=0 (3)Var(F)=Im D(ɛ)=Var(ɛ)= ɛ1,ɛ2…ɛp不相关，且方差不同 我们把F成为X公共因子，A为荷载矩阵，ɛ为X特殊因子 A=(aij) 数学上证明：aij就是i个变量与第j个因子的相关系数，参见层次分析法aij定义。 荷载矩阵 就荷载矩阵的估计和解释方法有主因子和极大似然估计，我们就主因子分析而言：（是主因子不是主成份） 设随机向量X的协方差阵为Ʃ λ1,λ2,λ3..&gt;0为Ʃ的特征根 μ1，μ2，μ3…为对应的标准正交向量 我们大一学过线代或者高代，里面有个东西叫谱分析： Ʃ=λ1μ1μ1’+……+λpμpμp’ = 当因子个数和变量个数一样多，特殊因子方差为0. 此时，模型为X=AF,其中Var(F)=Ip 于是，Var(X)=Var(AF)=AVar(F)A’=AA’ 对照Ʃ分解式,A第j列应该是 也就是说，除了uj前面部分，第j列因子签好为第j个主成份的系数，所以为主成份法。 如果非要作死考虑ɛ 原来的协方差阵可以分解为： Ʃ=AA’+D= 以上分析的目的； 1.因子分析模型是描述原变量X的协方差阵Ʃ的一种模型 2.主成份分析中每个主成份相应系数是唯一确定的，然而因子分析中的每个因子的相应系数不是唯一的，因而我们的因子荷载矩阵不是唯一的 (主成分分析是因子分析的特例，非常类似，有兴趣的可以去看看，这两者非常容易混淆) 共同度和方差贡献 无论是在spss或者R的因子分析中都围绕着贡献度，我们来看下，它到底是什么意思。 由因子分析模型，当仅有一个公因子F时， Var(Xi)=Var(aiF)+Var(ɛi) 由于数据标准化，左端为1，右端分别为共性方差和个性方差 共性方差越大，说明共性因子作用越大。 因子载荷矩阵A中的第i行元素之平方和记为hi2 成为变量(Xi)共同度 它是公共因子对(Xi)的方差锁做出的贡献，反映了全部公共因子对变量(Xi)的影响。 hi2大表明第i个分量对F的每一个分量F1,F2,…Fm的共同依赖程度大 将因子载荷矩阵A的第j列的各元素的平方和记为gj2 成为公共因子Fj对x的方差贡献。 gj2表示第j个公共因子Fj对x的每一个分量Xi所提供的方差的总和，他就是衡量公共因子的相对重要行的指标。gj2越大，表明公共因子Fj对x的贡献越大，或者说对x的影响和作用就越大。 如果将载荷矩阵A的所有gj2都计算出来，按大小排列，就可以提炼最有影响力的公共因子。 因子旋转 这方面涉及较为简单，我就简单提一下 目的：建立因子分析模型不是只要找主因子，更加重要的是意义，以便对实际进行分析，因子旋转就是使所得结论更加清晰的表示。 方法：正交旋转，斜交旋转两大类，常用正交。 便于理解，我解释下旋转的意义，以平面直角坐标系为例，我们想得到的数据正好为：y=x和y=-x上的点，我们能解释的却在x=0和y=0上，这时候我们就可以旋转坐标系，却不影响结果。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>因子分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则化-Lasso规约]]></title>
    <url>%2F2017%2F06%2F02%2F%E6%AD%A3%E5%88%99%E5%8C%96-Lasso%E8%A7%84%E7%BA%A6%2F</url>
    <content type="text"><![CDATA[摘要：lasso的目的主要是避免数据拟合过渡，导致训练数据效果优秀，测试数据效果较差 先看一波过拟合： 图中，红色的线存在明显的过拟合，绿色的线才是合理的拟合曲线，为了避免过拟合，我们可以引入正则化。 下面可以利用正则化来解决曲线拟合过程中的过拟合发生，存在均方根误差也叫标准误差，即为√[∑di^2/n]=Re，n为测量次数；di为一组测量值与真值的偏差。 实际考虑回归的过程中，我们需要考虑到误差项， 这个和简单的线性回归的公式相似，而在正则化下来优化过拟合这件事情的时候，会加入一个约束条件，也就是惩罚函数： 这边这个惩罚函数有多种形式，比较常用的有l1,l2，大概有如下几种： 讲一下比较常用的两种情况，q＝1和q＝2的情况：q＝1，也就是今天想讲的lasso回归，为什么lasso可以控制过拟合呢，因为在数据训练的过程中，可能有几百个，或者几千个变量，再过多的变量衡量目标函数的因变量的时候，可能造成结果的过度解释，而通过q＝1下的惩罚函数来限制变量个数的情况，可以优先筛选掉一些不是特别重要的变量，见下图： 作图只要不是特殊情况下与正方形的边相切，一定是与某个顶点优先相交，那必然存在横纵坐标轴中的一个系数为0，起到对变量的筛选的作用。q＝2的时候，其实就可以看作是上面这个蓝色的圆，在这个圆的限制下，点可以是圆上的任意一点，所以q＝2的时候也叫做岭回归，岭回归是起不到压缩变量的作用的，在这个图里也是可以看出来的。 lasso回归：lasso回归的特色就是在建立广义线型模型的时候，这里广义线型模型包含一维连续因变量、多维连续因变量、非负次数因变量、二元离散因变量、多元离散因变，除此之外，无论因变量是连续的还是离散的，lasso都能处理，总的来说，lasso对于数据的要求是极其低的，所以应用程度较广；除此之外，lasso还能够对变量进行筛选和对模型的复杂程度进行降低。这里的变量筛选是指不把所有的变量都放入模型中进行拟合，而是有选择的把变量放入模型从而得到更好的性能参数。 复杂度调整是指通过一系列参数控制模型的复杂度，从而避免过度拟合(Overfitting)。 对于线性模型来说，复杂度与模型的变量数有直接关系，变量数越多，模型复杂度就越高。 更多的变量在拟合时往往可以给出一个看似更好的模型，但是同时也面临过度拟合的危险。lasso的复杂程度由λ来控制，λ越大对变量较多的线性模型的惩罚力度就越大，从而最终获得一个变量较少的模型。除此之外，另一个参数α来控制应对高相关性(highly correlated)数据时模型的性状。 lasso回归α=1，Ridge回归α=0，这就对应了惩罚函数的形式和目的。我们可以通过尝试若干次不同值下的λ，来选取最优λ下的参数，还可以结合CV选择最优秀的模型。 读取数据123456789101112setwd(&quot;~/Desktop&quot;)library(glmnet)train_origin&lt;-read.table(&apos;trian.txt&apos;,header = T,fill = T)test_origin&lt;-read.table(&apos;test.txt&apos;,header = T,fill = T)train_test1&lt;-train_origintrain_test1&lt;-train_test1[,-9]train_test1$tag&lt;-as.factor(train_test1$tag)train_test1$risk_level&lt;-as.factor(train_test1$risk_level)x&lt;-train_test1[,3:11]y&lt;-train_test1[,2]## one hot encodingx1&lt;-model.matrix(~., x) 通常数据中会存在离散点，而lasso在R里面是通过数值矩阵来做输入的，所以需要对原数据做一步预处理，不然这边会抛错误；除此之外，如果数据之间差别的数量级较大，还需要进行标准化，R里面也是可以进行处理的，这边就不赘述了，glmnet()函数中添加参数standardize = TRUE来实现，scale()函数也可以实现，自行选择即可。 模型训练1model = glmnet(x1, y, family=&quot;binomial&quot;, nlambda=50, alpha=1) family里面是指选择函数的类型：family explation,gaussian univariate,mgaussian multivariate,poisson count,binomial binary,multinomial categorylambda是指随机选择λ，做lambda个模型；alpha是上述讲到的α，选择惩罚函数，正常情况下，1是lasso，0是岭回归这边模型拓展可以交叉检验一下，有内置的函数：cvmodel = cv.glmnet(x1, y, family = “binomial”, type.measure = “class”,nfolds=10)这边会多出来一个type.measure，这个type.measure是指期望最小化的目标参量是什么，换句话说，就是衡量这个模型的指标函数是啥：type.measure detailsdeviance: -2倍的Log-likelihoodmse:mean squred errormae:mean absolute errorclass:missclassification errorauc:area under the ROC curve比较常用的是auc，这个就是现在比较主流的衡量一个模型好坏的roc所衍生出来的一个值；我们这边用的是class，也就是模型错误分配的概率，结合我这次业务开发的实际业务场景，这个更合适一点；nfolds是指folds数目，也可以通过foldid数来控制每个fold里面的数据数量。对于glmnet，可以通过plot(model)来观察每个自变量的变化轨迹，cv.glmnet可以通过plot(cvmodel)举个plot(cvmodel)的例子： 可以通过c(cvfit$lambda.min, cvfit$lambda.1se)来看在所有的λ值中，得到最小目标函数type.measure均值的cvfit$lambda.min，以及其所对应的λ值可接受的一个标准误差之内对应的cvfit$lambda.1se。我们可以print(model)，在实际的选择模型中λ值的过程里，存在三个指标：df：自由度， %Dev：残差被解释的占比，也就是模型的好坏程度，类似于线性模型中的R平方，Lambda也就是λ值所对应的值，然后我们可以通过coef(fit, s=c(fit$lambda[35],0.002))得出当时模型所对应的系数。 最后，讲一下elastic netelastic net融合了l1范数和l2范数两种正则化的方法，上面的岭回归和lasso回归都可以看做它的特例： elastic net对于p远大于n,或者严重的多重共线性情况有明显的效果，很好理解，当alpha接近1时，elastic net表现很接近lasso，一般来说，elastic net是岭回归和lasso的很好的折中，当alpha从0变化到1，目标函数的稀疏解（部分变量的系数为0）也从0单调增加到lasso的稀疏解。 特征规约初步总结如下：1）子集选择 这是传统的方法，包括逐步回归和最优子集法等，对可能的部分子集拟合线性模型，利用判别准则 （如AIC,BIC,Cp,调整R2 等）决定最优的模型2）收缩方法（shrinkage method） 收缩方法又称为正则化（regularization）。主要是岭回归（ridge regression）和lasso回归。通过对最小二乘估计加入罚约束，使某些系数的估计为0。（岭回归：消除共线性；模的平方处理；Lasso回归：压缩变量，起降维作用；模处理）(3)维数缩减 主成分回归（PCR）和偏最小二乘回归（PLS）的方法。把p个预测变量投影到m维空间 部分图片转载于：http://bbs.pinggu.org/thread-3848519-1-1.html]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>正则化问题</tag>
      </tags>
  </entry>
</search>
